<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/default" title="Ztxpp's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="ztxpp.cc/page/4/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Ztxpp's Blog</title>
  <meta name="generator" content="Hexo 5.1.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ztxpp's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/Base/">
        <li class="mobile-menu-item">文档
          </li>
      </a><a href="/life/">
        <li class="mobile-menu-item">生活
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ztxpp's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/Base/">
            文档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/life/">
            生活
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/dubbo/">Dubbo</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>Apache Dubbo™ (incubating)是一款高性能Java RPC框架。具有面向接口的“远程方法调用”，“智能容错和负载均衡”，以及“服务自动注册和发现”的三大功能。本文是基于慕课网的 2小时实战Apache顶级项目-RPC框架Dubbo分布式服务调度 的学习笔记。</p>
</blockquote>
<h1 id="1-Dubbo基础知识"><a href="#1-Dubbo基础知识" class="headerlink" title="1.Dubbo基础知识"></a>1.Dubbo基础知识</h1><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/dubbo/1.%20dubbo%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84.png" alt="Dubbo的架构"></p>
<h2 id="2-Dubbo支持的通信协议"><a href="#2-Dubbo支持的通信协议" class="headerlink" title="2. Dubbo支持的通信协议"></a>2. Dubbo支持的通信协议</h2><p>推荐使用：</p>
<ul>
<li>RPC协议/Dubbo协议：同构项目（同样结构，搭建框架相同）</li>
<li>Http协议的Rest Api（走Json序列化）：通用项目</li>
</ul>
<p>Dubbo支持8种通信协议，分别是</p>
<ul>
<li>1、dubbo 协议 (默认)</li>
<li>2、rmi 协议</li>
<li>3、hessian 协议</li>
<li>4、http 协议</li>
<li>5、webservice 协议</li>
<li>6、thrift 协议</li>
<li>7、memcached 协议</li>
<li>8、redis 协议</li>
</ul>
<h2 id="3-利用dubbo在具体的业务场景中需要考虑的相关知识："><a href="#3-利用dubbo在具体的业务场景中需要考虑的相关知识：" class="headerlink" title="3. 利用dubbo在具体的业务场景中需要考虑的相关知识："></a>3. 利用dubbo在具体的业务场景中需要考虑的相关知识：</h2><ul>
<li>服务拆分：eg:商品服务；用户商城；订单服务；支付服务。</li>
<li>服务解耦：明确职责、服务调度、网络通信。</li>
<li>服务管理：统一注册中心配置管理（发布注册；订阅调度）。</li>
</ul>
<h1 id="2-搭建基于Dubbo-Zookeeper的SpringBoot项目Demo"><a href="#2-搭建基于Dubbo-Zookeeper的SpringBoot项目Demo" class="headerlink" title="2. 搭建基于Dubbo+Zookeeper的SpringBoot项目Demo"></a>2. 搭建基于Dubbo+Zookeeper的SpringBoot项目Demo</h1><h2 id="1-搭建基本的工程："><a href="#1-搭建基本的工程：" class="headerlink" title="1. 搭建基本的工程："></a>1. 搭建基本的工程：</h2><p>不做详细介绍，只讲基本步骤：</p>
<ul>
<li>利用IDEA创建SpringBoot工程，引入相关依赖（Zookeeper依赖，dubbo依赖）</li>
<li>创建两大dubbo的配置文件<ul>
<li>Spring-dubbo.xml:<ul>
<li>注解发布的dubbo服务所在的包</li>
<li>配置支持的两种调用方式对应的协议 RPC,http</li>
<li>消费服务配置</li>
</ul>
</li>
<li>dubbo.properties:<ul>
<li>配置两大协议对应的端口信息</li>
</ul>
</li>
</ul>
</li>
<li>下载Zookeeper，需要启动 ZKserver</li>
<li>运行项目</li>
</ul>
<p>项目结构：</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/dubbo/2.%20%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1SpringBoot%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE.png" alt="工程结构："></p>
<h2 id="2-具体的应用场景实战-基于RPC-Dubbo协议的调用方式"><a href="#2-具体的应用场景实战-基于RPC-Dubbo协议的调用方式" class="headerlink" title="2. 具体的应用场景实战-基于RPC/Dubbo协议的调用方式"></a>2. 具体的应用场景实战-基于RPC/Dubbo协议的调用方式</h2><ol>
<li><p>场景的需求分析： （商品列表服务）<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/dubbo/3.%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.png" alt="场景的需求分析"></p>
</li>
<li><p>实现思路：</p>
<ol>
<li>创建 dubboOne项目（商品库存服务），按照上述描述，引入依赖，创建dubbo两大配置文件，并且实现一些商品列表服务接口，等待调用。</li>
<li>创建 dubboTwo项目（商城平台服务），按照上述描述，引入依赖，创建dubbo两大配置文件。</li>
<li>将 dubboOne项目 mvn clean &gt; mvn install 到本地的maven仓库，dubboTwo项目的pom.xml文件则可引入dubboOne的api模块的这个jar包。作为服务间通信的规范和桥梁。如果修改了dubboOne的接口，需要重新mvn clean &gt; mvn install。 （mvn clean 删除本地maven库里的包， mvn install 将这个dubboOne聚合项目生成的jar包 install到本地的maven库里面，dubboTwo项目才能找到）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--dubboTwo引入了dubboOne发布的api--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.debug.mooc.dubbo.one<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
启动 zookeeper的server，运行 dubboOne(provider)，运行dubboTwo(consumer) , 调用dubboTwo 的controller中的接口。</li>
</ol>
</li>
<li><p>注意：</p>
</li>
</ol>
<ul>
<li>基于RPC的调用方式，在dubboTwo项目中调用 dubboOne提供的接口，需要dubboTwo引入dubboOne的api模板的jar包。dubboTwo配置dubbo相关信息后，经过Spring的自动装配，犹如本地调用一般自然。</li>
<li>entity都要implements Serializble， 因为走网络通信需要实现序列化。</li>
</ul>
<h2 id="3-具体的应用场景实战-基于http协议的调用方式"><a href="#3-具体的应用场景实战-基于http协议的调用方式" class="headerlink" title="3. 具体的应用场景实战-基于http协议的调用方式"></a>3. 具体的应用场景实战-基于http协议的调用方式</h2><ol>
<li>场景的需求分析 （用户下单服务）   </li>
</ol>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/dubbo/4.restFul%20%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90.png" alt="场景的需求分析 （用户下单服务）"></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/mysql/">mysql 优化</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span></div>
    </header>

    <div class="post-content"><p>MYSQL相关</p>
<h1 id="1-Mysql索引（InnerDB）"><a href="#1-Mysql索引（InnerDB）" class="headerlink" title="1. Mysql索引（InnerDB）"></a>1. Mysql索引（InnerDB）</h1><h2 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table  information(</span><br><span class="line">    -&gt; inf_id  int(11)  auto_increment  primary  key  not  null,</span><br><span class="line">    -&gt; name  varchar(50)  not  null,</span><br><span class="line">    -&gt; sex  varchar(5)  not null,</span><br><span class="line">    -&gt; birthday  varchar(50)  not  null,</span><br><span class="line">    -&gt; index  info(name,sex)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>

<p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41573234/article/details/80250279">https://blog.csdn.net/qq_41573234/article/details/80250279</a></p>
<h2 id="2-索引的概念"><a href="#2-索引的概念" class="headerlink" title="2. 索引的概念"></a>2. 索引的概念</h2><h3 id="2-1-意义："><a href="#2-1-意义：" class="headerlink" title="2.1 意义："></a>2.1 意义：</h3><p>想使用某种快速查找的算法，这前提必须是建立在某种有规律的特定的数据结构之上的。我们创建索引的过程，就是创建为了实现快速查找算法所必须的数据结构的过程。而在mysql中，想使用索引实现快速查找，可以简单理解为：必须要求索引的数据是按顺序排列的。</p>
<h3 id="2-2-实现方式"><a href="#2-2-实现方式" class="headerlink" title="2.2 实现方式"></a>2.2 实现方式</h3><p>Mysql中，索引由 B+ Tree 实现，不用红黑树的原因：</p>
<p>前言：</p>
<p>B/B+树上操作的时间通常由 存取磁盘 的时间和 CPU计算时间 这两部分构成，这即是说，整个查询是由：</p>
<ul>
<li>机械臂移动到对应的节点的时间：【层数】 logm N</li>
<li>在这个节点上查找的时间（如果是二分查找则最快）：【每层的比较数】 log2 M</li>
</ul>
<p>(整体查找相率为 logm N * log2 M = log2 N)，而且减少了磁盘的IO（所谓的IO就是磁头移动的次数）</p>
<p>标准回答:</p>
<ul>
<li>更少的查找次数： 平衡树的查找深度与树高相关, B+树的出度更大，红黑树出度=2</li>
<li>利用了磁盘的预读特性，数据库系统将索引的一个节点大小设置为页的大小，一次I/O就能完全载入一个节点。</li>
</ul>
<h2 id="3-优化查询"><a href="#3-优化查询" class="headerlink" title="3. 优化查询"></a>3. 优化查询</h2><h3 id="3-1-单列索引"><a href="#3-1-单列索引" class="headerlink" title="3.1 单列索引"></a>3.1 单列索引</h3><p>算法成本：二叉树查找法，通过有规律的数据结构，快速定位到某个数据，比全表扫描快。使用索引之后，在一般情况下，无论是IO成本还是计算查找成本都远低于全表扫描。</p>
<h3 id="3-2-多列索引（最左前缀查找）"><a href="#3-2-多列索引（最左前缀查找）" class="headerlink" title="3.2 多列索引（最左前缀查找）"></a>3.2 多列索引（最左前缀查找）</h3><ul>
<li><p>多列索引的本质是：对表重新进行 复合排序。</p>
</li>
<li><p>最佳设计是：按照索引的第一个元素进行二分查找，再按照 索引的 第二个元素进行二分查找。</p>
</li>
<li><p>符合最佳设计的复杂索引，要比 单列索引 查找快 （前者是多次二分查找，后者是先二分查找出所有，再扫描找）</p>
</li>
<li><p>mysql查询优化器会判断纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p>
</li>
</ul>
<p>例如 index info(name,cid), 会按照 name先排序，name 相同的情况下，再按照 cid 排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用到索引来查找：</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE name&#x3D;&#39;小红&#39;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM student WHERE cid&#x3D;1 AND name&#x3D;&#39;小红&#39;;</span><br><span class="line">等价于</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE name&#x3D;&#39;小红&#39; AND cid&#x3D;1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">没有使用索引查找：</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE cid&#x3D;1;</span><br></pre></td></tr></table></figure>

<h1 id="2-MYSQL优化"><a href="#2-MYSQL优化" class="headerlink" title="2. MYSQL优化"></a>2. MYSQL优化</h1><h2 id="2-1-学会查看sql语句的执行的各项性能消耗"><a href="#2-1-学会查看sql语句的执行的各项性能消耗" class="headerlink" title="2.1 学会查看sql语句的执行的各项性能消耗"></a>2.1 学会查看sql语句的执行的各项性能消耗</h2><p>在MySQL数据库中，可以通过配置profiling参数来启用SQL剖析。但是这个功能默认是关闭的。</p>
<ul>
<li><p>查看是否开启：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%pro%&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令开启：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profiling &#x3D;1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启后，执行sql语句，然后使用命令查看执行过的语句的耗时：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from stu;</span><br><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一个具体语句的详细情况,可以查看该sql语句每执行步骤的cpu、 io、 memory 等消耗情况：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show profile for query 3;</span><br><span class="line">show profile cpu,block io for query 4;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-2-多表查询的优化"><a href="#2-2-多表查询的优化" class="headerlink" title="2.2 多表查询的优化"></a>2.2 多表查询的优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from  stu  where  class_id  in (select id from class);</span><br><span class="line"></span><br><span class="line">select * from stu join class on stu.class_id &#x3D; class.id;</span><br></pre></td></tr></table></figure>

<ol>
<li>比较两种连表查询：</li>
</ol>
<ul>
<li>in: 需要查询的信息只来源于一张表 （eg: stu）</li>
<li>join：需要查询的信息来自于多张表（eg: stu,class）</li>
</ul>
<ol start="2">
<li>真实的执行过程</li>
</ol>
<ul>
<li><p>in：mysql会把in子查询转换成exists相关子查询，所以它实际等同于这条sql语句：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where exists(select id from class where stu.class_id&#x3D;class.id );</span><br></pre></td></tr></table></figure>
<p>  而exists相关子查询的执行原理是: 循环取出外表的每一条记录与子查询中的表进行比较，比较的条件是stu.class_id=class.id 然后看外表的每条记录的class_id是否在内表的id字段存在，如果存在就行返回外表的这条记录。</p>
<p>  弊端：exists 查询的 外表没有用到索引，用了全表扫描。</p>
</li>
<li><p>join: 是 exists的优化</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from stu inner join class on stu.class_id&#x3D;class.id; </span><br><span class="line">select * from stu left join class on stu.class_id&#x3D;class.id; </span><br><span class="line">select * from stu right join class on stu.class_id&#x3D;class.id;</span><br></pre></td></tr></table></figure>

<p>结果上的比较：</p>
<ul>
<li>inner join: 筛选出两张表中都符合on条件的行；</li>
<li>left join：左表数据全部选出，右表能匹配就匹配上，不能匹配就填null</li>
<li>right join：右表数据全部选出，左表能匹配就匹配上，不能匹配就填null</li>
</ul>
<p>执行上的比较：（前提是on后面的字段配了索引）</p>
<ul>
<li>left join： 左表全表扫描列出每一行，去右表用索引查找，看是否满足on条件：nlogn</li>
<li>right join： 右表全表扫描列出每一行，去左表用索引查找，看是否满足on条件：nlogn</li>
<li>inner join： mysql查询优化器,会自己评估使用a表查b表的效率高还是b表查a表高，如果两个表都建有索引的情况下，mysql同样会评估使用a表条件字段上的索引效率高还是b表</li>
</ul>
<ol start="3">
<li>连表查询的优化方式：</li>
</ol>
<p>一般而言，需要连表的字段都需要加上索引，把两个表的连接条件的两个字段都各自建立上索引，然后explain 一下，查看执行计划，看mysql到底利用了哪个索引，最后再把没有使用索引的表的字段索引给去掉就行了。</p>
<ol start="4">
<li>关于：“阿里程序规约表示，最好不要使用超过 3张表 的连表查询” 的 解读：</li>
</ol>
<ul>
<li><p>数据库优化器，会根据连表的多少决定相应的算法选择相应的算法：</p>
<p>  动态规划、贪心算法。在连接表数比较少的时候选择动态规划，一阶段一阶段的去分析各种可能得连接顺序得到一    个最优的执行计划，但动态规划场景下，随表的增加，计划也会爆炸式增加，优化器在选择最优计划的前提下，消    耗的内存和CPU是不能不考虑的，所以当表的数量太多，数据库会退化成贪心算法。</p>
</li>
<li><p>轻DB重应用的思路：</p>
<p>  从阿里的角度而言，数据库服务也从垂直拓展的集中式架构变成了水平拓展的分布式架构。由于数据规模太大，不得不考虑 “分库分表+中间件” 的模型。在分库分表场景下，能在数据库层面做join的场景自然也不多，所以大家 更多的是将数据库当成一个带多行事务能力的KV系统去用，这是轻DB重应用的思路，跟银行等传统行业重DB轻应   用的思路刚好相反；然而基于“中间件”来做join，中间件拿到数据sharding信息更难，成本肯定更大，所以这个 问题自然就落到了应用上。</p>
<p>  链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56236190/answer/250862637">https://www.zhihu.com/question/56236190/answer/250862637</a></p>
</li>
</ul>
<ol start="5">
<li>一个例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from</span><br><span class="line">    a inner join b on a.uid&#x3D;b.uid </span><br><span class="line">    inner join c on a.shopid&#x3D;c.id </span><br><span class="line">    where a.code&#x3D;0 and a.status like &#39;%未发货%&#39;</span><br><span class="line">    and b.auto_user&#x3D;0 order by a.time;</span><br></pre></td></tr></table></figure>

<p>其中：<br>a 表一百六十万多条数据，数据量最大。<br>b 表两千多条。<br>c 表十五万条。</p>
<p>优化的原则是：</p>
<ul>
<li>尽量使用索引</li>
<li>不要全表遍历大表</li>
</ul>
<p>具体的方法是：</p>
<ul>
<li>查b连a(遍历b小表，去a大表里面用索引查询，具体方法是给a的uid加索引)，得到一张结果表d</li>
<li>查d连c(遍历d表小表，去c大表里面用索引查询，具体方法是给c的id加索引，不用加，c的主键id就是索引)</li>
</ul>
<h2 id="2-3-Group-by-和-临时表的优化"><a href="#2-3-Group-by-和-临时表的优化" class="headerlink" title="2.3 Group by 和 临时表的优化"></a>2.3 Group by 和 临时表的优化</h2><ol>
<li>group by 执行原理：</li>
</ol>
<ul>
<li>首先mysql会把最终需要分组的结果集提取出来作为一个临时的表存放到内存空间。</li>
<li>对该临时表进行排序</li>
<li>排序之后进行分组</li>
</ul>
<ol start="2">
<li><p>优化方案：</p>
<p> 对该字段加上索引，则不需要产生临时表，也不需要重新排序了。因为索引已经排序了。</p>
</li>
<li><p>其他统计函数(min，max)</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(age) <span class="keyword">from</span> stu <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure>

<p>这个 max的操作也会用到 临时文件和额外的排序。解决的方式是 建立 index（class_id,age）。解释： 会按照class_id和age来进行 复合排序，（在class_id相同的情况下会再对age来排序），所以不会生成中间表，也不需要再额外的排序。</p>
<h2 id="2-4-其他优化方式"><a href="#2-4-其他优化方式" class="headerlink" title="2.4 其他优化方式"></a>2.4 其他优化方式</h2><h3 id="2-4-1-避免-SELECT"><a href="#2-4-1-避免-SELECT" class="headerlink" title="2.4.1 避免 SELECT *"></a>2.4.1 避免 SELECT *</h3><p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p>
<h3 id="2-4-2-垂直分割"><a href="#2-4-2-垂直分割" class="headerlink" title="2.4.2 垂直分割"></a>2.4.2 垂直分割</h3><p>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。</p>
<p>例如： 在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能。对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</p>
<h3 id="2-4-3-拆分大的-DELETE-或-INSERT-语句"><a href="#2-4-3-拆分大的-DELETE-或-INSERT-语句" class="headerlink" title="2.4.3 拆分大的 DELETE 或 INSERT 语句"></a>2.4.3 拆分大的 DELETE 或 INSERT 语句</h3><p>原因：DELETE和INSERT操作会进行“锁表”，如果表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让WEB服务Crash，还可能会让整台服务器马上挂了。</p>
<p>解决方案： 使用LIMIT限定条数</p>
<h3 id="2-4-4-越小的列会越快"><a href="#2-4-4-越小的列会越快" class="headerlink" title="2.4.4 越小的列会越快"></a>2.4.4 越小的列会越快</h3><p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。但是做下面的操作的时候请注意可扩展性。</p>
<ul>
<li>如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些</li>
<li>如果不需要记录时间，使用 DATE 要比 DATETIME 好得多。</li>
</ul>
<h2 id="2-4-5-InnoDB-还是-MyISAM-选择合适的存储引擎"><a href="#2-4-5-InnoDB-还是-MyISAM-选择合适的存储引擎" class="headerlink" title="2.4.5 InnoDB 还是 MyISAM? 选择合适的存储引擎"></a>2.4.5 InnoDB 还是 MyISAM? 选择合适的存储引擎</h2><ol>
<li>InnoDB：</li>
</ol>
<ul>
<li>事务处理</li>
<li>外键</li>
<li>大尺寸的数据 ( 因为INNODB其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快)<br>updates 在InnoDB 下会更快一些，尤其在并发量大的时候</li>
</ul>
<ol start="2">
<li>MyISAM：</li>
</ol>
<ul>
<li>全文索引</li>
<li>COUNT() 很快</li>
<li>大批的inserts 语句在MyISAM下会快一些</li>
<li>小型的应用或项目</li>
</ul>
<h3 id="2-4-6-选择一个ORM-Object-Relational-Mapper"><a href="#2-4-6-选择一个ORM-Object-Relational-Mapper" class="headerlink" title="2.4.6 选择一个ORM(Object Relational Mapper)"></a>2.4.6 选择一个ORM(Object Relational Mapper)</h3><p>Lazy Loading</p>
<h1 id="3-项目中出现的MySQL问题"><a href="#3-项目中出现的MySQL问题" class="headerlink" title="3. 项目中出现的MySQL问题"></a>3. 项目中出现的MySQL问题</h1><h2 id="1-Spring-事务："><a href="#1-Spring-事务：" class="headerlink" title="1. Spring 事务："></a>1. Spring 事务：</h2><h3 id="ztp遇到的问题："><a href="#ztp遇到的问题：" class="headerlink" title="ztp遇到的问题："></a>ztp遇到的问题：</h3><p>数据库事务在代码中需要注意，例如 Spring Transcation, 实际的项目里面不写会出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一段service代码，比较丑...</span></span><br><span class="line"><span class="comment">// 2019/04/22</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">saveEvaluationRealtimeAndGradeRealtime</span><span class="params">(GradeEvaluationRealtimeView gradeEvaluationRealtimeView, Long userId,Long trainRealtimeId, Float distance)</span> </span>&#123;</span><br><span class="line">    TrainRealtimeInstanceEntity trainRealtimeInstance = <span class="keyword">new</span> TrainRealtimeInstanceEntity();</span><br><span class="line">    trainRealtimeInstance.setUserId(userId);</span><br><span class="line">    trainRealtimeInstance.setTrainRealtimeId(trainRealtimeId);</span><br><span class="line">    trainRealtimeInstance.setTimemark(<span class="keyword">new</span> Date());</span><br><span class="line">    trainRealtimeInstance.setDistance(distance);</span><br><span class="line">    <span class="comment">// 1. 存储 训练计划 </span></span><br><span class="line">    trainRealtimeInstanceService.insert(trainRealtimeInstance);</span><br><span class="line">    Long trainRealtimeInstanceId = trainRealtimeInstance.getTrainRealtimeInstanceId();</span><br><span class="line">    List&lt;EvaluationRealtimeEntity&gt; evaluationRealtimeList = gradeEvaluationRealtimeView.getEvaluationRealtimeList();</span><br><span class="line">    GradeRealtimeEntity gradeRealtime = gradeEvaluationRealtimeView.getGradeRealtime();</span><br><span class="line">    <span class="comment">//存储EvaluationRealtime相关：</span></span><br><span class="line">    <span class="keyword">for</span>(EvaluationRealtimeEntity e:evaluationRealtimeList)&#123;</span><br><span class="line">        e.setTrainRealtimeInstanceId(trainRealtimeInstanceId);</span><br><span class="line">        e.setUserId(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 存储 训练结果相关，是一个耗时操作</span></span><br><span class="line">    evaluationRealtimeService.insertBatch(evaluationRealtimeList,<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 3. 存储 分数相关：</span></span><br><span class="line">    gradeRealtime.setUserId(userId);</span><br><span class="line">    <span class="comment">// 这边不设置时间，这里的timemark允许是 保存历史的时间。</span></span><br><span class="line">    gradeRealtime.setTrainRealtimeInstanceId(trainRealtimeInstanceId);</span><br><span class="line">    insert(gradeRealtime);</span><br><span class="line">    <span class="keyword">return</span> trainRealtimeInstanceId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码里面有3处存储数据库的操作，其中2是耗时操作，要存储1800条数据，比较容易出问题，所以可能导致1存储成功，2部分存储成功，3没有存储。导致数据库数据不一致的问题（原本TrainRealtimeInstance与GradeRealtime应该是1对1的关系）</p>
<p>解决方案：将这三个操作写入同一个service方法，在方法前面加上 @Transactional，保证这些是同一个事务，要么全部存储成功，要么一次db操作失败全部回滚，问题解决。</p>
<h3 id="Spring-事务管理："><a href="#Spring-事务管理：" class="headerlink" title="Spring 事务管理："></a>Spring 事务管理：</h3><ul>
<li><p>编程式事务管理 vs. 声明式事务管理:</p>
<ul>
<li>编程式： 在编程的帮助下有管理事务。极大的灵活性，但却很难维护。</li>
<li>声明式: 从业务代码中分离事务管理。仅仅使用注释或 XML 配置来管理事务。</li>
</ul>
</li>
<li><p>局部事物 vs. 全局事务:</p>
<ul>
<li>集中的计算环境中,事务管理只涉及到一个运行在一个单一机器中的本地数据管理器。更容易实现。</li>
<li>分布式计算环境中,所有的资源都分布在多个系统中。分布式或全局事务跨多个系统执行，它的执行需要全局事务管理系统和所有相关系统的局部数据管理人员之间的协调。</li>
</ul>
</li>
<li><p>Spring中事务源码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;  <span class="comment">//申明</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;    <span class="comment">//提交（成功）</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  <span class="comment">//回滚（失败）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务的定义：属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;    <span class="comment">//事务的传播行为</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;         <span class="comment">//事务的隔离级别</span></span><br><span class="line">   <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;                <span class="comment">//事务的名称</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;                <span class="comment">//事务完成的最大时间</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;            <span class="comment">//事务是否只读</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Spring的事务隔离级别<ul>
<li>ISOLATION_DEFAULT: 这是默认的隔离级别。(ISOLATION_READ_COMMITTED)</li>
<li>ISOLATION_READ_UNCOMMITTED: 可以发生误读、不可重复读和虚读。</li>
<li>ISOLATION_READ_COMMITTED: 能够阻止误读；可以发生不可重复读和虚读。</li>
<li>ISOLATION_REPEATABLE_READ: 够阻止误读和不可重复读；可以发生虚读。</li>
<li>ISOLATION_SERIALIZABLE: 能够阻止误读、不可重复读和虚读。</li>
</ul>
</li>
</ul>
<p>关于事务的并发一致性，封锁协议，隔离级别 ztp的理解如下（属于ACID的I）：</p>
<table>
<thead>
<tr>
<th align="center">并发一致性问题</th>
<th align="center">封锁协议</th>
<th align="center">隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">丢失更新</td>
<td align="center">一级封锁协议</td>
<td align="center">未提交读</td>
</tr>
<tr>
<td align="center">脏读</td>
<td align="center">二级封锁协议</td>
<td align="center">提交读 (默认)</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td align="center">三级封锁协议</td>
<td align="center">可重复读</td>
</tr>
<tr>
<td align="center">幻影读</td>
<td align="center">四级封锁协议</td>
<td align="center">可串行化</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>Spring事务的传播类型</p>
<ul>
<li>PROPAGATION_MANDATORY: 支持当前事务；如果不存在当前事务，则抛出一个异常。</li>
<li>PROPAGATION_NESTED: 如果存在当前事务，则在一个嵌套的事务中执行。</li>
<li>PROPAGATION_NEVER: 不支持当前事务；如果存在当前事务，则抛出一个异常。</li>
<li>PROPAGATION_NOT_SUPPORTED: 不支持当前事务；而总是执行非事务性。</li>
<li>PROPAGATION_REQUIRED: 支持当前事务；如果不存在事务，则创建一个新的事务。</li>
<li>PROPAGATION_REQUIRES_NEW: 创建一个新事务，如果存在一个事务，则把当前事务挂起。</li>
<li>PROPAGATION_SUPPORTS: 支持当前事务；如果不存在，则执行非事务性。</li>
<li>TIMEOUT_DEFAULT: 使用默认超时的底层事务系统，或者如果不支持超时则没有。   </li>
</ul>
</li>
<li><p>Spring声明式事务管理（基于AOP）</p>
<p>  声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p>  使用方式：@Transactional注解添加到类或者方法上，并且配置一些属性：</p>
<ul>
<li>@Transactional 添加到方法上：该方法具有事务性。</li>
<li>@Transactional 添加到类上：所有该类的公共方法都配置相同的事务属性信息。<a href="https://ztxpp.cc/2019/03/24/mysql/#jump">例如这个例子</a></li>
</ul>
</li>
</ul>
<h2 id="2-varchar的长度："><a href="#2-varchar的长度：" class="headerlink" title="2. varchar的长度："></a>2. varchar的长度：</h2><ul>
<li><p>mysql 4.0版本以下，varchar(50), 指的是50字节，如果存放utf8汉字时，只能存放16个（每个汉字3字节）</p>
</li>
<li><p>mysql 5.0版本以上，varchar(50), 指的是50字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放50个。</p>
</li>
</ul>
<h1 id="4-Mysql的切分"><a href="#4-Mysql的切分" class="headerlink" title="4. Mysql的切分"></a>4. Mysql的切分</h1><h2 id="1-水平切分：（sharding）"><a href="#1-水平切分：（sharding）" class="headerlink" title="1. 水平切分：（sharding）"></a>1. 水平切分：（sharding）</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>【按行切分】 将同一个表中的记录拆分到多个结构相同的表中，分库分表，从而缓解单数据库的压力</p>
<h3 id="sharding策略："><a href="#sharding策略：" class="headerlink" title="sharding策略："></a>sharding策略：</h3><ul>
<li>哈希取模： hash(key)%N</li>
<li>范围：可以是ID范围也可以是时间范围</li>
<li>映射表： 使用单独的一个数据库来存储映射关系</li>
</ul>
<h3 id="sharding存在的问题"><a href="#sharding存在的问题" class="headerlink" title="sharding存在的问题"></a>sharding存在的问题</h3><ul>
<li>事务问题：使用分布式事务解决</li>
<li>连表查询：<ul>
<li>单表查：可以将原来的连接分解成单表查询，然后再用户程序中进行连接。</li>
<li>广播表：在一个分库中保存全量的数据。</li>
</ul>
</li>
<li>ID唯一性：<ul>
<li>使用全局唯一的ID(GUID)</li>
<li>为每个分片指定一个ID的范围</li>
<li>分布式ID生成器（如：Twitter 的 Snowflake）</li>
</ul>
</li>
</ul>
<h2 id="2-垂直切分："><a href="#2-垂直切分：" class="headerlink" title="2. 垂直切分："></a>2. 垂直切分：</h2><p>【按列切分】 将一张表按照列切分成多个表，例如将 电商库 =&gt; 商品库 + 用户数据库。</p>
<h1 id="5-Mysql复制"><a href="#5-Mysql复制" class="headerlink" title="5. Mysql复制"></a>5. Mysql复制</h1><h2 id="1-主从复制："><a href="#1-主从复制：" class="headerlink" title="1. 主从复制："></a>1. 主从复制：</h2><ul>
<li>binlog线程: 将主数据库上的 “数据更新” 语句到二进制日志（Binary log）中。</li>
<li>I/O线程： 负责从主服务器上读取二进制日志，并写入从服务器的重放日志（replay log）中。</li>
<li>SQL线程：负责读取重放日志并重放其中的SQL语句。</li>
</ul>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190830215410.png" alt="主从复制三个线程"></p>
<h2 id="2-读写分离："><a href="#2-读写分离：" class="headerlink" title="2. 读写分离："></a>2. 读写分离：</h2><ul>
<li><p>分工：</p>
<ul>
<li>主服务器处理写操作+耗时读操作</li>
<li>从服务器处理读操作</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>缓解 锁的争夺</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销（MyISAM表锁，没有数据库事务）</li>
<li>增加冗余，提高可用性</li>
</ul>
</li>
<li><p>实现方式：  </p>
</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190830220229.png" alt="读写分离的实现方式"></p>
<ul>
<li>相关实现方式链接：<br><a href="https://ztxpp.cc/2019/01/16/dockerStudy/">利用docker搭建Mysql集群篇章</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/OOM/">java OOM异常</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span></div>
    </header>

    <div class="post-content"><p>java OOM 异常处理 （OutOfMemoryError）</p>
<h1 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h1><h2 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，对象数量达到最大堆容量限制，则发生溢出。(有点类似于“内存泄露”)</p>
<h2 id="1-2-举例："><a href="#1-2-举例：" class="headerlink" title="1.2 举例："></a>1.2 举例：</h2><p>Java堆溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// list保留引用，避免Full GC 回收 </span></span><br><span class="line">        list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:458)</span><br><span class="line">	at OOM.HeapOOM.main(HeapOOM.java:14)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-解决方式："><a href="#1-3-解决方式：" class="headerlink" title="1.3 解决方式："></a>1.3 解决方式：</h2><p>需要确认是 <strong>内存泄露</strong> 还是 <strong>内存溢出</strong>。</p>
<ul>
<li>内存泄露 ：查看泄露对象到GC Roots的引用链，定位泄露代码位置。</li>
<li>内存溢出 ：如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。</li>
</ul>
<h1 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h1><h2 id="2-1-定义："><a href="#2-1-定义：" class="headerlink" title="2.1 定义："></a>2.1 定义：</h2><p>HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。</p>
<ul>
<li>StackOverFlow：线程申请的栈深度超过允许的最大深度</li>
<li>OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间</li>
</ul>
<h2 id="2-2-举例"><a href="#2-2-举例" class="headerlink" title="2.2 举例"></a>2.2 举例</h2><p>Java栈 stackoutflow: (递归调用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackStackOverFlow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟机栈和本地方法栈溢出 StackOverFlow</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackStackOverFlow sof = <span class="keyword">new</span> JavaVMStackStackOverFlow();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sof.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length: &quot;</span> + sof.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>报错信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">stack length: <span class="number">19471</span></span><br><span class="line">    at OOM.JavaVMStackStackOverFlow.stackLeak(JavaVMStackStackOverFlow.java:<span class="number">17</span>)</span><br><span class="line">    at OOM.JavaVMStackStackOverFlow.stackLeak(JavaVMStackStackOverFlow.java:<span class="number">17</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>java栈 OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：Windows平台虚拟机中，Java的线程映射到操作系统的内核线程上执行，下面代码执行可能造成系统假死！</span></span><br><span class="line"><span class="comment">//不要执行，不要执行，不要执行！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多线程方式造成栈内存溢出 OutOfMemoryError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows死机</span><br></pre></td></tr></table></figure>

<h1 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3. 运行时常量池溢出"></a>3. 运行时常量池溢出</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>JDK1.7开始逐步“去永久代”，下面的讨论可以测试下实际影响。</p>
<p>String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。</p>
<p>在JDK1.6之前，常量池分配在永久代，以下代码在JDK1.6下运行才回发生内存溢出，如果在JDK1.7及其之后的版本运行，则是死循环</p>
<h2 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2 举例"></a>3.2 举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// list保留引用，避免Full GC 回收</span></span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdk1.7后 程序陷入死循环</span><br></pre></td></tr></table></figure>

<h1 id="4-方法区溢出"><a href="#4-方法区溢出" class="headerlink" title="4.方法区溢出"></a>4.方法区溢出</h1><h2 id="4-1-定义："><a href="#4-1-定义：" class="headerlink" title="4.1 定义："></a>4.1 定义：</h2><p>方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。</p>
<h2 id="4-2-举例："><a href="#4-2-举例：" class="headerlink" title="4.2 举例："></a>4.2 举例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法区溢出</span></span><br><span class="line"><span class="comment">     * -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(HeapOOM.OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method m, Object[] objs, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, objs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-本地直接内存溢出"><a href="#5-本地直接内存溢出" class="headerlink" title="5. 本地直接内存溢出"></a>5. 本地直接内存溢出</h1><h2 id="5-1-定义："><a href="#5-1-定义：" class="headerlink" title="5.1 定义："></a>5.1 定义：</h2><p>Java虚拟机可以通过参数-XX:MaxDirectMemorySize设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。</p>
<h2 id="5-2-举例："><a href="#5-2-举例：" class="headerlink" title="5.2 举例："></a>5.2 举例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe . class .getDeclaredFields()[0];     </span><br><span class="line">        unsafeField.setAccessible( <span class="keyword">true</span> );</span><br><span class="line">        Unsafe unsafe = ( Unsafe ) unsafeField.get( <span class="keyword">null</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( <span class="keyword">true</span> ) &#123;</span><br><span class="line">            <span class="comment">// unsafe 直接想操作系统申请内存</span></span><br><span class="line">            unsafe.allocateMemory( _1MB );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="line">	at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">	at OOM.DirectMemoryOOM.main(DirectMemoryOOM.java:20)</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51322119">https://blog.csdn.net/u011080472/article/details/51322119</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/19/project/">项目介绍</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-19
        </span></div>
    </header>

    <div class="post-content"><h1 id="基于计算机视觉的人体姿态估计平台-（项目负责人）"><a href="#基于计算机视觉的人体姿态估计平台-（项目负责人）" class="headerlink" title="基于计算机视觉的人体姿态估计平台 （项目负责人）"></a>基于计算机视觉的人体姿态估计平台 （项目负责人）</h1><h2 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h2><p>本项目来源是北京邮电大学的创新创业项目，主要目的是为了搭建基于人体姿态估计算法的平台，为用户在家中使用普通的2D摄像头，辅助进行健身和康复训练提供检测和指导。项目的前身设计较为简单，但获得了学校的研究生创新创业大赛的一等奖。</p>
<h2 id="项目架构："><a href="#项目架构：" class="headerlink" title="项目架构："></a>项目架构：</h2><p>本项目是分层设计的，最上层是 应用层，包括健康医疗系统，和正在搭建的健身指导系统； 算法层是实验室负责算法的同学改进的基于计算机视觉的一些算法实现，包括了改进后的人脸检测识别，人体姿态估计算法，后期还会加入的动作检测等；负责连接这两部分的是 中间的能力开放平台：该层负责将视觉识别算法封装成各种能力API的形式，提供基于图片和视频的服务，供上层应用使用。</p>
<h2 id="技术选型："><a href="#技术选型：" class="headerlink" title="技术选型："></a>技术选型：</h2><p>算法层大多基于python实现，人体姿态估计算法是基于resnet改进的，能完成多人的姿态估计；其他算法未参与设计。<br>能力开放平台采用的：基于java的 SpringBoot+Mybatis框架的含前后端的web系统，后续准备改进为微服务架构。上层应用也是基于javaWeb搭建的。 </p>
<h2 id="亮点："><a href="#亮点：" class="headerlink" title="亮点："></a>亮点：</h2><p>算法层与平台之间的 连续视频通信采用的基于Redis的消息中间件，采用订阅者发布者模式, 订阅两个channel，互相推送图片(base64)信息。好处：1.解耦了两个系统，弹性的资源控制。 2.异步消息队列，确保了任务的先入先出</p>
<h1 id="国家电网能力开放平台-（项目核心成员）"><a href="#国家电网能力开放平台-（项目核心成员）" class="headerlink" title="国家电网能力开放平台 （项目核心成员）"></a>国家电网能力开放平台 （项目核心成员）</h1><h2 id="项目简介：-1"><a href="#项目简介：-1" class="headerlink" title="项目简介："></a>项目简介：</h2><p>北邮与国家电网合作的，面向 ISP 和 ISV 设计开发的能力开放平台。能有效整合服务资源，通过能力开放的形式吸引服务提供商在平台完成注册、发布API，并与应用开发方建立商业联系。平台则需完成对ISP、ISV的服务监管和计量计费。</p>
<h2 id="项目架构：-1"><a href="#项目架构：-1" class="headerlink" title="项目架构："></a>项目架构：</h2><p>基于微服务架构设计，分为 协议转换模块、接入控制模块 和 平台管理模块。</p>
<h2 id="主要负责："><a href="#主要负责：" class="headerlink" title="主要负责："></a>主要负责：</h2><p>主要负责与国家电网南瑞子公司进行需求对接，并且主导了整体架构微服务的设计。完成了 “协议转换模块”，“流量控制模块”、“权限控制模块”、“计费模块的设计与实现”。</p>
<ul>
<li><p>协议转换模块：因为系统之间通信使用的基于阿里的 HSF 通信协议，所以需要将 http接口转换为 hsf需要的接口样式。对于用户的http调用，采用的 Spring AOP 做了一个拦截，具体采用的 Around方法，在调用之前，调用之中，调用之后分别对请求做了一些操作。</p>
</li>
<li><p>接入控制模块：对应协议控制模块中的拦截之前，对用户请求做了：鉴权、流控。 在请求之后，做了计量计费操作。</p>
<ul>
<li><p>鉴权：用户表，角色表，权限表，可见的菜单表、页面元素、文件表。</p>
</li>
<li><p>限流：基于 Redis + Lua 脚本，实现了基于固定时间分片的分布式限流，针对每个ISV应用进行控制，redis的key是 AppId_ApiId_Second 做key， 访问次数为 value, 每两秒钟过期，用于检测一秒内的访问控制。</p>
</li>
<li><p>计费：采用是工厂模式，产生三种计费方式：“按照时间计费（包年包月）”、“按照流量计费”、“按照次数计费”。</p>
</li>
</ul>
</li>
</ul>
<h2 id="亮点：-1"><a href="#亮点：-1" class="headerlink" title="亮点："></a>亮点：</h2><ul>
<li><p>设计模式：</p>
<ul>
<li><p>代理模式：协议转换和访问控制模块之间采用了 代理模式。整个协议控制模块都相当于中介。使用了AOP对原始方法做了处理；AOP本身利用反射对目标方法使用了 动态代理代理模式。</p>
</li>
<li><p>策略模式：定义一系列 控制算法，并且使得他们之间可以互换。访问控制模块使用该设计模式，分为 “正常状态下的访问” 和 “测试状态下的访问”，这两种不同的状态 包含了 不同的控制策略，“正常状态下的访问”：鉴权、流控、计费。 “测试状态下的访问”：鉴权、流控，不包含计费。 利用 Spring 将这些策略注入到 不同的 List中，然后依次进行调用。</p>
</li>
<li><p>工厂模式：将“包年包月计费”、“按照流量计费”、“按照次数计费”实现同一个接口，并用工厂类，利用反射来调用这些计费方式。</p>
</li>
</ul>
</li>
<li><p>微服务（结合项目）：</p>
<ul>
<li><p>多个模块独立部署：对于不同的模块，进行不同方向上的拓展。项目中：协议转换模块承载最大的用户接入 需要做 X轴拓展,通过负载均衡，对请求进行分发。而访问控制模块则分为不同的小模块，可以做数据库的Y轴业务上的拓展（功能性拆分）。<strong>可以按照服务对硬件资源不同的需求进行升级！</strong></p>
</li>
<li><p>模块解耦，本项目是采用的基于RPC的 HSF协议进行模块之间的通信。面向连接。HSF是阿里内部使用的模块间通信的方式，我之前没有使用过，短期的学习能力。调通分布式模块之间通信的问题是，我遇到的比较大的一个难题。通过分析Edas平台各个服务IP地址和服务端口，以及redis日志文件，判断到最后是因为一个模块之中的redis地址出错导致没有启动redis。引发的后续通信的问题。体现了排错能力和自主解决问题的能力。</p>
</li>
</ul>
</li>
</ul>
<h1 id="1Coach：基于SpringBoot-MyBatis的跑姿管理系统-（系统后台负责人）"><a href="#1Coach：基于SpringBoot-MyBatis的跑姿管理系统-（系统后台负责人）" class="headerlink" title="1Coach：基于SpringBoot+MyBatis的跑姿管理系统 （系统后台负责人）"></a>1Coach：基于SpringBoot+MyBatis的跑姿管理系统 （系统后台负责人）</h1><h2 id="项目简介：-2"><a href="#项目简介：-2" class="headerlink" title="项目简介："></a>项目简介：</h2><p>深圳趣感科技公司（创业公司）开发的一款穿戴式跑步训练指导系统，通过传感器采集人体运动数据，对跑步姿态进行科学的评估，根据评估结果生成个性化的力量训练和跑姿改善计划，并实施的检测完成度 和 完成质量。</p>
<h1 id="Motion-Capture-基于数据手套的智能医疗康复系统（项目核心成员）"><a href="#Motion-Capture-基于数据手套的智能医疗康复系统（项目核心成员）" class="headerlink" title="Motion Capture:基于数据手套的智能医疗康复系统（项目核心成员）"></a>Motion Capture:基于数据手套的智能医疗康复系统（项目核心成员）</h1><ol>
<li>unity部分的设计与实现（c#编程）</li>
<li>unity与控制中心的通信（socket通信）</li>
<li>前端界面实时变化的元素设计（后端发送 websocket）</li>
</ol>
<h1 id="天池阿里巴巴大数据智能云上编程（应用部分）"><a href="#天池阿里巴巴大数据智能云上编程（应用部分）" class="headerlink" title="天池阿里巴巴大数据智能云上编程（应用部分）"></a>天池阿里巴巴大数据智能云上编程（应用部分）</h1><h2 id="比赛介绍："><a href="#比赛介绍：" class="headerlink" title="比赛介绍："></a>比赛介绍：</h2><p>阿里巴巴云上智能编程大赛，主要解决 由于混沌现象导致的降水量难以精准预测的问题。具体是解决：杭州市某地区 降水量预测的问题。首先利用该地区61*61区域内的历史降水数据预测出该区域内某一天的降水情况，然后以 web 应用的形式展现出来，形式不限。</p>
<p>比赛的经历很坎坷：初赛算法进入前20，复赛排名 算法第10，应用排名第1，综合排名第3，决赛算法和应用排名双第1。</p>
<h2 id="系统架构："><a href="#系统架构：" class="headerlink" title="系统架构："></a>系统架构：</h2><ul>
<li><p>PAI平台：机器学习深度学习的算法平台。利用数加平台构造的特征设计出了算法模型：先GBDT回归 + 再RF多分类来解决。具体算法部分不是我设计的。</p>
</li>
<li><p>数加平台：数据处理的SQL平台。利用数加平台提供的数据，构造出了相关特征：时间特征（该地区一组50个member的统计特征）、空间特征（空间划分成相邻区域，区域之间带有降水的连续性）、时空交叉特征（该地区前一组降水情况，该地区相邻地区的降水统计情况）。</p>
</li>
<li><p>APP Studio平台：应用编写平台。应用设计与编写部分比较花心思，也取得了比较好的效果。利用 APP Studio这个不太成熟的平台（一边code，一边给官方报错），我们设计出了展现形式比较丰富的应用。主要有：</p>
<ul>
<li><p>集合降水预测模块：这是平台的主要模块，利用了 “OSS数据缓存 + PAI平台暴露的API接口 + 3D echart组件” 完成。每日先从公共 OSS空间 load数据到本地，并使用java处理数据提取特征，将当日数据提供给PAI平台进行 算法模块的预测，并将预测结果保存在 OSS 私有地址中。 第二次以后的请求，则直接从OSS模块中获取 预测的数据并进行展示。 前端采用 “echart 3D 立体柱状图”来对该 61*61的区域做展示。可以明显的 观察到 降水的局部分布的变化特性，受到了 “云栖大会”决赛组评委的一致好评。</p>
</li>
<li><p>认证与鉴权模块：利用“shrio” 做了用户注册和登录功能，登录用户可以调用更多功能，为以后系统的“用户、角色、权限”的拓展打好基础。</p>
</li>
<li><p>普通天气预报模块：调用第三方接口+爬虫。 我们订阅了阿里云市场里面的天气预报收费接口提供的服务，以及墨迹天气、中国天气网提供的各城市的天气数据，进行整合设计，做出了可以根据“城市”来查询天气的界面，“今日空气指数”、“未来5日AQI折线图”、“今日生活指数”、“未来15日气温、风力柱状图和雷达图” 等展示。前端采用平台提供的基于 react 的 “拖拽式 + 代码调节” 的模式完成，后端编写相应接口，并且暴露api。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>OSS 平台：数据云存储平台。 分为 公有空间 和 私有空间。 公有空间存储了所有小组都可以访问到的比赛数据，私有空间则 存放预测完的结果，作为数据缓存，加速用户查询的过程，提升用户体验。（首次PAI预测需要将近2分钟的时间）</li>
</ul>
<h2 id="主要工作："><a href="#主要工作：" class="headerlink" title="主要工作："></a>主要工作：</h2><ol>
<li>需求分析、功能设计、系统架构设计</li>
<li>缓存oss的设计和实现</li>
<li>前端 页面的组织、3D组件的设置 </li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/19/%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9A%84%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1%E5%B9%B3%E5%8F%B0%20%EF%BC%88%E9%A1%B9%E7%9B%AE%E8%B4%9F%E8%B4%A3%E4%BA%BA%EF%BC%89/">项目介绍</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-19
        </span></div>
    </header>

    <div class="post-content"><h1 id="基于计算机视觉的人体姿态估计平台-（项目负责人）"><a href="#基于计算机视觉的人体姿态估计平台-（项目负责人）" class="headerlink" title="基于计算机视觉的人体姿态估计平台 （项目负责人）"></a>基于计算机视觉的人体姿态估计平台 （项目负责人）</h1><h2 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h2><p>本项目来源是北京邮电大学的创新创业项目，主要目的是为了搭建基于人体姿态估计算法的平台，为用户在家中使用普通的2D摄像头，辅助进行健身和康复训练提供检测和指导。项目的前身设计较为简单，但获得了学校的研究生创新创业大赛的一等奖。</p>
<h2 id="项目架构："><a href="#项目架构：" class="headerlink" title="项目架构："></a>项目架构：</h2><p>本项目是分层设计的，最上层是 应用层，包括健康医疗系统，和正在搭建的健身指导系统； 算法层是实验室负责算法的同学改进的基于计算机视觉的一些算法实现，包括了改进后的人脸检测识别，人体姿态估计算法，后期还会加入的动作检测等；负责连接这两部分的是 中间的能力开放平台：该层负责将视觉识别算法封装成各种能力API的形式，提供基于图片和视频的服务，供上层应用使用。</p>
<h2 id="技术选型："><a href="#技术选型：" class="headerlink" title="技术选型："></a>技术选型：</h2><p>算法层大多基于python实现，人体姿态估计算法是基于resnet改进的，能完成多人的姿态估计；其他算法未参与设计。<br>能力开放平台采用的：基于java的 SpringBoot+Mybatis框架的含前后端的web系统，后续准备改进为微服务架构。上层应用也是基于javaWeb搭建的。 </p>
<h2 id="亮点："><a href="#亮点：" class="headerlink" title="亮点："></a>亮点：</h2><p>算法层与平台之间的 连续视频通信采用的基于Redis的消息中间件，采用订阅者发布者模式, 订阅两个channel，互相推送图片(base64)信息。好处：1.解耦了两个系统，弹性的资源控制。 2.异步消息队列，确保了任务的先入先出</p>
<h1 id="国家电网能力开放平台-（项目核心成员）"><a href="#国家电网能力开放平台-（项目核心成员）" class="headerlink" title="国家电网能力开放平台 （项目核心成员）"></a>国家电网能力开放平台 （项目核心成员）</h1><h2 id="项目简介：-1"><a href="#项目简介：-1" class="headerlink" title="项目简介："></a>项目简介：</h2><p>北邮与国家电网合作的，面向 ISP 和 ISV 设计开发的能力开放平台。能有效整合服务资源，通过能力开放的形式吸引服务提供商在平台完成注册、发布API，并与应用开发方建立商业联系。平台则需完成对ISP、ISV的服务监管和计量计费。</p>
<h2 id="项目架构：-1"><a href="#项目架构：-1" class="headerlink" title="项目架构："></a>项目架构：</h2><p>基于微服务架构设计，分为 协议转换模块、接入控制模块 和 平台管理模块。</p>
<h2 id="主要负责："><a href="#主要负责：" class="headerlink" title="主要负责："></a>主要负责：</h2><p>主要负责与国家电网南瑞子公司进行需求对接，并且主导了整体架构微服务的设计。完成了 “协议转换模块”，“流量控制模块”、“权限控制模块”、“计费模块的设计与实现”。</p>
<ul>
<li><p>协议转换模块：因为系统之间通信使用的基于阿里的 HSF 通信协议，所以需要将 http接口转换为 hsf需要的接口样式。对于用户的http调用，采用的 Spring AOP 做了一个拦截，具体采用的 Around方法，在调用之前，调用之中，调用之后分别对请求做了一些操作。</p>
</li>
<li><p>接入控制模块：对应协议控制模块中的拦截之前，对用户请求做了：鉴权、流控。 在请求之后，做了计量计费操作。</p>
<ul>
<li><p>鉴权：用户表，角色表，权限表，可见的菜单表、页面元素、文件表。</p>
</li>
<li><p>限流：基于 Redis + Lua 脚本，实现了基于固定时间分片的分布式限流，针对每个ISV应用进行控制，redis的key是 AppId_ApiId_Second 做key， 访问次数为 value, 每两秒钟过期，用于检测一秒内的访问控制。</p>
</li>
<li><p>计费：采用是工厂模式，产生三种计费方式：“按照时间计费（包年包月）”、“按照流量计费”、“按照次数计费”。</p>
</li>
</ul>
</li>
</ul>
<h2 id="亮点：-1"><a href="#亮点：-1" class="headerlink" title="亮点："></a>亮点：</h2><ul>
<li><p>设计模式：</p>
<ul>
<li><p>代理模式：协议转换和访问控制模块之间采用了 代理模式。整个协议控制模块都相当于中介。使用了AOP对原始方法做了处理；AOP本身利用反射对目标方法使用了 动态代理代理模式。</p>
</li>
<li><p>策略模式：定义一系列 控制算法，并且使得他们之间可以互换。访问控制模块使用该设计模式，分为 “正常状态下的访问” 和 “测试状态下的访问”，这两种不同的状态 包含了 不同的控制策略，“正常状态下的访问”：鉴权、流控、计费。 “测试状态下的访问”：鉴权、流控，不包含计费。 利用 Spring 将这些策略注入到 不同的 List中，然后依次进行调用。</p>
</li>
<li><p>工厂模式：将“包年包月计费”、“按照流量计费”、“按照次数计费”实现同一个接口，并用工厂类，利用反射来调用这些计费方式。</p>
</li>
</ul>
</li>
<li><p>微服务（结合项目）：</p>
<ul>
<li><p>多个模块独立部署：对于不同的模块，进行不同方向上的拓展。项目中：协议转换模块承载最大的用户接入 需要做 X轴拓展,通过负载均衡，对请求进行分发。而访问控制模块则分为不同的小模块，可以做数据库的Y轴业务上的拓展（功能性拆分）。<strong>可以按照服务对硬件资源不同的需求进行升级！</strong></p>
</li>
<li><p>模块解耦，本项目是采用的基于RPC的 HSF协议进行模块之间的通信。面向连接。HSF是阿里内部使用的模块间通信的方式，我之前没有使用过，短期的学习能力。调通分布式模块之间通信的问题是，我遇到的比较大的一个难题。通过分析Edas平台各个服务IP地址和服务端口，以及redis日志文件，判断到最后是因为一个模块之中的redis地址出错导致没有启动redis。引发的后续通信的问题。体现了排错能力和自主解决问题的能力。</p>
</li>
</ul>
</li>
</ul>
<h1 id="1Coach：基于SpringBoot-MyBatis的跑姿管理系统-（系统后台负责人）"><a href="#1Coach：基于SpringBoot-MyBatis的跑姿管理系统-（系统后台负责人）" class="headerlink" title="1Coach：基于SpringBoot+MyBatis的跑姿管理系统 （系统后台负责人）"></a>1Coach：基于SpringBoot+MyBatis的跑姿管理系统 （系统后台负责人）</h1><h2 id="项目简介：-2"><a href="#项目简介：-2" class="headerlink" title="项目简介："></a>项目简介：</h2><p>深圳趣感科技公司（创业公司）开发的一款穿戴式跑步训练指导系统，通过传感器采集人体运动数据，对跑步姿态进行科学的评估，根据评估结果生成个性化的力量训练和跑姿改善计划，并实施的检测完成度 和 完成质量。</p>
<h1 id="Motion-Capture-基于数据手套的智能医疗康复系统（项目核心成员）"><a href="#Motion-Capture-基于数据手套的智能医疗康复系统（项目核心成员）" class="headerlink" title="Motion Capture:基于数据手套的智能医疗康复系统（项目核心成员）"></a>Motion Capture:基于数据手套的智能医疗康复系统（项目核心成员）</h1><ol>
<li>unity部分的设计与实现（c#编程）</li>
<li>unity与控制中心的通信（socket通信）</li>
<li>前端界面实时变化的元素设计（后端发送 websocket）</li>
</ol>
<h1 id="天池阿里巴巴大数据智能云上编程（应用部分）"><a href="#天池阿里巴巴大数据智能云上编程（应用部分）" class="headerlink" title="天池阿里巴巴大数据智能云上编程（应用部分）"></a>天池阿里巴巴大数据智能云上编程（应用部分）</h1><h2 id="比赛介绍："><a href="#比赛介绍：" class="headerlink" title="比赛介绍："></a>比赛介绍：</h2><p>阿里巴巴云上智能编程大赛，主要解决 由于混沌现象导致的降水量难以精准预测的问题。具体是解决：杭州市某地区 降水量预测的问题。首先利用该地区61*61区域内的历史降水数据预测出该区域内某一天的降水情况，然后以 web 应用的形式展现出来，形式不限。</p>
<p>比赛的经历很坎坷：初赛算法进入前20，复赛排名 算法第10，应用排名第1，综合排名第3，决赛算法和应用排名双第1。</p>
<h2 id="系统架构："><a href="#系统架构：" class="headerlink" title="系统架构："></a>系统架构：</h2><ul>
<li><p>PAI平台：机器学习深度学习的算法平台。利用数加平台构造的特征设计出了算法模型：先GBDT回归 + 再RF多分类来解决。具体算法部分不是我设计的。</p>
</li>
<li><p>数加平台：数据处理的SQL平台。利用数加平台提供的数据，构造出了相关特征：时间特征（该地区一组50个member的统计特征）、空间特征（空间划分成相邻区域，区域之间带有降水的连续性）、时空交叉特征（该地区前一组降水情况，该地区相邻地区的降水统计情况）。</p>
</li>
<li><p>APP Studio平台：应用编写平台。应用设计与编写部分比较花心思，也取得了比较好的效果。利用 APP Studio这个不太成熟的平台（一边code，一边给官方报错），我们设计出了展现形式比较丰富的应用。主要有：</p>
<ul>
<li><p>集合降水预测模块：这是平台的主要模块，利用了 “OSS数据缓存 + PAI平台暴露的API接口 + 3D echart组件” 完成。每日先从公共 OSS空间 load数据到本地，并使用java处理数据提取特征，将当日数据提供给PAI平台进行 算法模块的预测，并将预测结果保存在 OSS 私有地址中。 第二次以后的请求，则直接从OSS模块中获取 预测的数据并进行展示。 前端采用 “echart 3D 立体柱状图”来对该 61*61的区域做展示。可以明显的 观察到 降水的局部分布的变化特性，受到了 “云栖大会”决赛组评委的一致好评。</p>
</li>
<li><p>认证与鉴权模块：利用“shrio” 做了用户注册和登录功能，登录用户可以调用更多功能，为以后系统的“用户、角色、权限”的拓展打好基础。</p>
</li>
<li><p>普通天气预报模块：调用第三方接口+爬虫。 我们订阅了阿里云市场里面的天气预报收费接口提供的服务，以及墨迹天气、中国天气网提供的各城市的天气数据，进行整合设计，做出了可以根据“城市”来查询天气的界面，“今日空气指数”、“未来5日AQI折线图”、“今日生活指数”、“未来15日气温、风力柱状图和雷达图” 等展示。前端采用平台提供的基于 react 的 “拖拽式 + 代码调节” 的模式完成，后端编写相应接口，并且暴露api。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>OSS 平台：数据云存储平台。 分为 公有空间 和 私有空间。 公有空间存储了所有小组都可以访问到的比赛数据，私有空间则 存放预测完的结果，作为数据缓存，加速用户查询的过程，提升用户体验。（首次PAI预测需要将近2分钟的时间）</li>
</ul>
<h2 id="主要工作："><a href="#主要工作：" class="headerlink" title="主要工作："></a>主要工作：</h2><ol>
<li>需求分析、功能设计、系统架构设计</li>
<li>缓存oss的设计和实现</li>
<li>前端 页面的组织、3D组件的设置 </li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/18/reflect/">java反射</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-18
        </span></div>
    </header>

    <div class="post-content"><p>总结一下java中的反射的基础知识，以及反射的应用（Spring）</p>
<h1 id="1-java的反射机制"><a href="#1-java的反射机制" class="headerlink" title="1.java的反射机制"></a>1.java的反射机制</h1><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。举例如下： </p>
<p>父类：FatherClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String mFatherName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mFatherAge;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> testa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printFatherMsg</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类：SonClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonClass</span> <span class="keyword">extends</span> <span class="title">FatherClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mSonName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> mSonAge;</span><br><span class="line">    <span class="keyword">public</span> String mSonBirthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSonMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son Msg - name : &quot;</span></span><br><span class="line">                + mSonName + <span class="string">&quot;; age : &quot;</span> + mSonAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSonName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        mSonName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setSonAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        mSonAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSonAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSonName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSonName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-使用反射获取类的信息"><a href="#1-使用反射获取类的信息" class="headerlink" title="1. 使用反射获取类的信息"></a>1. 使用反射获取类的信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射获取类的所有变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">//1.获取并输出类的名称</span></span><br><span class="line">    Class mClass = SonClass.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;类的名称：&quot;</span> + mClass.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1 获取所有 public 访问权限的变量</span></span><br><span class="line">    <span class="comment">// 包括本类声明的和从父类继承的</span></span><br><span class="line">    Field[] fields = mClass.getFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 获取所有本类声明的变量（不问访问权限）</span></span><br><span class="line">    <span class="comment">// Field[] fields = mClass.getDeclaredFields();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 获取父类的private方变量</span></span><br><span class="line">    <span class="comment">// Field fi = mClass.getSuperclass().getDeclaredField(&quot;testa&quot;);</span></span><br><span class="line">    <span class="comment">// System.out.println(&quot;1:&quot;+Modifier.toString(fi.getModifiers()) + &quot; &quot;+fi.getType().getName() + &quot; &quot; + fi.getName());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 遍历变量并输出变量信息</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">//获取访问权限并输出</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = field.getModifiers();</span><br><span class="line">        System.out.print(Modifier.toString(modifiers) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">//输出变量的类型及变量名</span></span><br><span class="line">        System.out.println(field.getType().getName() + <span class="string">&quot; &quot;</span> + field.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">输出：<span class="number">2.1</span> getFields() 包括了 子类的<span class="keyword">public</span>属性和继承自父类的所有属性（当然继承的<span class="keyword">public</span>的） </span><br></pre></td></tr></table></figure>
<p>类的名称：fanshe.SonClass<br>public java.lang.String mSonBirthday<br>public java.lang.String mFatherName<br>public int mFatherAge</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：2.2 getDeclaredFields()方法： 包括了 子类所有的属性，不问访问权限</span><br></pre></td></tr></table></figure>
<p>类的名称：fanshe.SonClass<br>private java.lang.String mSonName<br>protected int mSonAge<br>public java.lang.String mSonBirthday</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出2.3 想获取父类的信息，先getSuperclass(), 然后再 getDeclaredField(), 即可拿到private 属性  </span><br></pre></td></tr></table></figure>
<p>类的名称：fanshe.SonClass<br>1:private int testa</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 2. 获取类的所有方法信息</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">private static void printMethods()&#123;</span><br><span class="line">        &#x2F;&#x2F;1.获取并输出类的名称</span><br><span class="line">        Class mClass &#x3D; SonClass.class;</span><br><span class="line">        System.out.println(&quot;类的名称：&quot; + mClass.getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.1 获取所有 public 访问权限的方法</span><br><span class="line">        &#x2F;&#x2F;包括自己声明和从父类继承的</span><br><span class="line">       Method[] mMethods &#x3D; mClass.getMethods();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.2 获取所有本类的的方法（不问访问权限）</span><br><span class="line">        &#x2F;&#x2F; Method[] mMethods &#x3D; mClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3.遍历所有方法</span><br><span class="line">        for (Method method : mMethods) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取并输出方法的访问权限（Modifiers：修饰符）</span><br><span class="line">            int modifiers &#x3D; method.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers) + &quot; &quot;);</span><br><span class="line">            &#x2F;&#x2F;获取并输出方法的返回值类型</span><br><span class="line">            Class returnType &#x3D; method.getReturnType();</span><br><span class="line">            System.out.print(returnType.getName() + &quot; &quot; + method.getName() + &quot;( &quot;);</span><br><span class="line">            &#x2F;&#x2F;获取并输出方法的所有参数</span><br><span class="line">            Parameter[] parameters &#x3D; method.getParameters();</span><br><span class="line">            for (Parameter parameter: parameters) &#123;</span><br><span class="line">                System.out.print(parameter.getType().getName() + &quot; &quot; + parameter.getName() + &quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获取并输出方法抛出的异常</span><br><span class="line">            Class[] exceptionTypes &#x3D; method.getExceptionTypes();</span><br><span class="line">            if (exceptionTypes.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                System.out.println(&quot; )&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                for (Class c : exceptionTypes) &#123;</span><br><span class="line">                    System.out.println(&quot; ) throws &quot; + c.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">输出: 2.1 getMethods() 拿到了本类的所有public方法，包括从父类继承来的:</span><br></pre></td></tr></table></figure>
<p>类的名称：fanshe.SonClass<br>public void printSonMsg(  )         //自己的方法<br>public void printFatherMsg(  )      //从父类继承来的方法<br>public final void wait(  ) throws java.lang.InterruptedException // 下面的方法来自 Object 类。<br>public final void wait( long arg0,int arg1, ) throws java.lang.InterruptedException<br>public final native void wait( long arg0, ) throws java.lang.InterruptedException<br>public boolean equals( java.lang.Object arg0, )<br>public java.lang.String toString(  )<br>public native int hashCode(  )<br>public final native java.lang.Class getClass(  )<br>public final native void notify(  )<br>public final native void notifyAll(  )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出： 2.2 getDeclaredMethods(); 拿到了这个类中定义的所有方法，不包括继承来的，但是包含private方法</span><br></pre></td></tr></table></figure>
<p>类的名称：fanshe.SonClass<br>private void setSonName( java.lang.String arg0, )<br>private int getSonAge(  )<br>private void setSonAge( int arg0, )<br>public void printSonMsg(  )<br>private java.lang.String getSonName(  )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3. 访问或操作类的私有变量和方法</span><br><span class="line">定义类：TestClass</span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private String MSG &#x3D; &quot;Original&quot;;                       &#x2F;&#x2F;private变量</span><br><span class="line"></span><br><span class="line">    private void privateMethod(String head , int tail)&#123;    &#x2F;&#x2F;private方法</span><br><span class="line">        System.out.print(head + tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()&#123;</span><br><span class="line">        return MSG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 getPrivateMethod() 获取私有方法:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问对象的私有方法</span></span><br><span class="line"><span class="comment">     * 为简洁代码，在方法上抛出总的异常，实际开发别这样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPrivateMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取 Class 类实例</span></span><br><span class="line">        TestClass testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">        Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取私有方法</span></span><br><span class="line">        <span class="comment">//第一个参数为要获取的私有方法的名称</span></span><br><span class="line">        <span class="comment">//第二个为要获取方法的参数的类型，参数为 Class，没有参数就是null</span></span><br><span class="line">        <span class="comment">//方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125;</span></span><br><span class="line">        Method privateMethod = mClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 开始操作方法</span></span><br><span class="line">        <span class="keyword">if</span> (privateMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取私有方法的访问权</span></span><br><span class="line">            <span class="comment">//只是获取访问权，并不是修改实际权限</span></span><br><span class="line">            privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用 invoke 反射调用私有方法</span></span><br><span class="line">            <span class="comment">//privateMethod 是获取到的私有方法</span></span><br><span class="line">            <span class="comment">//testClass 要操作的对象</span></span><br><span class="line">            <span class="comment">//后面两个参数传实参</span></span><br><span class="line">            privateMethod.invoke(testClass, <span class="string">&quot;Java Reflect &quot;</span>, <span class="number">666</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出： 调用私有方法成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Reflect 666</span><br></pre></td></tr></table></figure>

<ul>
<li>利用modifyPrivateFiled() 修改私有变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改对象私有变量的值</span></span><br><span class="line"><span class="comment"> * 为简洁代码，在方法上抛出总的异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyPrivateFiled</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取 Class 类实例</span></span><br><span class="line">    TestClass testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">    Class mClass = testClass.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取私有变量</span></span><br><span class="line">    Field privateField = mClass.getDeclaredField(<span class="string">&quot;MSG&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 操作私有变量</span></span><br><span class="line">    <span class="keyword">if</span> (privateField != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取私有变量的访问权</span></span><br><span class="line">        privateField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改私有变量，并输出以测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before Modify：MSG = &quot;</span> + testClass.getMsg());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 set(object , value) 修改变量的值</span></span><br><span class="line">        <span class="comment">//privateField 是获取到的私有变量</span></span><br><span class="line">        privateField.set(testClass, <span class="string">&quot;Modified&quot;</span>); <span class="comment">//testClass 要操作的对象, &quot;Modified&quot; 为要修改成的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After Modify：MSG = &quot;</span> + testClass.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before Modify：MSG &#x3D; Original</span><br><span class="line">After Modify：MSG &#x3D; Modified</span><br></pre></td></tr></table></figure>
<p>反射基础部分借鉴：<a target="_blank" rel="noopener" href="https://juejin.im/post/598ea9116fb9a03c335a99a4">https://juejin.im/post/598ea9116fb9a03c335a99a4</a></p>
<h1 id="2-java反射在项目中的应用"><a href="#2-java反射在项目中的应用" class="headerlink" title="2. java反射在项目中的应用"></a>2. java反射在项目中的应用</h1><h2 id="2-1-工厂模式"><a href="#2-1-工厂模式" class="headerlink" title="2.1 工厂模式"></a>2.1 工厂模式</h2><p>例子：国家电网能力开放平台 项目 之中的 “计费” 使用的是 工厂模式。</p>
<p>接口类： （计费）   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;chargeService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChargeServiceI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(JSONObject j)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStatus</span><span class="params">(JSONObject j)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类1：ChargeByQueryServiceImpl（按照请求次数计费） 不用管具体实现，知道有两个方法为charge(), checkStatus() 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;chargeByQueryServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeByQueryServiceImpl</span> <span class="keyword">implements</span> <span class="title">ChargeServiceI</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    ChargeAccountServiceI chargeAccountService;</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SystemService systemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AlarmService alarmService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchMethod searchMethod;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(JSONObject j)</span> </span>&#123;</span><br><span class="line">        ChargeAccountEntity c = <span class="keyword">new</span> ChargeAccountEntity();</span><br><span class="line">        c.setId(j.get(<span class="string">&quot;chargeAccountId&quot;</span>).toString());</span><br><span class="line">        c.setTypename(j.get(<span class="string">&quot;typename&quot;</span>).toString());</span><br><span class="line">        c.setRestState(String.valueOf(Integer.parseInt(j.get(<span class="string">&quot;restState&quot;</span>).toString())-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChargeAccountServiceI chargeAccountService = (ChargeAccountServiceI) SpringContextUtils.getBean(<span class="string">&quot;chargeAccountService&quot;</span>);</span><br><span class="line">            chargeAccountService.saveOrUpdate(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            systemService.addLog(<span class="string">&quot;计费失败&quot;</span>, Globals.Log_Type_UPDATE, Globals.Log_Leavel_ERROR,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStatus</span><span class="params">(JSONObject j)</span> <span class="keyword">throws</span> ControlException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(j.get(<span class="string">&quot;restState&quot;</span>).toString())&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//alarmService.writeDatabase(&quot;剩余次数不足！&quot;,&quot;1&quot;,apiId,appName);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(<span class="string">&quot;剩余次数不足，请充值！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类2：ChargeByFlowServiceImpl（按照流量计费）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeByFlowServiceImpl</span> <span class="keyword">implements</span> <span class="title">ChargeServiceI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ChargeAccountServiceI chargeAccountService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SystemService systemService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AlarmService alarmService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchMethod searchMethod;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(JSONObject j)</span> <span class="keyword">throws</span> ControlException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> restState = Integer.parseInt(j.get(<span class="string">&quot;restState&quot;</span>).toString()) - Integer.parseInt(j.get(<span class="string">&quot;flowAmount&quot;</span>).toString());</span><br><span class="line">        ChargeAccountEntity c = <span class="keyword">new</span> ChargeAccountEntity();</span><br><span class="line">        <span class="keyword">if</span> (restState &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(<span class="string">&quot;流量超出限额&quot;</span>);</span><br><span class="line">        c.setId(j.get(<span class="string">&quot;chargeAccountId&quot;</span>).toString());</span><br><span class="line">        c.setTypename(j.get(<span class="string">&quot;typename&quot;</span>).toString());</span><br><span class="line">        c.setRestState(String.valueOf(restState));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chargeAccountService.saveOrUpdate(c);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            systemService.addLog(<span class="string">&quot;计费失败&quot;</span>, Globals.Log_Type_UPDATE, Globals.Log_Leavel_ERROR, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStatus</span><span class="params">(JSONObject j)</span> <span class="keyword">throws</span> ControlException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(j.get(<span class="string">&quot;restState&quot;</span>).toString()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(<span class="string">&quot;剩余流量不足，请充值！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现类3：ChargeByPeriodServiceImpl（按照时间计费）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeByPeriodServiceImpl</span> <span class="keyword">implements</span> <span class="title">ChargeServiceI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AlarmService alarmService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SearchMethod searchMethod;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(JSONObject j)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStatus</span><span class="params">(JSONObject j)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date expireDate = dateFormat.parse(j.get(<span class="string">&quot;restState&quot;</span>).toString());</span><br><span class="line">        Date today = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">if</span> (today.before(expireDate) || DateUtils.isSameDay(expireDate, today)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//alarmService.writeDatabase(&quot;订购已经到期！&quot;,&quot;2&quot;,apiId,appName);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;订购已经到期，请续订！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">工厂类：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="meta">@Component(&quot;chargeFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargeFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ChargeAccountServiceI chargeAccountService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStatus</span><span class="params">(JSONObject param)</span> <span class="keyword">throws</span> ControlException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> status = <span class="keyword">false</span>;</span><br><span class="line">        Class l = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = Class.forName(param.get(<span class="string">&quot;typename&quot;</span>).toString());</span><br><span class="line">            Object obj1 = l.newInstance();</span><br><span class="line">            Method m = l.getMethod(<span class="string">&quot;checkStatus&quot;</span>, param.getClass());</span><br><span class="line">            status = (<span class="keyword">boolean</span>) m.invoke(obj1, param);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ControlException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(e.msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(e.getTargetException().getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(JSONObject param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class l = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l = Class.forName(param.get(<span class="string">&quot;typename&quot;</span>).toString());</span><br><span class="line">            Object classObj = l.newInstance();</span><br><span class="line">            Method m = l.getMethod(<span class="string">&quot;charge&quot;</span>, param.getClass());</span><br><span class="line">            m.invoke(classObj,param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ControlException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ControlException(e.msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>工厂模式示意图：<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/java-reflect1.png" alt="工厂模式结构"></p>
</li>
<li><p>反射相关</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class Son = Class.forName(<span class="string">&quot;fanshe.SonClass&quot;</span>);</span><br><span class="line">    Object son = Son.newInstance();</span><br><span class="line">    Method method = Son.getMethod(<span class="string">&quot;printSonMsg&quot;</span>);</span><br><span class="line">    method.invoke(son);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 2.2 Spring的IOC中的反射</span><br><span class="line">只要在代码或配置文件中看到类的完整路径（包.类），其底层原理基本上使用的就是Java的反射机制。对于Spring，主要关注IOC底层实现的原理（反射），Bean容器的实现。</span><br><span class="line"></span><br><span class="line">- 示例<span class="number">1</span>： 基于 的 Spring 构造器的注入：</span><br><span class="line">```xml</span><br><span class="line">&lt;bean id=&quot;courseDao&quot; class=&quot;com.qcjy.learning.Dao.impl.CourseDaoImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>伪代码解释：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//解析<span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>/&gt;</span>元素的id属性得到该字符串值为“courseDao”</span><br><span class="line">String idStr = &quot;courseDao&quot;;</span><br><span class="line">//解析<span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>/&gt;</span>元素的class属性得到该字符串值为“com.qcjy.learning.Dao.impl.CourseDaoImpl”</span><br><span class="line">String classStr = &quot;com.qcjy.learning.Dao.impl.CourseDaoImpl&quot;;</span><br><span class="line">//利用反射知识，通过classStr获取Class类对象</span><br><span class="line">Class<span class="tag">&lt;<span class="name">?</span>&gt;</span> cls = Class.forName(classStr);</span><br><span class="line">//实例化对象</span><br><span class="line">Object obj = cls.newInstance();</span><br><span class="line">//container表示Spring容器</span><br><span class="line">container.put(idStr, obj);</span><br></pre></td></tr></table></figure>

<ul>
<li>示例2：含属性的bean 通过setter注入：</li>
</ul>
<p>当一个类里面需要应用另一类的对象时，Spring的配置如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;courseService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.qcjy.learning.service.impl.CourseServiceImpl&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 控制调用setCourseDao()方法，将容器中的courseDao bean作为传入参数 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;courseDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">伪代码解释：</span><br><span class="line">```xml</span><br><span class="line">//解析<span class="tag">&lt;<span class="name">property</span> <span class="attr">...</span>/&gt;</span>元素的name属性得到该字符串值为“courseDao”</span><br><span class="line">String nameStr = &quot;courseDao&quot;;</span><br><span class="line">//解析<span class="tag">&lt;<span class="name">property</span> <span class="attr">...</span>/&gt;</span>元素的ref属性得到该字符串值为“courseDao”</span><br><span class="line">String refStr = &quot;courseDao&quot;;</span><br><span class="line">//生成将要调用setter方法名</span><br><span class="line">String setterName = &quot;set&quot; + nameStr.substring(0, 1).toUpperCase()</span><br><span class="line">		+ nameStr.substring(1);</span><br><span class="line">//获取spring容器中名为refStr的Bean，该Bean将会作为传入参数</span><br><span class="line">Object paramBean = container.get(refStr);</span><br><span class="line">//获取setter方法的Method类，此处的cls是刚才反射代码得到的Class对象</span><br><span class="line">Method setter = cls.getMethod(setterName, paramBean.getClass());</span><br><span class="line">//调用invoke()方法，此处的obj是刚才反射代码得到的Object对象</span><br><span class="line">setter.invoke(obj, paramBean);</span><br></pre></td></tr></table></figure>

<p>Spring的IOC部分借鉴：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mlc1218559742/article/details/52774805">https://blog.csdn.net/mlc1218559742/article/details/52774805</a></p>
<h2 id="2-3-Spring的AOP中的反射-使用动态代理模式实现"><a href="#2-3-Spring的AOP中的反射-使用动态代理模式实现" class="headerlink" title="2.3 Spring的AOP中的反射(使用动态代理模式实现)"></a>2.3 Spring的AOP中的反射(使用动态代理模式实现)</h2><ul>
<li>代理模式：静态代理和动态代理，静态代理，顾名思义，就是你自己写代理对象，动态代理，则是在运行期，生成一个代理对象。</li>
<li>AOP：Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象。<br>对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，Spring AOP会使用Cglib，生成一个被代理对象的子类，来作为代理。</li>
</ul>
<p>简单的示例：</p>
<p>Interface: IOperation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行之前的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(Method method)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法执行之后的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：LoggerOperation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerOperation</span> <span class="keyword">implements</span> <span class="title">IOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        Logger.logging(Level.DEBUGE, method.getName() + <span class="string">&quot; Method end .&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        Logger.logging(Level.INFO, method.getName() + <span class="string">&quot; Method Start!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类:DynaProxyHello</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynaProxyHello</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object proxy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要处理的对象(也就是我们要在方法的前后加上业务逻辑的对象,如例子中的Hello)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态生成方法被处理过后的对象 (写法固定)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate,Object proxy)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.delegate.getClass().getClassLoader(), <span class="keyword">this</span>.delegate</span><br><span class="line">                        .getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要处理的对象中的每个方法会被此方法送去JVM调用,也就是说,要处理的对象的方法只能通过此方法调用</span></span><br><span class="line"><span class="comment">     * 此方法是动态的,不是手动调用的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射得到操作者的实例</span></span><br><span class="line">            Class clazz = <span class="keyword">this</span>.proxy.getClass();</span><br><span class="line">            <span class="comment">//反射得到操作者的Start方法</span></span><br><span class="line">            Method start = clazz.getDeclaredMethod(<span class="string">&quot;start&quot;</span>,<span class="keyword">new</span> Class[] &#123; Method.class &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射执行start方法</span></span><br><span class="line">            start.invoke(<span class="keyword">this</span>.proxy, <span class="keyword">new</span> Object[] &#123; method &#125;);</span><br><span class="line">            <span class="comment">//执行要处理对象的原本方法</span></span><br><span class="line">            result = method.invoke(<span class="keyword">this</span>.delegate, args);</span><br><span class="line">            <span class="comment">//反射得到操作者的end方法</span></span><br><span class="line">            Method end = clazz.getDeclaredMethod(<span class="string">&quot;end&quot;</span>,<span class="keyword">new</span> Class[] &#123; Method.class &#125;);</span><br><span class="line">            <span class="comment">//反射执行end方法</span></span><br><span class="line">            end.invoke(<span class="keyword">this</span>.proxy, <span class="keyword">new</span> Object[] &#123; method &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的AOP部分借鉴：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/61615149">https://blog.csdn.net/fuzhongmin05/article/details/61615149</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/17/4-sort/">java实现的排序算法</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-17
        </span></div>
    </header>

    <div class="post-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by AndrewKing on 3/7/2019.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        quick_sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择排序：从第i个元素后面的所有元素中找到最大的，与i交换位置。</span></span><br><span class="line">    <span class="comment">//算法复杂度：O(n2)，稳定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[min];</span><br><span class="line">            nums[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//冒泡排序：扫一次数组，两两交换相邻元素，把最大的元素移到了最右边；数组长度减1后，继续该操作。</span></span><br><span class="line">    <span class="comment">//算法复杂度：O(n2)，稳定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">//统计N次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序：i:每次找到一个元素，归位到左边他的位置;  i++</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//希尔排序：特殊的插入排序, 有可能一次性消除多个逆序对，提高效率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span> nums[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> h =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;N/<span class="number">3</span>)&#123;</span><br><span class="line">            h = h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h &amp;&amp; nums[j]&lt;nums[j-h];j=j-h)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j - h];</span><br><span class="line">                    nums[j - h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m_merge</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> b, <span class="keyword">int</span> mid, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//这里可以只申请一次</span></span><br><span class="line">        <span class="keyword">int</span> i=b, j=mid+<span class="number">1</span>; <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=b;k&lt;=e;k++)&#123; <span class="comment">//辅助空间</span></span><br><span class="line">            aux[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=b;k&lt;=e;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                nums[k]= aux[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;e)&#123;</span><br><span class="line">                nums[k] =aux[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&gt;=aux[j])&#123;</span><br><span class="line">                nums[k] = aux[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k] = aux[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归写法：top-down  m_sort先分， m_merge后合，复杂度: O(logN)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m_sort_topDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e&lt;=<span class="number">1</span> || b&gt;=e)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = b+ (e-b)/<span class="number">2</span>; <span class="comment">// 不能写成  (b+e)/2 会有溢出危险。</span></span><br><span class="line">        m_sort_topDown(nums, b,mid);</span><br><span class="line">        m_sort_topDown(nums, mid+<span class="number">1</span>, e);</span><br><span class="line">        m_merge(nums,b,mid,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环写法：bottom-up,先分后合，复杂度: O(logN)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m_sort_bottomUp</span><span class="params">(<span class="keyword">int</span> nums[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">1</span>;sz&lt;len;sz=sz*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;len-sz;b=b+<span class="number">2</span>*sz)&#123;</span><br><span class="line">                m_merge(nums,b,b+sz-<span class="number">1</span>,Math.min(b+<span class="number">2</span>*sz-<span class="number">1</span>,len-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = partition2(nums, l, h);</span><br><span class="line">        quick_sort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">        quick_sort(nums, j + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己写的比较麻烦</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=l+<span class="number">1</span>, j=h;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=j;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[l])&#123;</span><br><span class="line">                i++;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[l])&#123;</span><br><span class="line">                j--;<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">            i++;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&lt;nums[l])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">            nums[l]=nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较简洁</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=l, j=h+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[++i]&lt;nums[l] &amp;&amp; i!=h)&#123; &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[--j]&gt;nums[l] &amp;&amp; j!=l)&#123; &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i]= nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">        nums[j]= nums[l];</span><br><span class="line">        nums[l] = temp;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/12/offer-hunter/">求生之路</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-12
        </span></div>
    </header>

    <div class="post-content"><h1 id="Tencent-2019-3-12-person-round1-fail"><a href="#Tencent-2019-3-12-person-round1-fail" class="headerlink" title="Tencent_2019.3.12_person_round1_fail"></a>Tencent_2019.3.12_person_round1_fail</h1><ol>
<li>算法题<br>Given a collection of intervals, merge all overlapping intervals.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>来源 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a><br>答案：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    List&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">    Collections.sort(intervals, <span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.start&lt;o2.start)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.start==o2.start)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result.add(intervals.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Interval temp=overlap(result.get(j),intervals.get(i));</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                result.add(intervals.get(i));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.remove(j);</span><br><span class="line">                result.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Interval <span class="title">overlap</span><span class="params">(Interval o1, Interval o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o2.start&gt;o1.end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.end&gt;=o2.end)&#123;</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Interval(o1.start,o2.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>进程间切换，操作系统发生了哪些步骤</p>
</li>
<li><p>进程间通信的方式</p>
</li>
<li><p>java里面继承和实现的区别，细节  </p>
<p> 继承：  </p>
<ul>
<li><p>只能继承一个父类。 （如果能继承两个父类，会出现“致命的钻石问题”）</p>
</li>
<li><p>子类拥有父类非 private 的属性、方法; 子类可以重写父类的方法。</p>
</li>
<li><p>静态方法：</p>
<p>实现：</p>
</li>
<li><p>可以实现多个接口。</p>
</li>
<li><p>实现类必须实现接口的所有方法。  </p>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li>数据库的三大范式，细节解释  </li>
</ol>
<h1 id="360-2019-3-20-person-round3-AC"><a href="#360-2019-3-20-person-round3-AC" class="headerlink" title="360_2019.3.20_person_round3_AC"></a>360_2019.3.20_person_round3_AC</h1><ol>
<li>项目相关：  </li>
</ol>
<ul>
<li>能力开放平台，鉴权；如何实现正常调用程序（而非测试环节）；计费。</li>
</ul>
<ol start="2">
<li>jvm：</li>
</ol>
<ul>
<li>java内存模型</li>
<li>java垃圾收集：判断对象是否被回收，类的卸载，垃圾收集算法，垃圾收集器，G1垃圾收集器</li>
</ul>
<h1 id="Alibaba-新零售平台事业部-2019-3-22-phone-round1-AC"><a href="#Alibaba-新零售平台事业部-2019-3-22-phone-round1-AC" class="headerlink" title="Alibaba_新零售平台事业部_2019.3.22_phone_round1_AC"></a>Alibaba_新零售平台事业部_2019.3.22_phone_round1_AC</h1><ol>
<li><p>自我介绍  </p>
</li>
<li><p>项目相关：</p>
</li>
</ol>
<ul>
<li><p>背景、解决的问题、系统的架构设计、模块分层</p>
</li>
<li><p>redis：1. 为什么选取redis而不选择其他 消息中间件； 2. MySQL数据库与Redis缓存数据一致性问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">问题1：选取redis而不选择其他 消息中间件</span><br><span class="line"></span><br><span class="line"> 优点：</span><br><span class="line">    1. 将redis 当做轻量级的队列服务使用，与RabbitMQ相比：</span><br><span class="line">        对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。</span><br><span class="line">        测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：</span><br><span class="line">        入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；</span><br><span class="line">        出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</span><br><span class="line"></span><br><span class="line">    2. redis 消息推送是基于分布式 pub&#x2F;sub，多用于实时性较高的消息推送，并不保证可靠。</span><br><span class="line">        其他的mq和kafka保证可靠但有一些延迟（非实时系统没有保证延迟）</span><br><span class="line"></span><br><span class="line"> 缺点：</span><br><span class="line">    1. redis 消息推送不可靠，redis-pub&#x2F;sub断电就清空。</span><br><span class="line">    2. redis-pub&#x2F;sub没有提供“分组”这个概念, 与kafka相比，</span><br><span class="line">        比如kafka中发布一个东西，多个订阅者可以分组，同一个组里只有一个订阅者会收到该消息，</span><br><span class="line">        这样可以用作负载均衡</span><br><span class="line"></span><br><span class="line">问题2：MySQL数据库与Redis缓存数据一致性问题：</span><br><span class="line"></span><br><span class="line">  解决方式：</span><br><span class="line">    增：写数据只写db</span><br><span class="line">    改：更新数据先更新db，再失效cache</span><br><span class="line">    查：读数据，先读cache，未命中读db，写入cache</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>基础知识：   </li>
</ol>
<ul>
<li><p>解决hash冲突的方法：拉链法，rehash:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.『hash』: 翻译为“散列”，就是把任意长度的输入，通过散列算法，变成固定长度的输出，该输出就是散列值。</span><br><span class="line">这种转换是一种压缩映射，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。</span><br><span class="line"></span><br><span class="line">2. 『hash冲突』：根据key即经过一个函数f(key)得到的结果的作为地址去存放当前的key value键值对(这个是hashmap的存值方式)，但是却发现算出来的地址上已经有人先来了。</span><br><span class="line"></span><br><span class="line">3. 『解决hash冲突的办法』：</span><br><span class="line">开放地址法：(open addressing)</span><br><span class="line">    线性探测法(linear probing)、平方探测法(Quadratic probing)、双散列算法(double hashing)、再散列（rehashing）</span><br><span class="line">分离链表法：（Sperate Chaining）【拉链法】</span><br><span class="line">    将相应位置上冲突的所有关检测存储在同一个单链表中</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP的可靠性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 『差错控制』:</span><br><span class="line">TCP通过 校验和 、 确认 以及 超时重传 这三个工具，来检测和重传受到损伤的报文段、并重传丢失的报文段、保存失序到底的报文段直至缺失的报文段到期，以及检测和丢弃重复的报文段。</span><br><span class="line"></span><br><span class="line">2. 『流量控制』:</span><br><span class="line">TCP通过接收窗口的大小来调节生产者产生数据的速度和消费者消耗数据的数据，达到一种动态平衡。</span><br><span class="line"></span><br><span class="line">3.『拥塞控制』:</span><br><span class="line">慢开始、拥塞避免、快重传、快恢复</span><br></pre></td></tr></table></figure>
</li>
<li><p>java的类加载机制，一个应用从启动到运行的机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</span><br><span class="line"></span><br><span class="line">类从被虚拟机加载到内存中开始，到卸载出内存为止，它的生命周期经历了</span><br><span class="line">    加载（Loading）、</span><br><span class="line">    连接</span><br><span class="line">        验证（Verification）、</span><br><span class="line">        准备（Preparation）、</span><br><span class="line">        解析（Resolution）、</span><br><span class="line">    初始化（Initialization）、</span><br><span class="line">    使用（Using）</span><br><span class="line">    卸载（Unloading）</span><br></pre></td></tr></table></figure>
</li>
<li><p>java的内存管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Java 的内存管理就是对象的分配和释放问题。（两部分）</span><br><span class="line"></span><br><span class="line">1. 对象的分配与存储：</span><br><span class="line">    1.1 JVM 的内存区域组成</span><br><span class="line">    1.2 各种数据类型在java中的存储：</span><br><span class="line">        在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</span><br><span class="line">         （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中</span><br><span class="line">         （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的。</span><br><span class="line"></span><br><span class="line">        在类中声明的变量是成员变量，也叫全局变量，放在堆中的：</span><br><span class="line">        （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</span><br><span class="line">        （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。</span><br><span class="line"></span><br><span class="line">2. 对象的释放（GC）:</span><br><span class="line">	2.1 如何判断对象应该被回收:</span><br><span class="line">		引用计数算法；可达性分析算法；方法区域的回收。</span><br><span class="line">	2.2 怎么回收（垃圾收集的4种算法）：</span><br><span class="line">		标记-清除；标记-整理；复制；分代收集</span><br><span class="line">	2.3 7种垃圾收集器</span><br><span class="line">		Serial,ParNew,Parallel Scavenge, Serial Old, Parallel Old, CMS, G1</span><br><span class="line">	2.4 内存分配与回收策略</span><br></pre></td></tr></table></figure>
</li>
<li><p>java OOM 异常处理 （OutOfMemoryError）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. Java堆溢出</span><br><span class="line">    Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，对象数量达到最大堆容量限制，则发生溢出。(有点类似于“内存泄露”)</span><br><span class="line">  </span><br><span class="line">2. 虚拟机栈和本地方法栈溢出</span><br><span class="line">    StackOverFlow：线程申请的栈深度超过允许的最大深度</span><br><span class="line">    OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间</span><br><span class="line"></span><br><span class="line">3. 方法区和运行常量池溢出</span><br><span class="line">    方法区用于存放Class的相关信息，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。</span><br><span class="line">    例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；</span><br><span class="line">    大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。</span><br><span class="line"></span><br><span class="line">    运行时常量池：JDK7之前会有，不做研究。</span><br><span class="line"></span><br><span class="line">4. 本地直接内存溢出 </span><br><span class="line">    通过Unsafe类直接分配内存时，过大则会溢出。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>详见：<a href="http://ztxpp.cc/2019/03/23/java-OOM/">java OOM 异常处理</a></p>
<ol start="4">
<li>你最近在学习什么新技术？在看什么书？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">技术层面：深入理解JVM虚拟机</span><br><span class="line">架构层面：微服务</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Alibaba-新零售平台事业部-2019-3-28-phone-round2-AC"><a href="#Alibaba-新零售平台事业部-2019-3-28-phone-round2-AC" class="headerlink" title="Alibaba_新零售平台事业部_2019.3.28_phone_round2_AC"></a>Alibaba_新零售平台事业部_2019.3.28_phone_round2_AC</h1><ol>
<li>Java 代码编译和执行的整个过程； 类加载机制；<br><img src="http://wiki.jikexueyuan.com/project/java-vm/images/javadebug.gif" alt="java编译过程"><br><img src="http://wiki.jikexueyuan.com/project/java-vm/images/jvmdebug.gif" alt="java字节码的执行"></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java 代码编译和执行的整个过程,包含以下三个重要的机制：</span><br><span class="line"> 1. Java源码编译机制：</span><br><span class="line">                    分析和输入到符号表</span><br><span class="line">                    注解处理</span><br><span class="line">                    语义分析和生成 class 文件</span><br><span class="line"> 2. 类加载机制：</span><br><span class="line">                    双亲委派模型</span><br><span class="line"> 3. 类执行机制：</span><br><span class="line">                    JVM 是基于栈的体系结构来执行 class 字节码的。</span><br><span class="line">                    线程创建后，都会产生程序计数器（PC）和栈（Stack），</span><br><span class="line">                    （1）程序计数器存放下一条要执行的指令在方法内的偏移量，</span><br><span class="line">                    （2）栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>两个类，类和包名完全相同，应该从classLoader上面怎么处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当项目中同时出现两个相同的名称的 类（包名、类名都相同），且 两个jar包都要引用，不能删除某个jar包的import：</span><br><span class="line">    可以利用编译器修改引入 jar包的顺序,例如用IDEA, project structure -&gt; modules -&gt; Dependencies,手动修改顺序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>七层协议，每个有什么用；物理层有什么协议；wifi是那一层的协议；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1) 物理层：传送数据的单位是比特。物理层的任务就是透明地传送比特流。</span><br><span class="line"></span><br><span class="line">(2) 数据链路层（链路层）：将网络层交下来的 IP 数据报组装成帧，在两个相邻结点（主机和路由器，或两个路由器）之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</span><br><span class="line"></span><br><span class="line">(3) 网络层：使用无连接的网际协议 IP 和许多种路由选择协议。负责为分组交换网上的不同主机提供通信服务，把运输层产生的报文段或用户数据报封装成分组（也叫IP数据报或数据报）或包进行传送。网络层的另一个任务就是选择合适的路由</span><br><span class="line"></span><br><span class="line">(4) 传输层：向两个主机中进程之间的通信提供服务。</span><br><span class="line"></span><br><span class="line">(5) 应用层：直接为用户的应用进程提供服务，如 HTTP、支持文件传输的 FTP 协议等</span><br></pre></td></tr></table></figure>
</li>
<li><p>加密算法有什么了解?</p>
</li>
<li><p>数据库事务，怎么保障的，全盘通讲。</p>
</li>
<li><p>数据库索引的数据结构；多列索引</p>
</li>
<li><p>B+树 和 B树 相比有什么优点；</p>
</li>
<li><p>平衡树 都有哪些？</p>
</li>
<li><p>Spring IOC, AOP</p>
</li>
<li><p>项目里面为啥使用redis</p>
</li>
<li><p>servlet 与 filter， 流 有什么共同点</p>
</li>
<li><p>设计模式 了解哪些</p>
</li>
<li><p>算法方面，深度学习了解多少</p>
</li>
<li><p>学科专业上的安排，毕设的情况</p>
</li>
</ol>
<h1 id="Amazon-SDE-Software-Develop-Engineer-2019-3-29-round1-amp-2"><a href="#Amazon-SDE-Software-Develop-Engineer-2019-3-29-round1-amp-2" class="headerlink" title="Amazon_SDE(Software Develop Engineer)_2019.3.29_round1&amp;2"></a>Amazon_SDE(Software Develop Engineer)_2019.3.29_round1&amp;2</h1><h2 id="round-1-mentor面"><a href="#round-1-mentor面" class="headerlink" title="round_1 (mentor面)"></a>round_1 (mentor面)</h2><ol>
<li><p>系统设计 （商品的推荐商品），这个功能怎么设计，细化到数据库的表结构</p>
</li>
<li><p>一个印象最深刻的项目（设计模式）</p>
</li>
<li><p>项目中 一个与老师之间battle的例子，细节</p>
</li>
</ol>
<h2 id="round-2-基础面"><a href="#round-2-基础面" class="headerlink" title="round_2 (基础面)"></a>round_2 (基础面)</h2><ol>
<li><p>讲比赛的项目（天池）</p>
</li>
<li><p>两道算法题</p>
</li>
</ol>
<ul>
<li>Symmetric tree： 题目和解答</li>
<li>博物馆的max人数的时刻：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目：给定array[]长度为1000,  存的 &lt;a,b&gt;，意义为 a:某人进入博物馆的时刻，b 此人离开博物馆的时刻，问哪些时刻博物馆的人最多。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Amazon-SDE-Software-Develop-Engineer-2019-4-2-offerCall-accept"><a href="#Amazon-SDE-Software-Develop-Engineer-2019-4-2-offerCall-accept" class="headerlink" title="Amazon_SDE(Software Develop Engineer)_2019.4.2_offerCall_accept"></a>Amazon_SDE(Software Develop Engineer)_2019.4.2_offerCall_accept</h2><h1 id="360-2019-4-4-IT架构中心java开发-offerCall-reject"><a href="#360-2019-4-4-IT架构中心java开发-offerCall-reject" class="headerlink" title="360_2019.4.4_IT架构中心java开发_offerCall_reject"></a>360_2019.4.4_IT架构中心java开发_offerCall_reject</h1><h1 id="Alibaba-新零售平台事业部-2019-4-4-phone-round3-AC"><a href="#Alibaba-新零售平台事业部-2019-4-4-phone-round3-AC" class="headerlink" title="Alibaba_新零售平台事业部_2019.4.4_phone_round3_AC"></a>Alibaba_新零售平台事业部_2019.4.4_phone_round3_AC</h1><ol>
<li><p>自我介绍（着重介绍技术项目）</p>
</li>
<li><p>流控（redis）：</p>
</li>
</ol>
<ul>
<li>使用滑动窗口的具体业务需求是什么？</li>
<li>三年之后的业务量大概是多少？</li>
<li>假如 api的数量到达很大的级别（千万级），redis的性能怎么保证，怎么解决？  </li>
</ul>
<ol start="3">
<li><p>权限控制 表级别的权限控制</p>
</li>
<li><p>协议转换 代码细节</p>
</li>
<li><p>程序里面发生了很多 full GC， 你该怎么解决？</p>
</li>
<li><p>流控的时候，redis的并发安全问题？内存的并发安全问题？</p>
</li>
<li><p>你的能力开放平台系统，压力测试情况，系统测试情况？</p>
</li>
</ol>
<h1 id="阿里hr面准备："><a href="#阿里hr面准备：" class="headerlink" title="阿里hr面准备："></a>阿里hr面准备：</h1><ol>
<li>做项目的启发和经历：</li>
</ol>
<ul>
<li>国家电网的项目，系统的设计，微服务的思想，设计模式等等。重设计，轻实现。</li>
</ul>
<ol start="2">
<li><p>流控和协议转换，是自己做的么？</p>
</li>
<li><p>对阿里的看法：  </p>
</li>
</ol>
<ul>
<li>让天下没有难做的生意，让天下没有难做的算法和应用。</li>
<li>一流的企业做标准，二流三流才是做文化.品牌.解决方案。阿里有完整的java的生态体系，和自己的jvm，从几轮面试中也能看出来。阿里和我自己的技术展非常契合，我在前几年的确是想好好来阿里学习、钻研技术的。</li>
</ul>
<ol start="4">
<li>一个最困难的事情，怎么解决的：</li>
</ol>
<ul>
<li>系统架构的设计；能力开发平台的加班；线上线下的联调；</li>
</ul>
<ol start="5">
<li>对自己的职业发展的规划：</li>
</ol>
<ul>
<li>前几年先在大公司好好扎实做技术，然后做技术深入或者，转管理岗位。</li>
</ul>
<ol start="6">
<li>我的缺点;我的优点：</li>
</ol>
<ul>
<li>缺点：有时候太细致，较真儿。可能会拖慢项目进度。总喜欢最后check一下。不确定正确的事情也不敢下定论。</li>
</ul>
<ol start="7">
<li><p>你最自豪的一件事情：</p>
</li>
<li><p>其他家公司的offer已有的：</p>
</li>
<li><p>还在面试其他家公司吗？</p>
</li>
<li><p>其他家的公司和阿里比较，会选择阿里吗？</p>
</li>
<li><p>可以选择的工作地点？</p>
</li>
<li><p>996怎么看待？   </p>
</li>
</ol>
<h1 id="阿里hr面试-2019-4-10："><a href="#阿里hr面试-2019-4-10：" class="headerlink" title="阿里hr面试_2019.4.10："></a>阿里hr面试_2019.4.10：</h1><ol>
<li><p>能接受在杭州工作吗？</p>
</li>
<li><p>女朋友有吗？女朋友的工作地点？</p>
</li>
<li><p>你影响最深刻的一个项目，项目的背景，你在当中承担的职责，项目中你解决的最大的一个难题。体现出你的什么品质？</p>
</li>
<li><p>你的优点，缺点</p>
</li>
</ol>
<h1 id="京东1面-onsite-2019-9-1"><a href="#京东1面-onsite-2019-9-1" class="headerlink" title="京东1面_onsite_2019.9.1:"></a>京东1面_onsite_2019.9.1:</h1><p>主要问项目</p>
<h1 id="京东2面-onsite-2019-9-4"><a href="#京东2面-onsite-2019-9-4" class="headerlink" title="京东2面_onsite_2019.9.4:"></a>京东2面_onsite_2019.9.4:</h1><p>面试官让从 数据库、数据结构、操作系统、网络这四个部分选择一个，我选的数据库。</p>
<ol>
<li>数据库索引<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给mysql数据库的一张表，设置（a,b,c）三列的联合索引，问下列哪种情况能够用到这个索引？</span><br><span class="line">1. select * from table where a &#x3D; 1 and b &#x3D; 1 and c &#x3D; 1;</span><br><span class="line">2. select * from table where b &#x3D; 1 and c &#x3D; 1;</span><br><span class="line">3. select * from table where c &#x3D; 1;</span><br><span class="line">4. select * from table where a LIKE &#39;com%&#39;;</span><br><span class="line">5. select * from table where a LIKE &#39;%com&#39;;</span><br><span class="line">6. select * from table where md5(a) &#x3D; 1;</span><br><span class="line">7. select * from table where a &#x3D; now(); </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 用到   2，3 没有     &#x2F;&#x2F; 索引最左前缀匹配，原理上是符合排序，有a即用到。 </span><br><span class="line">4. 用到   5.没有用      &#x2F;&#x2F; LIKE模糊查询，右模糊用到了a的索引，左模糊就不知道怎么往b+树里面找了</span><br><span class="line">6. 没有   7.用到        &#x2F;&#x2F; 对左侧做函数操作用不了索引，对右侧做函数操作，能用索引，本质上还是在b+树里面能不能找到</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设计数据库结构，存储 “组织架构”（树）, 满足下面三个功能，并说出算法复杂度：</li>
</ol>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190905163425.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 能利用ID进行CRUD操作</span><br><span class="line">2. 找到一个节点的全路径</span><br><span class="line">3. 找到一个节点的下属所有节点</span><br></pre></td></tr></table></figure>

<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/9fb03b0fb1f09c2813910bee0518c37.png"></p>
<p>回答：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法1.第一反应</span><br><span class="line">1.  O(1)的查找，增加删除节点要满足一定的约束条件</span><br><span class="line">2.  O(n)的递归方式查找： 这里指的需要n次查询</span><br><span class="line">3.  O(n)的方式循环查找： 这里指的需要n次查询</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">法2.经过提示，数据库里面可以存更多信息，即保存路径</span><br><span class="line">1. 增加节点的时候，需要先查出父节点的parent,添加到自己的parent上，O(1)</span><br><span class="line">2. O(1) 找一个节点的全路径</span><br><span class="line">3. O(1) 找到一个节点的所有子节点，一次查询可以知道结果</span><br><span class="line">eg: select * from table where parent LIKE A%;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上十亿级别的数据，怎么做多列筛选（待整理）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017180119">https://segmentfault.com/a/1190000017180119</a></p>
<p>主要方案：</p>
<ul>
<li>更换存储引擎，选用列式存储，hybridDB之类。</li>
<li>采用缓存，记录中间结果。</li>
<li>采用计算中间表，来进行保存结果。</li>
</ul>
<h1 id="京东hr面-他人题目-准备"><a href="#京东hr面-他人题目-准备" class="headerlink" title="京东hr面_他人题目_准备"></a>京东hr面_他人题目_准备</h1><ol>
<li><p>自我介绍</p>
</li>
<li><p>个人目前面试实习情况</p>
</li>
</ol>
<ul>
<li>目前offer有阿里，面试中有京东；</li>
</ul>
<ol start="3">
<li>why 京东 not others</li>
</ol>
<ul>
<li><p>个人观感，更喜欢在京东上买东西，更快，更正规。</p>
</li>
<li><p>京东优势：</p>
<ul>
<li>自营型电商更有优势，阿里更多的是平台型电商</li>
<li>最好最快的快递：物流体系更加健全。</li>
<li>只卖真货：对于库存的把控更加严格</li>
</ul>
</li>
<li><p>当马云轻轻松松赚的盆钵满盈、走上“神坛”、呼风唤雨之时，刘强东还在苦逼兮兮地和快递员们称兄道弟、打成一片。问题是，羊毛不会出在狗身上，马云虽富，却是建立在数百万商家挣扎生存的前提下；刘强东虽穷，但效率未必就不能致胜。在零售业的链条上，京东和阿里都各占一环，到底谁的模式才是更合理的资源配置模式？探讨这个问题需要对产业链的上下游进行综合分析。</p>
</li>
<li><p>京东供应链部门：复杂性更高，更加成熟，sku数更多</p>
</li>
</ul>
<ol start="4">
<li>个人优势</li>
</ol>
<ul>
<li>怎么体现出很match<ul>
<li>开发项目经历</li>
<li>获奖经历</li>
<li>更喜欢了解业务</li>
</ul>
</li>
</ul>
<ol start="5">
<li>京东企业价值观</li>
</ol>
<ul>
<li>使命：科技引领生活</li>
<li>核心价值观：<ul>
<li>客户为先、诚信、 协作</li>
<li>感恩 、拼搏 、担当</li>
</ul>
</li>
<li>愿景<ul>
<li>成为全球最值得信赖的企业</li>
</ul>
</li>
</ul>
<ol start="6">
<li><p>个人诚信自我评分</p>
<p>95分</p>
</li>
<li><p>有什么问题</p>
</li>
</ol>
<p>地点问题，换地点，换岗位的相关问题</p>
<h1 id="京东hr面-onsite-2019-9-6"><a href="#京东hr面-onsite-2019-9-6" class="headerlink" title="京东hr面_onsite_2019.9.6"></a>京东hr面_onsite_2019.9.6</h1><ol>
<li><p>名字的含义</p>
</li>
<li><p>自我介绍</p>
</li>
<li><p>讲讲阿里的经历，对自我的提升</p>
</li>
<li><p>对于互联网的负面性怎么看？人员流动性大，压力大，怎么看？</p>
</li>
<li><p>身边的人怎么评价你？</p>
</li>
</ol>
<h1 id="拼多多1面-电话-视频-2019-9-17-耻辱之战"><a href="#拼多多1面-电话-视频-2019-9-17-耻辱之战" class="headerlink" title="拼多多1面_电话+视频_2019.9.17(耻辱之战)"></a>拼多多1面_电话+视频_2019.9.17(耻辱之战)</h1><ol>
<li><p>数据库与消息队列，怎么保证数据正确读取时发送消息；数据存取失败时，不发送消息</p>
</li>
<li><p>HashMap 和 linkedHashMap的底层数据结构； hashmap线程安全怎么保证； hashmap实现LRU算法； LinkedHashMap 的LRU算法怎么保证线程安全？</p>
</li>
<li><p>redis在进行并发操作的时候怎么保证线程安全</p>
</li>
<li><p>数据库索引</p>
</li>
<li><p>多路归并算法</p>
</li>
<li><p>讲一下微服务</p>
</li>
<li><p>怎么实现论坛的回帖数在多线程情况下不重复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. mysql层面： 采用 for update 操作，保证读取时，具有排它锁</span><br><span class="line"></span><br><span class="line">2. redis层面： 采用incr 原子性操作，设计一个分布式锁。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="字节跳动-北京-商业变现部门-1面-onsite-2019-9-23"><a href="#字节跳动-北京-商业变现部门-1面-onsite-2019-9-23" class="headerlink" title="字节跳动_北京_商业变现部门_1面_onsite_2019.9.23"></a>字节跳动_北京_商业变现部门_1面_onsite_2019.9.23</h1><ol>
<li>java反射，Spring IOC</li>
<li>线程与进程区别，用户态与内核态</li>
<li>JVM：垃圾回收机制，垃圾回收器，java内存模型</li>
<li>TCP四次挥手，time wait的作用，导致的问题； </li>
<li>TCP的拥塞控制细节（四个过程）；慢开始为什么是指数型增长？</li>
<li>HTTP的状态码分类；</li>
<li>数据结构hash表，b+树讲解；hashmap的效率当一个节点下面的链表过长怎么优化。</li>
<li>讲一下rocketMQ，消息中间件</li>
<li>微服务系统之间三种通信方式的优缺点，RPC,HTTP,MQ</li>
<li>讲一下RPC为什么比较快 &gt; 序列化</li>
<li>讲一下项目中的dstunnel</li>
<li>算法题：将 ../a/b/c/./d/../e/../f 优化成为 a/b/c/f </li>
</ol>
<h1 id="字节跳动-北京-商业变现部门-2面-onsite-2019-9-23"><a href="#字节跳动-北京-商业变现部门-2面-onsite-2019-9-23" class="headerlink" title="字节跳动_北京_商业变现部门_2面_onsite_2019.9.23"></a>字节跳动_北京_商业变现部门_2面_onsite_2019.9.23</h1><ol>
<li>讲一下数据库索引，b树与b+树的区别</li>
<li>数据库优化优化查询</li>
<li>阿里的实习给你带来什么收获，层次不高面试官不开心</li>
<li>算法题：归并两个有序链表</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/02/28/3-array/">牛客网 > leetcode > 数组算法 题目总结</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-28
        </span></div>
    </header>

    <div class="post-content"><p>牛客网上 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/leetcode">leetCode</a> 在线练习部分 全部二叉树算法汇总，索引到我的笔记</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组是属于最基础的数据结构，比较灵活。</li>
<li>首先注意是否是排序？递增？非递减？乱序？的数组。 有序的数组的查找问题想到用“二分查找”，</li>
<li>数组中多用到双指针滑动窗口（和为S的连续正数序列），或者双指针夹逼(eg:和为S的两个数字)，或者带flag的双指针夹逼（eg:蓄水池问题）</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>牛客网上 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/coding-interviews">剑指offer</a> 在线练习部分 全部 数组 算法汇总，索引到我的笔记</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">题目</th>
<th align="center">考点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/324621?tags=%E6%95%B0%E7%BB%84">数组中重复的数字(剑指3)</a></td>
<td align="center">数组中的数字在0到n-1的范围内。ztp:hashset或hashmap辅助;  标准解法：利用数字大小的特点，众神归位，谁的位子被占了就是重复的（节省空间）</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/307089?tags=%E6%95%B0%E7%BB%84">二维数组中的查找（剑指4）</a></td>
<td align="center">找到唯一方向的路径（从左下角开始，比input大则上移，比input小则右移。递归。）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/307177?tags=%E6%95%B0%E7%BB%84">旋转数组的最小数字(剑指11)</a></td>
<td align="center">对非减排序的数组的一个旋转，再找到最小值：二分查找 O(logn)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/316936?tags=%E6%95%B0%E7%BB%84">数组中出现次数超过一半的数字(剑指39)</a></td>
<td align="center">ztp: hashmap辅助操作。 标准：摩尔投票法(每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个)</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/316964?tags=%E6%95%B0%E7%BB%84">连续子数组的最大和(剑指42)</a></td>
<td align="center">关键问题是找起点，找终点。起点：若 sum+array[i] &lt; array[i],即 sum&lt;0, 前面的sum 加了不如不加，弃之，从i开始；终点：不好找，不用找。遍历一遍，把 sumMax 往上顶即可。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/317008?tags=%E6%95%B0%E7%BB%84">把数组排成最小的数(45)</a></td>
<td align="center">重新定义Comparator排序规则（或者组合排序，例如商品的性质A和性质B同时决定商品的价格）。 变相的排序问题，1. 制定排序规则 2.排序（本题目用的是collection的匿名内部类来实现，算法复杂度 O(Nlog(N)) ）；需要注意：大数问题，用string解决。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/317038?tags=%E6%95%B0%E7%BB%84">数组中的逆序对(剑指51)</a></td>
<td align="center">消除逆序对，归并排序变化,算法复杂度为O(Nlog(N))。排序问题本质是消除逆序对，只通过交换相邻元素来消除逆序对的做法，算法复杂度为 O(n2);</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/322863?tags=%E6%95%B0%E7%BB%84">数字在排序数组中出现的次数（剑指53）</a></td>
<td align="center">凡是排序数组，想到二分查找</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/323118?tags=%E6%95%B0%E7%BB%84">数组中只出现一次的数字(剑指56)</a></td>
<td align="center">经典题目（1.只出现一次的1个数；2.只出现一次的两个数，其他数字出现偶数次）异或。 异或满足交换律和结合律。 异或的本质是不带进位的加法。 只出现一次的1个数，则异或全部数字； 只出现一次的2个数，则拆分成两个子数组。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/323206?tags=%E6%95%B0%E7%BB%84">和为S的两个数字（剑指57.1）</a></td>
<td align="center">经典题目（1.数组是递增排列；2.数组中可能有重复的数字）双指针夹逼</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/323188?tags=%E6%95%B0%E7%BB%84">和为S的连续正数序列(剑指57.2)</a></td>
<td align="center">上面题目的变式，双指针滑动窗口</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/324691?tags=%E6%95%B0%E7%BB%84">构建乘积数组（剑指66）</a></td>
<td align="center">构建乘积但不允许使用除法。想到用两个数组来保存中间结果，如何初始化这两个数组，想到将通项公式转化为递推公式。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/01/22/dockerstudy4/">Docker环境下前后端分离项目部署与运维(四)</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-22
        </span></div>
    </header>

    <div class="post-content"><p>为了搭建 <strong>高性能、高负载、高可用</strong> 的系统，继续<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/219.html">本课程</a>的学习。 </p>
<h1 id="第6章-后端项目部署与负载均衡"><a href="#第6章-后端项目部署与负载均衡" class="headerlink" title="第6章 后端项目部署与负载均衡"></a>第6章 后端项目部署与负载均衡</h1><h2 id="1-后端项目部署与负载均衡"><a href="#1-后端项目部署与负载均衡" class="headerlink" title="1.后端项目部署与负载均衡"></a>1.后端项目部署与负载均衡</h2><h3 id="1-1-导入数据库，配置数据库连接"><a href="#1-1-导入数据库，配置数据库连接" class="headerlink" title="1.1 导入数据库，配置数据库连接"></a>1.1 导入数据库，配置数据库连接</h3><p>用数据库工具连接 在 <a href="http://ztxpp.cc/2019/01/17/dockerStudy2/">Docker环境下前后端分离项目部署与运维(二)</a> 中 配置好的服务器数据库集群，宿主机虚拟ip：10.103.238.200:3306，导入renren_fast后端的mysql数据。</p>
<p>在renren_fast工程中修改数据库的连接配置文件 application-dev.yml， 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    datasource:</span><br><span class="line">        type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">        driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">        druid:</span><br><span class="line">            first:  #数据源1</span><br><span class="line">                url: jdbc:mysql:&#x2F;&#x2F;10.103.238.200:3306&#x2F;renren_fast?allowMultiQueries&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">                username: root</span><br><span class="line">                password: abc123456</span><br><span class="line">            second:  #数据源2</span><br><span class="line">                url: jdbc:mysql:&#x2F;&#x2F;10.103.238.200:3306&#x2F;renren_fast?allowMultiQueries&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8</span><br><span class="line">                username: root</span><br><span class="line">                password: abc123456</span><br></pre></td></tr></table></figure>

<h3 id="1-2-添加-Redis-集群"><a href="#1-2-添加-Redis-集群" class="headerlink" title="1.2 添加 Redis 集群"></a>1.2 添加 Redis 集群</h3><p>修改renren_fast工程中的 Redis配置文件 application.yml。 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> redis:</span><br><span class="line">    open: false  # 是否开启redis缓存  true开启   false关闭</span><br><span class="line">    database: 0</span><br><span class="line">#    host: localhost</span><br><span class="line">#    port: 6379</span><br><span class="line">#    password:    # 密码（默认为空）</span><br><span class="line">    timeout: 6000ms  # 连接超时时长（毫秒）</span><br><span class="line">    cluster:</span><br><span class="line">      nodes:</span><br><span class="line">      - 172.19.0.2:6379</span><br><span class="line">      - 172.19.0.3:6379</span><br><span class="line">      - 172.19.0.4:6379</span><br><span class="line">      - 172.19.0.5:6379</span><br><span class="line">      - 172.19.0.6:6379</span><br><span class="line">      - 172.19.0.7:6379</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 1000  # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">        max-wait: -1ms      # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">        max-idle: 10      # 连接池中的最大空闲连接</span><br><span class="line">        min-idle: 5       # 连接池中的最小空闲连接</span><br></pre></td></tr></table></figure>

<h3 id="1-3-修改-tomcat-端口设置"><a href="#1-3-修改-tomcat-端口设置" class="headerlink" title="1.3 修改 tomcat 端口设置"></a>1.3 修改 tomcat 端口设置</h3><p>注意：renren_fast工程运行的java网段，应当直接设置为服务器的宿主机的网段，因为docker禁止跨网段相互调用。（如果java环境设置为net3,之前设置的database集群为net1网段，redis集群为net2网段，则不方便调用）。然而如果要是后端程序能多节点负载均衡，则需要将不同后端代码开启不同的端口，此处修改renren_fast工程中的 Redis配置文件 application.yml。 修改如下：将端口改为 6001 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Tomcat</span><br><span class="line">server:</span><br><span class="line">  tomcat:</span><br><span class="line">    uri-encoding: UTF-8</span><br><span class="line">    max-threads: 1000</span><br><span class="line">    min-spare-threads: 30</span><br><span class="line">  port: 6001</span><br><span class="line">  connection-timeout: 5000ms</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: &#x2F;renren-fast</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-Maven打包部署"><a href="#1-4-Maven打包部署" class="headerlink" title="1.4 Maven打包部署"></a>1.4 Maven打包部署</h3><p>renren-fast包含了tomcat.jar文件，利用maven打成jar包，部署在具有java环境的docker容器中即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip&#x3D;true</span><br></pre></td></tr></table></figure>
<p>这里我利用IDEA的maven 来打包</p>
<p>运行java容器，部署并运行JAR文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name j1 -v j1:&#x2F;home&#x2F;soft --net&#x3D;host java</span><br><span class="line">nohup java -jar &#x2F;home&#x2F;soft&#x2F;renren-fast.jar</span><br></pre></td></tr></table></figure>
        </div></article>
      <nav class="pagination"><a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    <a class="next" href="/page/5/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zhutianpeng</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
