<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ztxpp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ztxpp&#39;s Blog">
<meta property="og:url" content="ztxpp.cc/page/3/index.html">
<meta property="og:site_name" content="Ztxpp&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhutianpeng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ztxpp&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ztxpp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="ztxpp.cc"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/31/JVM/" class="article-date">
  <time datetime="2019-08-31T14:08:06.000Z" itemprop="datePublished">2019-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/31/JVM/">JVM 常见知识点整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190831221516.png" alt="JVM小结1"><br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190831221628.png" alt="JVM小结2"><br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190831221715.png" alt="JVM小结3"><br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190831221746.png" alt="JVM小结4"></p>
<p>整图：<a target="_blank" rel="noopener" href="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190831220711.png">下载</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/08/31/JVM/" data-id="ckebizjw10005647kdyrc88y1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-financial-management" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/23/financial-management/" class="article-date">
  <time datetime="2019-05-23T01:56:23.000Z" itemprop="datePublished">2019-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/financial-management/">financial_management</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为理财小白的启蒙课，理财入门学习笔记。</p>
<h1 id="0-预备学习"><a href="#0-预备学习" class="headerlink" title="0.预备学习"></a>0.预备学习</h1><p>课程读物：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/Finance%20Management/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1.pdf">《小狗钱钱》</a></li>
<li><a target="_blank" rel="noopener" href="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/Finance%20Management/%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8.pdf">《穷爸爸富爸爸》</a></li>
</ul>
<h1 id="1-第一课-理财是人人都需要的底层能力"><a href="#1-第一课-理财是人人都需要的底层能力" class="headerlink" title="1.第一课: 理财是人人都需要的底层能力"></a>1.第一课: 理财是人人都需要的底层能力</h1><h2 id="1-通货膨胀："><a href="#1-通货膨胀：" class="headerlink" title="1. 通货膨胀："></a>1. 通货膨胀：</h2><ul>
<li><p>定义：指在货币流通条件下，因货币供给大于货币实际需求，也即现实购买力大于产出供给，导致货币贬值，而引起的一段时间内物价持续而普遍地上涨现象。其实质是社会总需求大于社会总供给 （求远大于供）。  </p>
</li>
<li><p>举例：</p>
<ul>
<li>我国大米价格90年代初 0.7元/斤， 现在7元/斤， 这是一系列通货膨胀的结果，但是由于经济本身也g奥苏增长，这种通胀是温和的。</li>
<li>委内瑞拉的津巴布维的通胀，就是恶性通胀。</li>
</ul>
</li>
<li><p>成因：（货币中性理论） P x Y = M x V   (P:总物价，Y：总产出； M：货币供给； V：货币流通速度)</p>
<ul>
<li>M增加：货币超发通货膨胀。 eg：货币恶意超发、外汇型通货膨胀、信用型通货膨胀、财政型通货膨胀。</li>
<li>Y减小：供给型通货膨胀。 eg:实物减少型（战争摧毁，石油危机）通货膨胀、出口型通货膨胀、结构型（产业发展不均衡）通货膨胀、进口型通货膨胀（商品过分依赖进口，进口国家发生通胀，影响本国）。</li>
<li>V增加：需求型通货膨胀。 解释：当其他因素不变，而人们对某商品的需求剧增，会引发货币流转次数的增加。eg：追赶型通货膨胀。</li>
</ul>
</li>
<li><p>影响：</p>
<ul>
<li>钱存银行，或者攥在手里：弊端为银行利息追不上通胀率</li>
<li>靠固定工资过日子：弊端为工资涨幅追不上通胀率</li>
</ul>
</li>
</ul>
<h2 id="2-理财利弊："><a href="#2-理财利弊：" class="headerlink" title="2. 理财利弊："></a>2. 理财利弊：</h2><ul>
<li><p>益处：</p>
<ul>
<li>跑赢通胀</li>
<li>带来被动收入</li>
</ul>
</li>
<li><p>理财误区：</p>
<ul>
<li>收入低不理财：理财!=投资， 理财包括了：收支规划、养老安排、子女教育、税收筹划等，是一种思维习惯和生活方式。</li>
<li>所有的钱全部去投资，错在把鸡蛋放在同一个篮子里。而应当参照普尔家庭象限图来合理分配收入。<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/Finance%20Management/1.%20%E6%99%AE%E5%B0%94%E5%AE%B6%E5%BA%AD%E8%B1%A1%E9%99%90%E5%9B%BE.png" alt="标准普尔家庭象限图"></li>
<li>不懂理财着急投资。应当先学习理论再上手，做到不懂不碰。 </li>
</ul>
</li>
</ul>
<h1 id="2-第二课：2张表搞定收入问题"><a href="#2-第二课：2张表搞定收入问题" class="headerlink" title="2.第二课：2张表搞定收入问题"></a>2.第二课：2张表搞定收入问题</h1><p>如何衡量自己能有多少钱用来理财，需要先搞清楚自己的资产状况。</p>
<h2 id="1-资产负债表"><a href="#1-资产负债表" class="headerlink" title="1. 资产负债表"></a>1. 资产负债表</h2><ul>
<li>公式：资产 = 负债 + 所有者权益</li>
<li>作用：定期盘点资产和负债情况，确定绝对值。</li>
</ul>
<h2 id="2-收入支出表"><a href="#2-收入支出表" class="headerlink" title="2. 收入支出表"></a>2. 收入支出表</h2><ul>
<li>作用： 记录收支情况，确定△值。</li>
</ul>
<h2 id="表单样例："><a href="#表单样例：" class="headerlink" title="表单样例："></a>表单样例：</h2><p><a target="_blank" rel="noopener" href="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/Finance%20Management/%E8%B5%84%E4%BA%A7%E8%B4%9F%E5%80%BA%E8%A1%A8%E3%80%81%E6%94%B6%E6%94%AF%E8%A1%A8.xlsx">资产负债表,收入支出表</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/05/23/financial-management/" data-id="ckebizjwi0013647kbog4h8zo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/financial/" rel="tag">financial</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-annotation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/19/annotation/" class="article-date">
  <time datetime="2019-05-19T10:30:02.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/19/annotation/">Java 注解 （Annotation）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>annotation: Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。下文为关于 annotation的学习笔记。</p>
</blockquote>
<h1 id="1-annotation的地位"><a href="#1-annotation的地位" class="headerlink" title="1. annotation的地位"></a>1. annotation的地位</h1><ul>
<li>annotation是一种类型，跟Class, Interface一个层面上的定义。</li>
<li>annotation在 rt.jar 中的 lang.annotation 中定义，其使用与 lang.reflect 紧密相关。</li>
</ul>
<h1 id="2-annotation的语法"><a href="#2-annotation的语法" class="headerlink" title="2. annotation的语法"></a>2. annotation的语法</h1><h2 id="2-1-理解："><a href="#2-1-理解：" class="headerlink" title="2.1 理解："></a>2.1 理解：</h2><ul>
<li>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。  </li>
<li>注解就是一种标签，一种盖章。可以给事物打上这种标签，使得事物具有某种属性。</li>
</ul>
<h2 id="2-2-定义："><a href="#2-2-定义：" class="headerlink" title="2.2 定义："></a>2.2 定义：</h2><p>注解通过 @interface关键字进行定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;&#125; <span class="comment">// 理解：创建了一张名字为 Login 的标签。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-元注解："><a href="#2-3-元注解：" class="headerlink" title="2.3 元注解："></a>2.3 元注解：</h2><ul>
<li>元注解是一种基本注解，能给注解加注解。</li>
<li>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保留期:当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</span></span><br><span class="line"><span class="comment">//分为：源码期，编译期，运行期：</span></span><br><span class="line"><span class="comment">//      SOURCE(源码阶段保留，编译时丢弃)，</span></span><br><span class="line"><span class="comment">//      CLASS(保留到编译期，不被加载到JVM)，</span></span><br><span class="line"><span class="comment">//      RUNTIME（保留到程序运行，它会被加载进入到 JVM 中，在程序运行时可以获取到）</span></span><br><span class="line"><span class="meta">@Retention()</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文档:作用是能够将注解中的元素包含到 Javadoc 中去。</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标: @Target 指定了注解运用的场景。</span></span><br><span class="line"><span class="comment">//分为： 注解，构造方法，属性，局部变量，方法，包，方法内参数，类：</span></span><br><span class="line"><span class="comment">//      ANNOTATION_TYPE: 可以给注解进行注解</span></span><br><span class="line"><span class="comment">//      CONSTRUCTOR ：给构造方法进行注解</span></span><br><span class="line"><span class="comment">//      FIELD ：给属性进行注解</span></span><br><span class="line"><span class="comment">//      LOCAL_VARIABLE： 给局部变量进行注解</span></span><br><span class="line"><span class="comment">//      METHOD ：给方法进行注解</span></span><br><span class="line"><span class="comment">//      PACKAGE ：给一个包进行注解</span></span><br><span class="line"><span class="comment">//      PARAMETER ：给方法内的参数进行注解</span></span><br><span class="line"><span class="comment">//      TYPE ：可以给一个类型进行注解，比如类、接口、枚举</span></span><br><span class="line"><span class="meta">@Target()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承, 超类被一个 “被 @Inherited注解过的注解 @testA” 注解，则子类也拥有这个注解 @testA。 </span></span><br><span class="line"><span class="meta">@Inherited()</span></span><br><span class="line">    <span class="comment">//eg：</span></span><br><span class="line">        <span class="meta">@Inherited</span></span><br><span class="line">        <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">        <span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; <span class="comment">// B也具有了 @Test 的注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可重复, 同一个注解可以用来加在同一个事物上多次</span></span><br><span class="line"><span class="meta">@Repeatable()</span></span><br><span class="line">    <span class="comment">//eg：</span></span><br><span class="line">        <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">         Person[]  value();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line">        <span class="meta">@interface</span> Person&#123;</span><br><span class="line">        	String role <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Person(role=&quot;artist&quot;)</span></span><br><span class="line">        <span class="meta">@Person(role=&quot;coder&quot;)</span></span><br><span class="line">        <span class="meta">@Person(role=&quot;PM&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-注解的属性"><a href="#2-4-注解的属性" class="headerlink" title="2.4 注解的属性"></a>2.4 注解的属性</h2></li>
<li>在注解中定义属性时它的类型必须是 8 种基本数据类型（char,int,short,long,boolean,byte,double,float）外加String、 class、 enum、接口、注解及它们的数组</li>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> &quot;Hi&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(id=3,msg=&quot;hello annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-5-Java-预置的注解"><a href="#2-5-Java-预置的注解" class="headerlink" title="2.5 Java 预置的注解"></a>2.5 Java 预置的注解</h2><ul>
<li>@Deprecated ：过时的元素</li>
<li>@Override: override</li>
<li>@SuppressWarnings:关闭不当的编译器警告。</li>
<li>@SafeVarargs：参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作。</li>
<li>@FunctionalInterface: 函数式编程接口</li>
</ul>
<h2 id="2-6-注解的提取-反射"><a href="#2-6-注解的提取-反射" class="headerlink" title="2.6 注解的提取 - 反射"></a>2.6 注解的提取 - 反射</h2><p>注解是元素的一个标签，想要获取注解，先获取元素。所以获取 class, method, field等就需要用到 reflect的方法。<br>基本的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>获取到annotation后，再获取相应的属性即可。</p>
<h1 id="3-annotation的应用"><a href="#3-annotation的应用" class="headerlink" title="3. annotation的应用"></a>3. annotation的应用</h1><p>annotation的应用或者作用不能一概而论，分类讨论，注解的分类如下：  </p>
<h2 id="3-1-按照运行机制划分："><a href="#3-1-按照运行机制划分：" class="headerlink" title="3.1 按照运行机制划分："></a>3.1 按照运行机制划分：</h2><ol>
<li><p>源码注解:<br> 提供信息给编译器，编译器可以利用注解来探测错误和警告信息</p>
</li>
<li><p>编译时注解：<br> 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。<br> eg：@Override、@Deprecated、@SuppressWarnings</p>
</li>
<li><p>运行时注解：<br> 某些注解可以在程序运行的时候接受代码的提取<br> eg：Spring的 @Autowired自动注入</p>
</li>
</ol>
<h2 id="3-2-按照来源划分："><a href="#3-2-按照来源划分：" class="headerlink" title="3.2 按照来源划分："></a>3.2 按照来源划分：</h2><ol>
<li><p>来自JDK的注解<br>@Retention、@Documented、@Target、@Inherited、@Repeatable</p>
</li>
<li><p>来自第三方的注解<br>举例：<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E9%97%B2%E6%95%A3/%E6%B3%A8%E8%A7%A3.png" alt="来自第三方的注解">  </p>
</li>
<li><p>自定义注解  </p>
</li>
</ol>
<h2 id="3-3-元注解："><a href="#3-3-元注解：" class="headerlink" title="3.3 元注解："></a>3.3 元注解：</h2><p>注解的注解。</p>
<h1 id="4-自定义注解实战"><a href="#4-自定义注解实战" class="headerlink" title="4. 自定义注解实战"></a>4. 自定义注解实战</h1><h2 id="4-1-利用自定义注解-标记-“登陆后方法”，并结合拦截器检查"><a href="#4-1-利用自定义注解-标记-“登陆后方法”，并结合拦截器检查" class="headerlink" title="4.1 利用自定义注解 标记 “登陆后方法”，并结合拦截器检查"></a>4.1 利用自定义注解 标记 “登陆后方法”，并结合拦截器检查</h2><p>定义@Login注解：<br>Login</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录效验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合Interceptor设置登录状态判断：<br>AuthorizationInterceptor.java  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限(Token)验证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_KEY = <span class="string">&quot;userId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 判断该方法是否需要进行登录状态的校验。</span></span><br><span class="line">        Login annotation;</span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            annotation = ((HandlerMethod) handler).getMethodAnnotation(Login.class);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//不需要登录状态校验，直接返回。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(annotation == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//不需要登录状态校验，直接返回。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的登录校验的业务逻辑不需要关注。</span></span><br><span class="line">        <span class="comment">//从header中获取token</span></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//如果header中不存在token，则从参数中获取token</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            token = request.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//token为空</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            RRException exception = <span class="keyword">new</span> RRException(<span class="string">&quot;token不能为空&quot;</span>);</span><br><span class="line">            exception.setCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询token信息</span></span><br><span class="line">        TokenEntity tokenEntity = tokenService.queryByToken(token);</span><br><span class="line">        <span class="keyword">if</span>(tokenEntity == <span class="keyword">null</span> || tokenEntity.getExpireTime().getTime() &lt; System.currentTimeMillis())&#123;</span><br><span class="line">            RRException exception = <span class="keyword">new</span> RRException(<span class="string">&quot;token失效，请重新刷新token&quot;</span>);</span><br><span class="line">            exception.setCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置userId到request里，后续根据userId，获取用户信息</span></span><br><span class="line">        request.setAttribute(USER_KEY, tokenEntity.getUserId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体使用：<br>EvaluationRealtimeController.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ztp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-5-29</span></span><br><span class="line"><span class="comment"> * 列出一段时间内的，某个用户的评估结果，list形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Login</span> <span class="comment">//这句话表示下面的方法，需要进过登录状态判断，必须是登录后才可以访问到的方法</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/list/duringTime/&#123;startTime&#125;/&#123;endTime&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;列出一段时间内的，某个用户的评估结果&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">listDuringTime</span><span class="params">(<span class="meta">@ApiParam(value = &quot;YYYY-MM-DD HH:mm:SS&quot;, required = true)</span><span class="meta">@PathVariable(&quot;startTime&quot;)</span> String startTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@ApiParam(value = &quot;YYYY-MM-DD HH:mm:SS&quot;, required = true)</span><span class="meta">@PathVariable(&quot;endTime&quot;)</span> String endTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@ApiIgnore</span> <span class="meta">@RequestAttribute(&quot;userId&quot;)</span> Long userId)</span></span>&#123;</span><br><span class="line">    List&lt;TrainRealtimeInstanceEntity&gt; list =evaluationRealtimeService.queryDuringTimeAndUserId(userId,startTime,endTime);</span><br><span class="line">    <span class="keyword">return</span> R.ok().put(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-2-利用自定义注解实现-ORM-映射"><a href="#4-2-利用自定义注解实现-ORM-映射" class="headerlink" title="4.2 利用自定义注解实现 ORM 映射"></a>4.2 利用自定义注解实现 ORM 映射</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/05/19/annotation/" data-id="ckebizjw9000j647kht827vxn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SCM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/SCM/" class="article-date">
  <time datetime="2019-05-16T08:58:47.000Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/SCM/">供应链 - 库存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>除了约束理论和Heide象征论之外，库存管理、采购管理、风险管理已经逐步成为支撑供应链管理发展的理论基 础。 本文主要总结库存管理的基本概念，以辅助理解库存管理中的业务逻辑和流程。<br>参考资料：  </p>
<ul>
<li>东南大学物流管理工程系-供应链与物流管理  </li>
<li>[美] 大卫·辛奇-厉维 《供应链设计与管理》</li>
</ul>
</blockquote>
<h1 id="1-供应链-基本概念"><a href="#1-供应链-基本概念" class="headerlink" title="1. 供应链 基本概念"></a>1. 供应链 基本概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul>
<li><p>供应链的定义：生产及流通过程中，涉及将产品更新换代或服务提供给最终用户的上游或下游企业，所形成的网络结构。</p>
</li>
<li><p>供应链管理的定义：</p>
<ul>
<li>中国的定义： 利用计算机网络技术全面规划供应链中的商流、物流、信息流、资金流等，并进行计划、组织、协调与控制等。</li>
<li>GSCF的定义： 供应链管理就是指对整个供应链系统进行计划、协调、操作、控制和优化的各种活动和过程，其目标是要将消费者所需的正确的产品、能够在正确的时间、按照正确的数量、正确的质量、正确的状态、正确的成本，送到正确的地点（5R/7R）。</li>
</ul>
</li>
</ul>
<h2 id="1-2-供应链管理的流程"><a href="#1-2-供应链管理的流程" class="headerlink" title="1.2 供应链管理的流程"></a>1.2 供应链管理的流程</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%89%A9%E6%B5%81%E7%AE%A1%E7%90%86/%E4%BE%9B%E5%BA%94%E9%93%BE%E7%AE%A1%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="物流管理的流程"></p>
<h2 id="1-3-供应链的理论基础"><a href="#1-3-供应链的理论基础" class="headerlink" title="1.3 供应链的理论基础"></a>1.3 供应链的理论基础</h2><ul>
<li>约束理论和Heide象征论</li>
<li>库存管理</li>
<li>采购管理</li>
<li>风险管理</li>
</ul>
<h1 id="2-库存管理-库存管理基本知识"><a href="#2-库存管理-库存管理基本知识" class="headerlink" title="2. 库存管理 - 库存管理基本知识"></a>2. 库存管理 - 库存管理基本知识</h1><h2 id="2-1-库存的相关概念："><a href="#2-1-库存的相关概念：" class="headerlink" title="2.1 库存的相关概念："></a>2.1 库存的相关概念：</h2><ol>
<li>定义</li>
</ol>
<ul>
<li>狭义：指的是在仓库中处于暂时停滞状态的物资</li>
<li>广义： 库存表示用于将来目的、暂时处于闲置状态的资源</li>
</ul>
<ol start="2">
<li>企业进行仓储主要有以下四个基本原因：</li>
</ol>
<ul>
<li>降低运输－生产成本</li>
<li>协调供应和需求</li>
<li>辅助生产</li>
<li>辅助市场销售</li>
</ul>
<ol start="3">
<li>库存的利与弊 - “库存是一个必要的恶魔”：</li>
</ol>
<ul>
<li><p>利：</p>
<ul>
<li>客户资源平衡（缩短交货期）</li>
<li>生产资源平衡（稳定生产需求）</li>
<li>运输资源平衡</li>
</ul>
</li>
<li><p>弊：</p>
<ul>
<li>占用大量资金</li>
<li>增加企业费用支出</li>
<li>腐烂变质的损失</li>
<li>麻痹管理人员的思想（库存具有缓冲作用，“冰山效应”，能掩盖企业中出现的一些问题）</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>现代“零库存”管理 的含义：（行程良性循环）<br> 降低库存→暴露生产系统中的问题→改进生产系统→更完善的生产系统→进一步降低库存</p>
</li>
<li><p>库存的分类</p>
</li>
</ol>
<ul>
<li>在途库存：处于流通中（运输途中）</li>
<li>“投机库存”： 对于某些原材料，有时是为了价格投机，有时是为了满足运作需要。</li>
<li>周期性库存：为了满足连续补货期间的平均需求而储存的必要存货，很大程度上取决于生产批量的规模、经济- 运输批量、存储空间的限制、补货提前期、价格－数量折扣计划和库存持有成本等因素。</li>
<li>额外库存/安全库存：为防范需求和补货提前期的变动而建立库存。</li>
</ul>
<ol start="6">
<li>库存的种类：</li>
</ol>
<ul>
<li>原材料和外购件库存</li>
<li>半成品库存及在制品（work in progress）库存</li>
<li>成品（Finished-goods）库存</li>
<li>备品、备件、工具、工艺装备库存</li>
<li>在途库存（Goods-in-transit to warehouses or customers）</li>
</ul>
<h2 id="2-2-库存控制的因素和指标"><a href="#2-2-库存控制的因素和指标" class="headerlink" title="2.2 库存控制的因素和指标"></a>2.2 库存控制的因素和指标</h2><ol>
<li>库存管理的衡量指标：</li>
</ol>
<ul>
<li>平均库存值</li>
<li>可供应时间</li>
<li>库存周转率</li>
</ul>
<ol start="2">
<li><p>库存产生的原因：</p>
<p> 供求关系的失调。</p>
<p> 所以需求的预测比较重要，普通产品的需求模式的分类：</p>
<ul>
<li>终止性需求(eg：飞机零件)</li>
<li>持久性需求（eg：罐头汤）</li>
<li>起伏性需求（eg：建筑设备）</li>
<li>季节性需求（eg：室内空调）</li>
</ul>
</li>
</ol>
<h2 id="2-3-库存控制系统"><a href="#2-3-库存控制系统" class="headerlink" title="2.3 库存控制系统"></a>2.3 库存控制系统</h2><ol>
<li>需求特性：</li>
</ol>
<ul>
<li>确定性需求: 定性定量的</li>
<li>随机性需求: “量”、”时间“不知，但其概率分布函数可知</li>
<li>不确定性需求：“量”、“时间”均无法确定</li>
</ul>
<ol start="2">
<li>供应特征：</li>
</ol>
<ul>
<li>订货提前期</li>
<li>起订点</li>
<li>采购价格和折扣</li>
</ul>
<ol start="3">
<li>进货方式</li>
</ol>
<ul>
<li><p>定量订货方式：<br>  订货批量每次不变，订货间隔期随需求量的变化而变化<br>  例如：经济批量模型</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%89%A9%E6%B5%81%E7%AE%A1%E7%90%86/%E7%BB%8F%E6%B5%8E%E6%89%B9%E9%87%8F%E6%A8%A1%E5%9E%8B.png" alt="经济批量模型"><br>  <img src="https://wiki.mbalib.com/w/images/9/9d/%E7%BB%8F%E6%B5%8E%E8%AE%A2%E8%B4%A7%E6%89%B9%E9%87%8F1.jpg" alt="经济批量模型">   </p>
</li>
<li><p>定期订货方式：<br>  订货间隔期固定不变，每次订货量随需求量的变化而变化<br>  例如：<br>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%89%A9%E6%B5%81%E7%AE%A1%E7%90%86/%E5%AE%9A%E6%9C%9F%E5%AD%98%E5%82%A8.png" alt="定期存储"></p>
</li>
</ul>
<ol start="4">
<li>库存的成本构成</li>
</ol>
<ul>
<li><p>订货成本 （Ordering Costs，$C_O$）</p>
</li>
<li><p>库存持有成本 （Holding Costs，$C_H$）</p>
<p>  过时成本； 损坏/报废； 税； 保险； 存储； 资金（机会成本）。</p>
</li>
<li><p>缺货成本 （Shortage loss Costs，$C_S$）</p>
</li>
</ul>
<h2 id="2-4-库存控制方法"><a href="#2-4-库存控制方法" class="headerlink" title="2.4 库存控制方法"></a>2.4 库存控制方法</h2><p>需要解决的问题：需求预测和订货批量的计算！</p>
<ol>
<li><p>60天订货法则 （“凭常识的”库存控制方法）<br> 每次重新订货时，订足够数量的物料使得现有库存与已订货量的总数等于过去60天的销售量。</p>
</li>
<li><p>ABC分类法 （类似于“二八定律”）</p>
</li>
</ol>
<ul>
<li>分类标准：<ul>
<li>A类物资占全部库存物资的10%左右，而其需求量却占全部物资总需求量的70%左右；</li>
<li>B类物资种类数占20%左右，而其需求量大致也为总需求量的20%左右；</li>
<li>C类物资种类数占70%左右，而其需求量只占总需求量的10%左右。</li>
</ul>
</li>
<li>原则：<br>  将管理的重点放在重要的库存物资上，进行分类管理和控制。</li>
</ul>
<ol start="3">
<li>订货点法</li>
</ol>
<ul>
<li><p>定义<br>  在需求量和运作周期已知的情况下，基本订货点或称再订货点可以采用如下公式计算：</p>
<p>  $$R＝D∗T$$</p>
<ul>
<li><p>R—用单位数表示的再订货点</p>
</li>
<li><p>D—平均日需求量</p>
</li>
<li><p>T—平均运营周期。</p>
<p>当需求量或完成周期存在不确定因素时，就必须使用库存缓冲来补偿不确定因素。在不确定条件下，再订货点公式变 为：</p>
<p>$$R＝D∗T＋SS$$</p>
</li>
<li><p>SS—为用单位数表示的安全库存或缓冲库存。</p>
</li>
<li><p>四种库存策略</p>
<ul>
<li>（Q,R）策略</li>
<li>（R,S）策略</li>
<li>（t,S）策略</li>
<li>（t,R,S）策略</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/05/16/SCM/" data-id="ckebizjw6000d647khvdde9ss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BE%9B%E5%BA%94%E9%93%BE/" rel="tag">供应链</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/06/MQ/" class="article-date">
  <time datetime="2019-05-06T08:58:47.000Z" itemprop="datePublished">2019-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/MQ/">以activemq为例的消息中间件浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ol>
<li>传统的前端向后端发起http request,后端回复http response的方式，在服务器端主动推送模型中不再适用。</li>
<li>传统的单体结构的项目升级为多模块的项目之后，模块与模块之间的通信方式有所改变。<br>上述两个问题都可以用“消息中间件”的思想来解决，本文做一个基础知识的学习。并且就activemq进行一些分析和总结。</li>
</ol>
</blockquote>
<h1 id="1-web项目中-server-向-client推送消息的方式调研"><a href="#1-web项目中-server-向-client推送消息的方式调研" class="headerlink" title="1. web项目中 server 向 client推送消息的方式调研"></a>1. web项目中 server 向 client推送消息的方式调研</h1><p>要实现 服务器端推送，以及异步处理，需要使用基于mqtt的消息中间件，或者使用websocket来进行</p>
<h1 id="2-消息队列的模型分类（JMS规范支持的消息模型）"><a href="#2-消息队列的模型分类（JMS规范支持的消息模型）" class="headerlink" title="2. 消息队列的模型分类（JMS规范支持的消息模型）"></a>2. 消息队列的模型分类（JMS规范支持的消息模型）</h1><h2 id="2-1-：-点对点（point-to-point，-queue）-vs-发布-订阅（publish-subscribe，topic）"><a href="#2-1-：-点对点（point-to-point，-queue）-vs-发布-订阅（publish-subscribe，topic）" class="headerlink" title="2.1 ： 点对点（point to point， queue） vs 发布/订阅（publish/subscribe，topic）"></a>2.1 ： 点对点（point to point， queue） vs 发布/订阅（publish/subscribe，topic）</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E9%97%B2%E6%95%A3/MQ_1.bmp" alt="JMS规范支持的消息模型"></p>
<p>点对点模型：queue，只能消费一次。</p>
<ul>
<li>定义：消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再有存储，Queue支持存在多个消费者，但是一个消息只能被消费一次。</li>
<li>特点：queue中不存储已被消费一次的消息。</li>
</ul>
<p>发布/订阅：Topic，可以重复消费：</p>
<ul>
<li>定义：消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。</li>
<li>特点1：发布到topic的消息会被所有订阅者消费。</li>
<li>特点2：支持“订阅组”的发布订阅模式。当发布消息量过大时，采用多订阅节点组成一个订阅组来 负载均衡地分组订阅，可以简单地将消费能力进行线性扩展。</li>
</ul>
<h2 id="2-2-推-vs-拉"><a href="#2-2-推-vs-拉" class="headerlink" title="2.2 推 vs 拉"></a>2.2 推 vs 拉</h2><p>Push方式：由消息中间件主动地将消息推送给消费者；</p>
<ul>
<li>优点：尽可能快地将消息发送给消费者</li>
<li>缺点：如果消费者的处理消息的能力很弱(一条消息需要很长的时间处理)，而消息中间件不断地向消费者Push消息，消费者的缓冲区可能会溢出。</li>
</ul>
<p>Pull方式：由消费者主动向消息中间件拉取消息。</p>
<ul>
<li>特点： 会增加消息的延迟，即消息到达消费者的时间有点长</li>
</ul>
<p>举例：</p>
<ul>
<li>ActiveMQ： 包含“推”，“拉”两种模型，较为复杂，后面详细介绍。</li>
<li>RabbitMQ： 既支持内存队列也支持持久化队列，消费端为“推”模型，消费状态和订阅关系由服务端负责维护，消息消费完后立即删除，不保留历史消息。</li>
<li>Kafka: 只支持消息持久化，消费端为“拉”模型，消费状态和订阅关系由客户端端负责维护，消息消费完后不会立即删除，会保留历史消息。</li>
</ul>
<h1 id="3-activemq浅析"><a href="#3-activemq浅析" class="headerlink" title="3. activemq浅析"></a>3. activemq浅析</h1><h2 id="3-1-名词介绍"><a href="#3-1-名词介绍" class="headerlink" title="3.1 名词介绍"></a>3.1 名词介绍</h2><p>ActiveMQ 是一个 MOM，具体来说是一个实现了 JMS 规范的系统间远程通信的消息代理。</p>
<ul>
<li>MOM:<ul>
<li>面向消息中间件(Message-oriented middleware)。</li>
<li>以分布式应用或系统中的异步、松耦合、可靠、可扩展和安全通信的一类软件。</li>
<li>MOM 的总体思想是它作为消息发送器和消息接收器之间的消息中介,这种中介提供了一个全新水平的松耦合。</li>
</ul>
</li>
<li>JMS：<ul>
<li>Java 消息服务(Java Message Service)。java平台上有关面向 MOM 的技术规范。</li>
<li>旨在通过提供标准的产生、发送、接收和处理消息的 API 简化企业应用的开发，类似于 JDBC 和关系型数据库通信方式的抽象。</li>
</ul>
</li>
</ul>
<p>消息队列的另外四个基本概念：分别是Provider，Domains，Connection factory，Destination。</p>
<ul>
<li>Provider：纯 Java 语言编写的 JMS 接口实现（eg: ActiveMQ）</li>
<li>Domains：消息传递方式，包括点对点（P2P）、发布/订阅（Pub/Sub）两种</li>
<li>Connection factory：客户端使用连接工厂来创建与 JMS provider 的连接</li>
<li>Destination：消息被寻址、发送以及接收的对象</li>
</ul>
<h2 id="3-2-Activemq使用的通用步骤"><a href="#3-2-Activemq使用的通用步骤" class="headerlink" title="3.2 Activemq使用的通用步骤"></a>3.2 Activemq使用的通用步骤</h2><ul>
<li>获取连接工厂</li>
<li>使用连接工厂创建连接</li>
<li>启动连接</li>
<li>从连接创建会话</li>
<li>获取 Destination</li>
<li>创建 Producer</li>
<li>创建 Consumer<ul>
<li>创建 Consumer</li>
<li>注册消息监听器（可选）</li>
</ul>
</li>
<li>发送或接收 message</li>
<li>关闭资源（connection, session, producer, consumer 等)</li>
</ul>
<h2 id="3-3-Activemq的-“P2P”与“Pub-Sub”的比较"><a href="#3-3-Activemq的-“P2P”与“Pub-Sub”的比较" class="headerlink" title="3.3 Activemq的 “P2P”与“Pub/Sub”的比较"></a>3.3 Activemq的 “P2P”与“Pub/Sub”的比较</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E9%97%B2%E6%95%A3/MQ.png" alt="activemq的 “P2P”与“Pub/Sub”的比较"></p>
<p>解释：Topic和queue的区别：</p>
<ul>
<li><p>对于消费者延迟启动，是否还有消息保留的问题： （本质上是消息发送的方式）</p>
<ul>
<li>Pub/Sub（topic）： 以 广播 的形式，通知所有在线监听的客户端有新的消息，没有监听的客户端将收不到消息；</li>
<li>P2P（queue）：则是以点对点的形式通知多个处于监听状态的客户端中的一个</li>
</ul>
</li>
<li><p>对于Broker重启时消息是否保留的问题： （本质上是持久化问题）</p>
<ul>
<li>P2P:<ul>
<li>当DeliveryMode设置为NON_PERSISTENCE时，消息被保存在内存中,broker重启即消息丢失；</li>
<li>而当DeliveryMode设置为PERSISTENCE时，消息保存在broker的相应的文件或者数据库中。broker重启不会导致消息丢失，只有P2P中消息被Consumer消费后才从broker中删除。</li>
</ul>
</li>
<li>Pub/Sub模式：<ul>
<li>当DeliveryMode设置为PERSISTENCE，且有持久订阅者(Durable Subscribers)时，Broker重启后，消息会保留。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-Activemq的-“推与拉”"><a href="#3-4-Activemq的-“推与拉”" class="headerlink" title="3.4 Activemq的 “推与拉”"></a>3.4 Activemq的 “推与拉”</h2><h3 id="3-4-1-ActiveMQ消息传送机制"><a href="#3-4-1-ActiveMQ消息传送机制" class="headerlink" title="3.4.1 ActiveMQ消息传送机制"></a>3.4.1 ActiveMQ消息传送机制</h3><p>prefetch limit:<br>由来：  </p>
<ul>
<li>生产者给消费者推送消息，消费者来不及消费，会将消息缓存在 缓冲区中，缓冲区可能有溢出的风险。prefetch limit 规定了一次可以向消费者Push(推送)多少条消息。当生产者发送的消息累计达到prefetch limit，但是消费者没有回复ack时，消息中间件将不再推送消息。</li>
</ul>
<p>怎么取值：  </p>
<ul>
<li>大于0: 是push的方式，允许消息的堆积</li>
<li>等于1：消费者收到一条消息，如果没有处理完，回复一个ack给中间件，就没法继续推送。适用于消息的数很少(生产者生产消息的速率不快)，但是每条消息 消费者需要很长的时间处理的情况。</li>
<li>等于0：是pull的方式了。</li>
</ul>
<h3 id="3-4-2-ActiveMQ的ack确认机制"><a href="#3-4-2-ActiveMQ的ack确认机制" class="headerlink" title="3.4.2 ActiveMQ的ack确认机制"></a>3.4.2 ActiveMQ的ack确认机制</h3><p>optimizeACK:<br>由来：  </p>
<ul>
<li>可优化的ACK”，这是ActiveMQ对于consumer在消息消费时，对消息ACK的优化选项，也是consumer端最重要的优化参数之一。</li>
<li>只有开启了optimizeAcknowledge=true,后面的optimizeAcknowledgeTimeOut，prefetchSize，redelivery才有意义。</li>
</ul>
<p>作用：</p>
<ul>
<li>通过optimizeACK和prefetch配合，可以达成高效的消息消费模型：批量获取消息，并“延迟”确认(ACK)</li>
</ul>
<h3 id="3-4-3-通过prefetch与optimizeACK-实现高效消息消费模型"><a href="#3-4-3-通过prefetch与optimizeACK-实现高效消息消费模型" class="headerlink" title="3.4.3 通过prefetch与optimizeACK 实现高效消息消费模型"></a>3.4.3 通过prefetch与optimizeACK 实现高效消息消费模型</h3><p>上文看到：prefetch优化了消息传送的性能，optimizeACK优化了消息确认的性能。现在进行适用的场景分析：</p>
<ul>
<li><p>（consumer消费速率 &gt; producer生产速率） &amp;&amp; 消息的数量也很大：<br>  使用optimizeACK + prefetch的消费模型可以大大提升consumer的性能。</p>
</li>
<li><p>consumer的消费速度慢 &amp;&amp; 消息的数量也很大:<br>  prefetchSize设置过大反而不利于consumer端的负载均衡。应当使用较小的prefetch，同时关闭optimizeACK，可以让消息在多个consumer间“负载均衡”(即均匀的发送给每个consumer)</p>
</li>
<li><p>consumer的消费速度 &gt;&gt; producer的生产速度 &amp;&amp; 部署了多个consumer：<br>  建议开启optimizeACK，但是需要设置的prefetchSize不能过大；这样可以保证每个consumer都能有”活干”，否则将会出现一个consumer非常忙碌，但是其他consumer几乎收不到消息</p>
</li>
<li><p>消息很重要，不愿意接受redelivery的消息:<br>  optimizeACK=false，prefetchSize=1，解释：当optimizeACK=true时，存在这种风险（当consumer收到消息，在延迟ack的时间内，发生了故障，则其他consumer可能会受到redelivery的消息）。所以不要延迟发送ack。而prefetchSize=1则是确保消息确认收到后，再继续推送下一条消息。</p>
</li>
</ul>
<h3 id="3-4-4-代码中如何使用-“推-拉”-“同步调用”和“异步调用”的比较"><a href="#3-4-4-代码中如何使用-“推-拉”-“同步调用”和“异步调用”的比较" class="headerlink" title="3.4.4 代码中如何使用 “推/拉” - “同步调用”和“异步调用”的比较"></a>3.4.4 代码中如何使用 “推/拉” - “同步调用”和“异步调用”的比较</h3><p>同步调用：</p>
<ul>
<li>语法： ActiveMQMessageConsumer的receive()方法。</li>
<li>prefetch limit取值：<ul>
<li>大于0：push</li>
<li>等于0：pull</li>
</ul>
</li>
</ul>
<p>异步调用：</p>
<ul>
<li>语法： 消费者实现MessageListener接口，监听消息。</li>
<li>prefetch limit取值：只能大于0，因为是被动监听的模式：push。</li>
</ul>
<h2 id="3-5-ActiveMQ的持久化方式"><a href="#3-5-ActiveMQ的持久化方式" class="headerlink" title="3.5 ActiveMQ的持久化方式"></a>3.5 ActiveMQ的持久化方式</h2><h2 id="3-6-ActiveMQ的部署模式-向高可用进发"><a href="#3-6-ActiveMQ的部署模式-向高可用进发" class="headerlink" title="3.6 ActiveMQ的部署模式 (向高可用进发)"></a>3.6 ActiveMQ的部署模式 (向高可用进发)</h2><ol>
<li><p>单例模式</p>
</li>
<li><p>无共享主从模式</p>
</li>
<li><p>共享存储主从模式</p>
</li>
</ol>
<h2 id="3-7-ActiveMQ的网络连接"><a href="#3-7-ActiveMQ的网络连接" class="headerlink" title="3.7 ActiveMQ的网络连接"></a>3.7 ActiveMQ的网络连接</h2><hr>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/heyutao007/article/details/50131089">消息队列的两种模式</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/hapjin/p/5683648.html">ActiveMQ的推拉模型</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cyfonly/p/6380860.html">成小胖学习ActiveMQ·基础篇</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xyw_blog/article/details/9128219">ActiveMQ持久化方式</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xyw_blog/article/details/9128219">ActiveMQ消息传送机制以及ACK机制详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/05/06/MQ/" data-id="ckebizjw30008647k1iaqdbpg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-activemq/" rel="tag">中间件 - activemq</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dynamic-program" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/dynamic-program/" class="article-date">
  <time datetime="2019-04-23T08:58:47.000Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/23/dynamic-program/">动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><p>把DP看作是数列，有3个关键因素，2种求解思路，3种实现方式，3个难点</p>
<h2 id="3个关键因素："><a href="#3个关键因素：" class="headerlink" title="3个关键因素："></a>3个关键因素：</h2><ul>
<li>最优子结构：最终成功的条件的子集，通常有几种情况组成，或是求和，或是求max</li>
<li>边界 ：初始条件，不要遗漏</li>
<li>状态转移公式 ：递推公式</li>
</ul>
<h2 id="2种求解思路："><a href="#2种求解思路：" class="headerlink" title="2种求解思路："></a>2种求解思路：</h2><ul>
<li>top-down： 递归，从A(n),A(n-1)往下求值</li>
<li>bottom-up： 循环，从A(1),A(2)…往上求值</li>
</ul>
<h2 id="3种实现的方式："><a href="#3种实现的方式：" class="headerlink" title="3种实现的方式："></a>3种实现的方式：</h2><p>具体的实现方式有三种，时间复杂度要看具体情况而论（不一定数学的方式就最快），一般采用 “简单递归 + 备忘录算法” ：</p>
<ul>
<li>top-down<ul>
<li>简单递归 ： 时间复杂度是指数级，底数要看最优子结构有几项</li>
<li>简单递归 + 备忘录算法 ： 时间复杂度和空间复杂度相同，为HashMap中的key的数量</li>
</ul>
</li>
<li>bottom-up<ul>
<li>循环求解 ： 时间复杂度为 O(N M …) 其中 N,M 均为维度上面的衡量指标</li>
</ul>
</li>
</ul>
<p><code>从前往后用循环，从后往前用递归。</code></p>
<h2 id="3个难点："><a href="#3个难点：" class="headerlink" title="3个难点："></a>3个难点：</h2><ul>
<li>知道这个题目要用动态规划</li>
<li>最优子结构不好想</li>
<li>边界条件容易 遗漏情况</li>
</ul>
<h1 id="例题集"><a href="#例题集" class="headerlink" title="例题集"></a>例题集</h1><h2 id="1-跳台阶："><a href="#1-跳台阶：" class="headerlink" title="1. 跳台阶："></a>1. 跳台阶：</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/307633?noteType=0">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</a></p>
<p>简单递归： 时间复杂度O（2^N）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="comment">//求递推公式是最终目标（递归），思考方式有两种：bottom up, top down.</span></span><br><span class="line"><span class="comment">//bottom up：走上第三级台阶的种数等于走上第一级台阶+第二级台阶 f(3)=f(2)+f(1);</span></span><br><span class="line"><span class="comment">//top down: 走完全部台阶种数= 走完倒数第一级+走完倒数第二级:  f(n)=f(n-1)+f(n-2); </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单递归+备忘录算法： 时间复杂度 O(n)， 空间复杂度 O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target, HashMap&lt;Integer,Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(target))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> value = JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">            map.put(target,value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数学法: 时间复杂度O(n), 空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> a=<span class="number">1</span>; <span class="keyword">int</span> b=<span class="number">2</span>; <span class="keyword">int</span> temp =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           temp=a+b;</span><br><span class="line">           a=b;</span><br><span class="line">           b=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-变态跳台阶"><a href="#2-变态跳台阶" class="headerlink" title="2.变态跳台阶"></a>2.变态跳台阶</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/profile/1923750/note/detail/309821?noteType=0">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</a></p>
<p>数学法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"><span class="comment">//思路：动态规划</span></span><br><span class="line"><span class="comment">//递推公式： f(n)= f(n-1)+ f(n-2)+f(n-3)+... +f(1)+f(0), 千万不要漏掉 f(0),以后还是建议用buttom up的思路</span></span><br><span class="line"><span class="comment">//递推公式2：f(n)=2f(n-1)</span></span><br><span class="line"><span class="comment">//通项公式： f(n) = Math.pow(2,n-1);</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-挖金矿"><a href="#3-挖金矿" class="headerlink" title="3. 挖金矿"></a>3. 挖金矿</h2><p>有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金数目。</p>
<p>参见： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg">程序员小灰漫画：什么是动态规划？（整合版）</a></p>
<p>简单递归：时间复杂度 O(2^n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人数:w    金矿:n    G[]:金矿中金子数目     P[]:挖矿需要的人数</span></span><br><span class="line"><span class="comment">//简单递归, 时间复杂度O(2^n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">goldDigger1</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> n, <span class="keyword">int</span>[] G, <span class="keyword">int</span>[] P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span> &amp;&amp; w&lt;P[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=P[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> G[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">1</span> &amp;&amp; w&lt;P[n-<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> goldDigger1(w, n-<span class="number">1</span>, G, P);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(goldDigger1(w,n-<span class="number">1</span>,G,P) , goldDigger1((w-P[n-<span class="number">1</span>]),n-<span class="number">1</span>,G,P)+G[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单递归 + 备忘录算法： 时间复杂度 O(key), 空间复杂度 O(key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//人数:w    金矿:n    G[]:金矿中金子数目     P[]:挖矿需要的人数</span></span><br><span class="line"><span class="comment">//简单递归 + 备忘录算法, 时间复杂度 O(key), 空间复杂度 O(key)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">goldDigger2</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> n, <span class="keyword">int</span>[] G, <span class="keyword">int</span>[] P, HashMap&lt;String,Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span> &amp;&amp; w&lt;P[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; w&gt;=P[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> G[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.containsKey(w+<span class="string">&quot;_&quot;</span>+n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(w+<span class="string">&quot;_&quot;</span>+n);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span> &amp;&amp; w&lt;P[n-<span class="number">1</span>])&#123;</span><br><span class="line">            value = goldDigger2(w, n-<span class="number">1</span>, G, P,map);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            value =  Math.max(goldDigger2(w,n-<span class="number">1</span>,G,P,map) , goldDigger2((w-P[n-<span class="number">1</span>]),n-<span class="number">1</span>,G,Pmap)+G[n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(w+<span class="string">&quot;_&quot;</span>+n,value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Decode-Ways"><a href="#4-Decode-Ways" class="headerlink" title="4. Decode Ways"></a>4. Decode Ways</h2><p>题目： <a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">leetcode91</a></p>
<p>解答1. 数学公式法：（这种写起来比较清爽，但是不太容易想到）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decodeWays</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//empty String only has 1 way to decode</span></span><br><span class="line">    dp[<span class="number">1</span>]=s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>? <span class="number">0</span>:<span class="number">1</span>; <span class="comment">//0:cannot decode; not 0: 1 way</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> first = Integer.valueOf(s.substring(i-<span class="number">1</span>,i));</span><br><span class="line">        <span class="keyword">int</span> second = Integer.valueOf(s.substring(i-<span class="number">2</span>,i));</span><br><span class="line">        <span class="keyword">if</span>(first&gt;=<span class="number">1</span> &amp;&amp; first&lt;=<span class="number">9</span>)&#123;dp[i]+=dp[i-<span class="number">1</span>];&#125;</span><br><span class="line">        <span class="keyword">if</span>(second&gt;=<span class="number">10</span> &amp;&amp; second&lt;=<span class="number">26</span>)&#123;dp[i]+=dp[i-<span class="number">2</span>];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解答2. 简单递归+备忘录算法 (很直观，但是不建议写)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decodeWay</span><span class="params">(String s, <span class="keyword">int</span> n, HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(n))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            value = s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            value =  s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.valueOf(s.substring(n-<span class="number">1</span>,n));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.valueOf(s.substring(n-<span class="number">2</span>,n));</span><br><span class="line">            <span class="keyword">if</span>(first&gt;=<span class="number">1</span> &amp;&amp; first&lt;=<span class="number">9</span> &amp;&amp; second&gt;=<span class="number">10</span> &amp;&amp; second&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">                value= decodeWay(s,n-<span class="number">1</span>,map)+decodeWay(s,n-<span class="number">2</span>,map);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(first==<span class="number">0</span> &amp;&amp; second&gt;=<span class="number">10</span> &amp;&amp; second&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">                value= decodeWay(s,n-<span class="number">2</span>,map);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(first&gt;=<span class="number">1</span> &amp;&amp; first&lt;=<span class="number">9</span> &amp;&amp; (second&lt;<span class="number">10</span> || second&gt;<span class="number">26</span>))&#123;</span><br><span class="line">                value= decodeWay(s,n-<span class="number">1</span>,map);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                value= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n,value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解答3： 递归写法( 这种写法比较直观，但是会有超时的风险)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       String s = sc.next();</span><br><span class="line">       System.out.print(find(s,s.length()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> first = Integer.valueOf(s.substring(i-<span class="number">1</span>,i));</span><br><span class="line">       <span class="keyword">int</span> twins = Integer.valueOf(s.substring(i-<span class="number">2</span>,i));</span><br><span class="line">       Boolean flag1=<span class="keyword">false</span>, flag2=<span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(first&gt;=<span class="number">1</span> &amp;&amp; first&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">           flag1=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(twins&gt;=<span class="number">10</span> &amp;&amp; twins&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">           flag2=<span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flag1&amp;&amp;flag2)&#123;</span><br><span class="line">           <span class="keyword">return</span> find(s,i-<span class="number">1</span>)+find(s,i-<span class="number">2</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">           <span class="keyword">return</span> find(s,i-<span class="number">1</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag2)&#123;</span><br><span class="line">           <span class="keyword">return</span> find(s,i-<span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-1-Jump-Game"><a href="#5-1-Jump-Game" class="headerlink" title="5.1. Jump Game"></a>5.1. Jump Game</h2><p>题目： <a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">LeetCode: 55.Jump Game</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//探索法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=reach;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reach&lt;=i+nums[i])    reach = i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(reach&gt;=nums.length-<span class="number">1</span>)    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Jump-Game2"><a href="#5-2-Jump-Game2" class="headerlink" title="5.2 Jump Game2"></a>5.2 Jump Game2</h2><p>题目 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">LeetCode: 45.Jump Game II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//探索法，O(n)，每一次都要走最远才算一步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>, nextreach=<span class="number">0</span>, step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=reach)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=reach;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nextreach&lt;=j+nums[j])&#123;</span><br><span class="line">                    nextreach=j+nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nextreach&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i=reach+<span class="number">1</span>;</span><br><span class="line">            reach=nextreach;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Minimum-Path-Sum"><a href="#6-Minimum-Path-Sum" class="headerlink" title="6. Minimum Path Sum"></a>6. Minimum Path Sum</h2><p>题目 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">LeetCode: 64. Minimum Path Sum</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，由于只能向下走或者向右走，所以每一个格子只能由上一个格子或者左一个格子得到，取较小即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            grid[<span class="number">0</span>][i]=grid[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i]; <span class="comment">//边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            grid[i][<span class="number">0</span>]=grid[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>]; <span class="comment">//边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                grid[i][j]=grid[i][j]+ Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]); <span class="comment">//最优子结构</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Triangle"><a href="#7-Triangle" class="headerlink" title="7. Triangle"></a>7. Triangle</h2><p>题目 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/">LeetCode: 120. Triangle</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个题目是典型的DP</span></span><br><span class="line"><span class="comment">// 最优子结构： dp[i][j] = min&#123;dp[i+1][j],dp[i+1][j+1]&#125;+triangle.get[i].get[j]; 其中dp[i][j]的含义是从[i][j]位置 到最底层的路径和。</span></span><br><span class="line"><span class="comment">// 注意边界条件涵盖在 循环当中了。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=triangle.size();</span><br><span class="line">        <span class="keyword">int</span> n=triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">                dp[i][j]= Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/04/23/dynamic-program/" data-id="ckebizjwh0010647kb5uv2qnr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">java - 动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-taobao_read" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/18/taobao_read/" class="article-date">
  <time datetime="2019-04-18T08:58:47.000Z" itemprop="datePublished">2019-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/taobao_read/">《淘宝技术这十年》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>《淘宝技术这十年》读书笔记</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本节用“光棍节的狂欢”这一案例表现出 普通用户在使用淘宝网时，系统中发生的事情，简述如下：</p>
<ol>
<li>访问一个网页的全过程：</li>
</ol>
<ul>
<li>解析主机名：从网址中解析到主机名称：如<a target="_blank" rel="noopener" href="http://www.example.com/hello.html%E5%88%99%E4%BC%9A%E5%B0%86%E4%B8%BB%E6%9C%BA%E5%90%8Dwww.example.com%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E3%80%82">http://www.example.com/hello.html则会将主机名www.example.com解析出来。</a></li>
<li>查找ip: DNS 层层上找，找到即返回IP地址</li>
<li>通过ARP协议找到主机的mac地址</li>
<li>与主机进行TCP连接，三次握手</li>
<li>发送与收取数据（浏览器与目的主机开始HTTP访问过程）</li>
<li>与目的主机断开TCP连接（四次挥手）</li>
</ul>
<p>对于淘宝而言：</p>
<ul>
<li>在dns解析的时候使用了LVS（linux Virtual ）做负载均衡找到比较空闲的那台主机的ip；</li>
<li>在请求资源返回html,css,js时,前端人员将这些资源存储在不同的服务器上，以绕过浏览器对同一个域名下并发加载资源数量的限制。</li>
<li>由于访问流量较大，淘宝网使用了CDN（content dilivery network）进行加速</li>
<li>卖家发布新的宝贝，如何更新到全国各地的CDN中？淘宝如何保存海量数据？</li>
<li>内容分发与同步技术</li>
<li>TFS(TaoBao File System) 实现分布式文件系统</li>
</ul>
<ol start="3">
<li>用户搜索;</li>
</ol>
<ul>
<li>分词</li>
<li>购物意图解析： 浏览型、查询型、对比型、确定型…</li>
</ul>
<ol start="4">
<li>购买记录及分析：</li>
</ol>
<ul>
<li>对每年数十亿交易的快照进行保存和快速调用： Tair(淘宝的分布式KV存储方案)</li>
<li>交易的访问日志记录： TimeTunnel(淘宝的快速、实时、同步传输数据的技术)</li>
<li>海量数据存储： 基于Hadoop的“云梯”</li>
<li>海量数据分析系统：ODPS(淘宝的数据系统)</li>
</ul>
<h1 id="第一章：-个人网站"><a href="#第一章：-个人网站" class="headerlink" title="第一章： 个人网站"></a>第一章： 个人网站</h1><ul>
<li><p>2003年4月7日：十人团队开始搭建淘宝网，技术选型为：LAMP(linux+Apache+Mysql+php)</p>
</li>
<li><p>系统架构：一个小网站 + 一个论坛社区</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/1.%E6%B7%98%E5%AE%9D%E6%9E%B6%E6%9E%84.png" alt="taobao 最早的系统架构"></p>
<p>  主要是对数据库的一个更改：1主2从，读写分离（提高效率），存储容量增加，备份使得更安全了。</p>
</li>
<li><p>DB细节：使用的MySQL4的MyISAM存储引擎，写数据的时候会锁表（不好）</p>
<p>  回顾一下MyISAM存储引擎的优点：</p>
<ul>
<li>全文索引</li>
<li>COUNT() 很快</li>
<li>大批的inserts 语句在MyISAM下会快一些</li>
<li>小型的应用或项目</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/04/18/taobao_read/" data-id="ckebizjwo001h647k98qf83aq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-taobao-read" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/18/taobao-read/" class="article-date">
  <time datetime="2019-04-18T08:58:47.000Z" itemprop="datePublished">2019-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/18/taobao-read/">《淘宝技术这十年》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>《淘宝技术这十年》读书笔记</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本节用“光棍节的狂欢”这一案例表现出 普通用户在使用淘宝网时，系统中发生的事情，简述如下：</p>
<ol>
<li>访问一个网页的全过程：</li>
</ol>
<ul>
<li>解析主机名：从网址中解析到主机名称：如<a target="_blank" rel="noopener" href="http://www.example.com/hello.html%E5%88%99%E4%BC%9A%E5%B0%86%E4%B8%BB%E6%9C%BA%E5%90%8Dwww.example.com%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E3%80%82">http://www.example.com/hello.html则会将主机名www.example.com解析出来。</a></li>
<li>查找ip: DNS 层层上找，找到即返回IP地址</li>
<li>通过ARP协议找到主机的mac地址</li>
<li>与主机进行TCP连接，三次握手</li>
<li>发送与收取数据（浏览器与目的主机开始HTTP访问过程）</li>
<li>与目的主机断开TCP连接（四次挥手）</li>
</ul>
<p>对于淘宝而言：</p>
<ul>
<li>在dns解析的时候使用了LVS（linux Virtual ）做负载均衡找到比较空闲的那台主机的ip；</li>
<li>在请求资源返回html,css,js时,前端人员将这些资源存储在不同的服务器上，以绕过浏览器对同一个域名下并发加载资源数量的限制。</li>
<li>由于访问流量较大，淘宝网使用了CDN（content dilivery network）进行加速</li>
<li>卖家发布新的宝贝，如何更新到全国各地的CDN中？淘宝如何保存海量数据？</li>
<li>内容分发与同步技术</li>
<li>TFS(TaoBao File System) 实现分布式文件系统</li>
</ul>
<ol start="3">
<li>用户搜索;</li>
</ol>
<ul>
<li>分词</li>
<li>购物意图解析： 浏览型、查询型、对比型、确定型…</li>
</ul>
<ol start="4">
<li>购买记录及分析：</li>
</ol>
<ul>
<li>对每年数十亿交易的快照进行保存和快速调用： Tair(淘宝的分布式KV存储方案)</li>
<li>交易的访问日志记录： TimeTunnel(淘宝的快速、实时、同步传输数据的技术)</li>
<li>海量数据存储： 基于Hadoop的“云梯”</li>
<li>海量数据分析系统：ODPS(淘宝的数据系统)</li>
</ul>
<h1 id="第一章：-个人网站"><a href="#第一章：-个人网站" class="headerlink" title="第一章： 个人网站"></a>第一章： 个人网站</h1><ul>
<li><p>2003年4月7日：十人团队开始搭建淘宝网，技术选型为：LAMP(linux+Apache+Mysql+php)</p>
</li>
<li><p>系统架构：一个小网站 + 一个论坛社区</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/1.%E6%B7%98%E5%AE%9D%E6%9E%B6%E6%9E%84.png" alt="taobao 最早的系统架构"></p>
<p>  主要是对数据库的一个更改：1主2从，读写分离（提高效率），存储容量增加，备份使得更安全了。</p>
</li>
<li><p>DB细节：使用的MySQL4的MyISAM存储引擎，写数据的时候会锁表（不好）</p>
<p>  回顾一下MyISAM存储引擎的优点：</p>
<ul>
<li>全文索引</li>
<li>COUNT() 很快</li>
<li>大批的inserts 语句在MyISAM下会快一些</li>
<li>小型的应用或项目</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/04/18/taobao-read/" data-id="ckebizjwn001f647k2mxc5l4p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SpringCloud" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/SpringCloud/" class="article-date">
  <time datetime="2019-04-14T08:58:47.000Z" itemprop="datePublished">2019-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/SpringCloud/">SpringCloud</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SpringCloud系列学习  </p>
<p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。   </p>
<h1 id="一-总体把握"><a href="#一-总体把握" class="headerlink" title="一.总体把握"></a>一.总体把握</h1><h2 id="架构发展史："><a href="#架构发展史：" class="headerlink" title="架构发展史："></a>架构发展史：</h2><p><img src="http://selfstudy.oss-cn-beijing.aliyuncs.com/blog/1.%20%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="架构发展史"></p>
<ul>
<li><p>单一应用架构：</p>
<p>  就一个应用，所有功能聚合在一起，以减少部署节点和成本，ORM是关键</p>
</li>
<li><p>垂直应用架构：</p>
<p>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架（MVC）是关键。</p>
</li>
<li><p>分布式服务架构：</p>
<p>  当垂直应用逐渐增多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快的响应多变的市场需求。此时，用于提高业务复用以及整合的分布式服务框架（RPC）是关键。</p>
<p>  旨在支持应用程序和服务开发，可以利用物理架构由多个自制的处理元素，不共享主内存，但通过网络发送消息合作。</p>
</li>
<li><p>流动计算架构：</p>
<p>  当服务增多，容量的评估，小服务器资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心（SOA）是关键。</p>
</li>
</ul>
<h2 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h2><ul>
<li>服务注册与发现</li>
<li>服务网关：前端路由，连接内外的大门，屏蔽内部细节，路由功能，限流，容错，监控，日志</li>
<li>后端通用服务：（也称中间层服务 Middle Tier Service）</li>
<li>前端服务：(也称边缘服务 Edge Service)：聚合，裁剪后端服务，暴露。<ul>
<li>聚合： eg: 将多个API合并成一个</li>
<li>裁剪： eg: 同一个接口，PC端调用返回得多，移动端调用返回的信息少</li>
</ul>
</li>
</ul>
<h2 id="两大实现方案："><a href="#两大实现方案：" class="headerlink" title="两大实现方案："></a>两大实现方案：</h2><ul>
<li><p>阿里系：</p>
<ul>
<li>Dubbo: 服务化治理</li>
<li>Zookeeper: 服务注册中心</li>
<li>SpringMVC or SpringBoot：</li>
</ul>
</li>
<li><p>Spring Cloud 全家桶:</p>
<ul>
<li><p>Spring Cloud Netflix Eureka</p>
</li>
<li><p>SpringBoot</p>
<p>Spring Cloud 的版本：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><p>参考知乎，以订单服务、库存服务、仓储服务、积分服务为例</p>
<p>具体业务例如：用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态。订单服务调用库存服务，完成相应功能；订单服务调用仓储服务，完成相应功能；订单服务调用积分服务，完成相应功能。</p>
<ul>
<li><p>Eureka：</p>
<ul>
<li><p>EurekaClient：负责将这个服务的信息注册到Eureka Server中</p>
</li>
<li><p>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/2.Eureka%E4%B8%BE%E4%BE%8B.jpg" alt="Eureka举例"></p>
<p>订单服务本地有一个Eureka的client，会去远端的Eureka server询问 需要调用的其他服务（库存、仓储、积分）的地址和端口，并且拉取到本地缓存。 之后订单服务就可以 调用 其他三种服务。</p>
</li>
</ul>
</li>
<li><p>Feign:</p>
<ul>
<li><p>Feign使用了动态代理，Feign Client会在底层根据注解，跟指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/3.Feign%E4%B8%BE%E4%BE%8B.jpg" alt="Feign举例"></p>
<p>对一个接口定义@FeignClient注解，Feign就会针对这个接口创建一个动态代理；接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心；Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址；最后针对这个地址，发起请求、解析响应</p>
</li>
</ul>
</li>
<li><p>Ribbon:</p>
<ul>
<li><p>负载均衡</p>
</li>
<li><p>载均衡默认使用的最经典的Round Robin轮询算法，将服务均匀的依次发送到对应的机器（1,2,3,4,1,2,3,4…）<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/4.Ribbon%E4%B8%BE%E4%BE%8B.jpg" alt="Ribbon举例"></p>
<p>Ribbon是和Feign以及Eureka紧密协作，完成工作的。</p>
</li>
</ul>
<ol>
<li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号；  </li>
<li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器；</li>
<li>Feign就会针对这台机器，构造并发起请求  </li>
</ol>
</li>
<li><p>Hystrix:</p>
<ul>
<li><p>Hystrix是隔离、熔断以及降级的一个框架。</p>
</li>
<li><p>Hystrix会有很多个小小的线程池，每个服务职能调用自己的线程池里面的线程，线程卡住了，不会影响到其他服务的线程调用。</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/5.Hystrix%E4%B8%BE%E4%BE%8B.jpg" alt="Hystrix举例"></p>
<p>库存服务、仓储服务、积分服务分别有自己的线程池，当积分服务down掉后，不会影响库存和仓储，积分服务自己会选择做服务熔断或者服务降级，然后去故障数据库里记录数据。</p>
</li>
</ul>
</li>
<li><p>Zuul：</p>
</li>
<li><p>网关</p>
</li>
<li><p>可以做：统一的降级、限流、认证授权、安全</p>
<p>  像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务</p>
</li>
<li><p>整体的架构图：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/6.%20%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="整体架构图举例"></p>
</li>
</ul>
<h2 id="微服务的管理学（康辉定律）【微服务的精髓】"><a href="#微服务的管理学（康辉定律）【微服务的精髓】" class="headerlink" title="微服务的管理学（康辉定律）【微服务的精髓】"></a>微服务的管理学（康辉定律）【微服务的精髓】</h2><blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.<br>—— 任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致</p>
</blockquote>
<p>ztp: 什么样的系统适合用微服务架构来设计，涉及到系统本身的功能，团队的人员配置与管理。</p>
<ul>
<li>传统团队：将不同能力的人才从资源池里面选调出来完成项目，项目结束后释放人才资源。</li>
<li>微服务团队：人员组织是团队模式，倾向于让团队负责整个服务（模块）的生命周期，以提供更优质的服务。小团队里面要能自己处理从前端到后端，从开发到运维部署的所有事情。  </li>
</ul>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/11.%E4%BC%A0%E7%BB%9F%E5%9B%A2%E9%98%9F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9B%A2%E9%98%9F.png" alt="传统团队与微服务团队">  </p>
<h1 id="二-服务的注册与发现（Eureka）"><a href="#二-服务的注册与发现（Eureka）" class="headerlink" title="二.服务的注册与发现（Eureka）"></a>二.服务的注册与发现（Eureka）</h1><ul>
<li>Eureka: 属于 Spring-cloud-netflix包下，主要内容是对Netflix公司一系列开源产品的包装</li>
<li>本章节采用基于下列版本来搭建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-boot:  1.5.4.RELEASE</span><br><span class="line">spring-cloud: Dalston.SR1</span><br></pre></td></tr></table></figure>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2></li>
</ul>
<p>参考 程序猿DD的这篇博客</p>
<ol>
<li><p>使用IDEA创建一个工程Spring-Cloud-Demo</p>
</li>
<li><p>创建 Eureka-server</p>
</li>
</ol>
<ul>
<li>新建一个Module名为 Eureka-server，注意：new -module -&gt; spring initializr -&gt; Cloud Discovery -&gt; Eureka Server</li>
<li>并在pom.xml中引入相应的依赖；【注意对应的版本信息】</li>
<li>在主类中添加这个@EnableEurekaServer注解，启动一个服务注册中心提供给其他应用进行对话</li>
<li>将“服务注册中心自己作为客户端来尝试注册它自己”的功能禁掉。需要在 application.properties/application.yml 配置文件里面添加一些信息，我的application.yml如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动工程,访问 <a target="_blank" rel="noopener" href="http://localhost:1001/">http://localhost:1001/</a> ,此时没有任何服务来注册</li>
</ul>
<ol start="3">
<li>创建“服务提供方” Eureka-Client</li>
</ol>
<ul>
<li><p>创建一个基本的Spring Boot应用。命名为 eureka-client</p>
</li>
<li><p>在pom.xml中，加入相应配置， 大概是spring-boot的版本信息，和Spring Cloud的版本信息。</p>
</li>
<li><p>添加相应的接口和服务信息（这一步实际工程会有）</p>
</li>
<li><p>在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现</p>
</li>
<li><p>配置application.properties/application.yml，我的application.yml如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1001/eureka/</span> <span class="comment">#此处应当能找到上面定义的 server</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务，能观察到服务已经被注册进eureka中心<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/7.eureka.png" alt="eureka示例"></p>
</li>
</ul>
<ol start="4">
<li>Eureka的高可用</li>
</ol>
<ul>
<li><p>两个Eureka互相注册</p>
<p>  注意在测试的时候会出现更新不及时的情况，是由于eureka的心跳检测机制引起的，重启eureka即可</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/8.euraka%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="Eureka的高可用"></p>
</li>
<li><p>利用IDEA,Edit configuration -&gt; copy 一份 eureka server， 给两个server修改启动参数的 VM options 分别为 -Dserver.port=8761 和 -Dserver.port=8762。</p>
</li>
<li><p>启动server1前，修改其配置文件如下，并启动server1：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#register-with-eureka: true</span></span><br><span class="line">    <span class="comment"># 表示是否从Eureka Server获取注册信息，默认为true。 如果这是一个单点的 Eureka Server，不需要同步其他节  点的数据，可以设为false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8762/eureka/</span> <span class="comment"># 意思是让server1在server2中注册</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#  关闭自我保护模式，只能在开发环境这样做，生产环境需要打开</span></span><br><span class="line">    <span class="comment">#    port: 1001</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动server2前，修改其配置文件如下，并启动server2：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#    register-with-eureka: true</span></span><br><span class="line">    <span class="comment"># 表示是否从Eureka Server获取注册信息，默认为true。 如果这是一个单点的 Eureka Server，不需要同步其他节  点的数据，可以设为false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span>  <span class="comment"># 意思是让server2在server1中注册</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#  关闭自我保护模式，只能在开发环境这样做，生产环境需要打开</span></span><br><span class="line">    <span class="comment">#    port: 1001</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eureka-client照常启动即可，注意只需要在一个server1中注册，即可将注册信息同步到server2；</p>
<p>  挂掉server1,发现client仍然在server2上面注册存在；</p>
<p>  但是如果server1挂掉了，再重启client,则会发现server2上的client也不复存在，所以最保险的做法应该是如下的配置：(配置多台server的地址)</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大集群三个eureka的相互注册，延伸一下即可,server之间两两相互注册，并且client注册三个server</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/9.eureka%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="三个eureka的相互注册"></p>
</li>
</ul>
<h2 id="服务注册的一些理解"><a href="#服务注册的一些理解" class="headerlink" title="服务注册的一些理解"></a>服务注册的一些理解</h2><ol>
<li><p>为什么要在分布式系统中使用 “服务发现”：  </p>
<p> <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/10.eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.png" alt="为什么要在分布式系统中使用 “服务发现”"></p>
</li>
</ol>
<p>随着集群中机器数量的增加，B的数量过多，不适合用写配置文件的方式来记录</p>
<ol start="2">
<li>服务发现的两种分类（需要权衡）：</li>
</ol>
<ul>
<li><p>客户端发现：</p>
<ul>
<li>由A发起，去注册中心找到一个B，然后通过ip地址调用B。关键点在于：使用某种“负载均衡”的机制来选择提供服务的一台机器， 例如： 轮训，随机，哈希等。</li>
<li>优点：简单，不需要代理的介入，client知道所有服务提供方的地址。</li>
<li>缺点：client需要自己实现一套逻辑来挑选服务提供方。</li>
<li>举例： Eureka</li>
</ul>
</li>
<li><p>服务端发现：</p>
<ul>
<li>增加一个新的角色：代理。 代理帮助A从众多可用的B中找到一个。</li>
<li>优点：B对A是不可见的，A只需要访问代理即可。</li>
<li>举例： Nginx, Dubbo系的Zookeeper, Kubernetes(k8s：集群中的每一个节点都运行一个代理，来实现服务发现的功能)</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>pringCloud的服务调用方式（不同语言怎么在eureka中注册）</p>
<p> eureka允许其他语言被纳入到他的服务治理体系中去，具体是这种语言需要实现eureka的客户端程序，例如 node.js实现了eureka-js-client。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/04/14/SpringCloud/" data-id="ckebizjw6000f647kfi203ozd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">java - SpringCloud - 微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-concurrent" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/concurrent/" class="article-date">
  <time datetime="2019-03-27T08:58:47.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/concurrent/">java并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java多线程实例</p>
<h1 id="1-守护线程"><a href="#1-守护线程" class="headerlink" title="1. 守护线程"></a>1. 守护线程</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>通过setDaemon(true)来设置线程为“守护线程”,守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。</p>
<ul>
<li>当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；</li>
<li>如果还有一个或以上的非守护线程则JVM不会退出。</li>
</ul>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            <span class="comment">//永真循环线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;   &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        DaemonThread test = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">        test.setDaemon(<span class="keyword">true</span>);    </span><br><span class="line">        <span class="comment">//调试时可以设置为false，那么这个程序是个死循环，没有退出条件。设置为true，即可主线程结束，test线程也结束。</span></span><br><span class="line">        test.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;isDaemon = &quot;</span> + test.isDaemon());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read();   <span class="comment">// 接受输入，使程序在此停顿，一旦接收到用户输入，main线程结束，守护线程自动结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p>
<h1 id="2-Executors"><a href="#2-Executors" class="headerlink" title="2. Executors"></a>2. Executors</h1><h2 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a>1. 定义：</h2><p>java.util.concurrent包中的ExecutorService, ExecutorService就是Java中对线程池的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span><br><span class="line"><span class="number">2.</span> newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span><br><span class="line"><span class="number">3.</span> newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</span><br><span class="line"><span class="number">4.</span> newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 2.用法实例：</span><br><span class="line">基本使用和创建</span><br><span class="line">```java </span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Asynchronous task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future future = exec.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Asynchronous task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">//如果任务结束执行则返回 null</span></span><br><span class="line">System.out.println(<span class="string">&quot;future.get()=&quot;</span> + future.get());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Task 3&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">String result = executorService.invokeAny(callables);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>invokeAny(…)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果.</p>
</li>
<li><p>invokeAll(…)与 invokeAny(…)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。</p>
</li>
</ul>
<h1 id="3-N个线程循环打印累加数字"><a href="#3-N个线程循环打印累加数字" class="headerlink" title="3. N个线程循环打印累加数字"></a>3. N个线程循环打印累加数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、补充如下程序通过N个线程顺序循环打印从0至100，如给定N&#x3D;3则输出： </span><br><span class="line">thread0: 0</span><br><span class="line">thread1: 1</span><br><span class="line">thread2: 2</span><br><span class="line">thread0: 3</span><br><span class="line">thread1: 4</span><br><span class="line">...</span><br><span class="line">注意线程号与输出顺序间的关系。</span><br></pre></td></tr></table></figure>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><p>使用 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NumberCount().printNumber(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        PrintThead first = <span class="keyword">new</span> PrintThead(<span class="number">0</span>, n,<span class="number">100</span>);</span><br><span class="line">        first.start();</span><br><span class="line"></span><br><span class="line">        PrintThead pre = first;</span><br><span class="line">        PrintThead printThead = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            printThead = <span class="keyword">new</span> PrintThead(i, n,<span class="number">100</span>);</span><br><span class="line">            pre.setNextThreadCondition(printThead.getCondition());</span><br><span class="line">            pre = printThead;</span><br><span class="line">            printThead.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=first) &#123;</span><br><span class="line">            pre.setNextThreadCondition(first.getCondition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintThead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">int</span> order;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键点1： Condition 的强大之处在于它可以为多个线程间建立不同的 Condition</span></span><br><span class="line">    <span class="comment">// 而：      notify 会提醒其他的任意 一个线程</span></span><br><span class="line">    Condition condition = lock.newCondition();    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Condition nextThreadCondition;</span><br><span class="line"></span><br><span class="line">    PrintThead(<span class="keyword">int</span> order, <span class="keyword">int</span> num, <span class="keyword">int</span> max)&#123;</span><br><span class="line">        <span class="keyword">this</span>.order = order;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextThreadCondition</span><span class="params">(Condition nextThreadCondition)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextThreadCondition = nextThreadCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">getCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; max) &#123;</span><br><span class="line">                nextThreadCondition.signal();     </span><br><span class="line">                lock.unlock();                    <span class="comment">//关键点2：最后一次，销毁线程前，需要手动释放锁</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count % num == order) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count);</span><br><span class="line">                count++;</span><br><span class="line">                nextThreadCondition.signal();    <span class="comment">// signal 可以提醒一个指定的condition </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 考点： 线程之间的协作</span><br><span class="line"><span class="number">1.</span> join</span><br><span class="line"></span><br><span class="line">    在线程中调用另一个线程的 join() 方法，会将当前线程挂起，直到目标线程结束后恢复。也可以带一个超时参数，保证目标线程在超时后，join方法可以返回</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> wait(), notify(), notifyAll()</span><br><span class="line">```java </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">/*指代的为 t,因为使用的是implements方式。若使用继承Thread类的方式,使用this*/</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">/*唤醒另外一个线程，注意是 this对象的方法，而不是 Thread 类的方法 */</span></span><br><span class="line">            notify(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*使其休眠100毫秒，放大线程差异*/</span></span><br><span class="line">                Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;=<span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span>+ i);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/*放弃资源，等待*/</span></span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*只有一个TestThread对象*/</span></span><br><span class="line">        TestThread t = <span class="keyword">new</span> TestThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>await(), signal(), signalAll()</p>
<p> java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
</li>
</ol>
<h1 id="4-并发编程-原理（给volatile做铺垫）"><a href="#4-并发编程-原理（给volatile做铺垫）" class="headerlink" title="4. 并发编程 原理（给volatile做铺垫）"></a>4. 并发编程 原理（给volatile做铺垫）</h1><h2 id="1-内存模型的相关概念（计算机的内存模型）"><a href="#1-内存模型的相关概念（计算机的内存模型）" class="headerlink" title="1. 内存模型的相关概念（计算机的内存模型）"></a>1. 内存模型的相关概念（计算机的内存模型）</h2><p>计算机执行程序的时候，cpu（高速缓存）和 内存 之间存在 缓存数据不一致的问题，有两种解决方法：</p>
<ul>
<li>通过在总线加LOCK#锁的方式；</li>
<li>通过缓存一致性协议</li>
</ul>
<p>通过在总线加LOCK#锁的方式： 加锁会影响性能</p>
<p>=&gt;</p>
<p>通过缓存一致性协议： 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="2-并发编程的三个概念："><a href="#2-并发编程的三个概念：" class="headerlink" title="2.并发编程的三个概念："></a>2.并发编程的三个概念：</h2><p><strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong> </p>
<ol>
<li>原子性：  </li>
</ol>
<p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。一个很经典的例子就是银行账户转账问题：</p>
<ol start="2">
<li>可见性：(重要，需要理解)  </li>
</ol>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>  此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
</li>
</ul>
<ol start="3">
<li>有序性 （涉及到jvm的指令重排）</li>
</ol>
<ul>
<li><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
</li>
<li><p>指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。（ztp:有依赖的地方会保证是有序的，当然了，仅限单线程）</p>
</li>
<li><p>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
</li>
</ul>
<h3 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h3><p>引申：Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<ol>
<li><p>原子性：</p>
<p> Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。synchronized和Lock能够保证任一时刻只有一个线程执行该代码块。</p>
</li>
<li><p>可见性：</p>
<p> Java提供了volatile关键字来保证可见性。</p>
<p> 解释：　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p> 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p> 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性</p>
</li>
<li><p>有序性：</p>
<p> happens-before原则（先行发生原则）：这8条原则摘自《深入理解Java虚拟机》。</p>
</li>
</ol>
<ul>
<li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
</li>
<li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</p>
</li>
<li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>
</li>
<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
</li>
<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>
</li>
<li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
</li>
<li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、 Thread.isAlive()的返回值手段检测到线程已经终止执行</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>
<p>重要需要理解的是 volatile变量规则： 直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
</li>
</ul>
<h1 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h1><h2 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h2><p>变量不可变，则不需要考虑线程安全问题：</p>
<ul>
<li>final修饰</li>
<li>String</li>
<li>枚举类型</li>
<li>Number部分子类：Long，Double，BigInteger, BigDecimal 等</li>
</ul>
<h2 id="2-阻塞同步（互斥同步）-（悲观锁）"><a href="#2-阻塞同步（互斥同步）-（悲观锁）" class="headerlink" title="2. 阻塞同步（互斥同步） （悲观锁）"></a>2. 阻塞同步（互斥同步） （悲观锁）</h2><ul>
<li>synchronized</li>
<li>ReentranLock （重入锁）</li>
</ul>
<h2 id="3-非阻塞同步-（乐观锁）"><a href="#3-非阻塞同步-（乐观锁）" class="headerlink" title="3. 非阻塞同步 （乐观锁）"></a>3. 非阻塞同步 （乐观锁）</h2><p>先进行操作，判断没有其他线程共享资源，则操作成功；否则采取补偿措施（重试直到成功），此之谓非阻塞。</p>
<p>乐观锁需要 硬件支持原子性操作：CAS(compare and set)</p>
<h2 id="4-无同步方案"><a href="#4-无同步方案" class="headerlink" title="4. 无同步方案"></a>4. 无同步方案</h2><ul>
<li>栈封闭（多线程访问方法的局部变量，属于线程私有的，没有安全性问题）</li>
<li>线程本地存储（将需要共享数据的 多块代码，放进一个线程里面，一次性搞定，例如“web的request就是一个thread”）</li>
<li>可重入代码？</li>
</ul>
<h1 id="6-关键词分析："><a href="#6-关键词分析：" class="headerlink" title="6. 关键词分析："></a>6. 关键词分析：</h1><h2 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1. synchronized"></a>1. synchronized</h2><h2 id="2-volatile-（理解-见java内存模型）"><a href="#2-volatile-（理解-见java内存模型）" class="headerlink" title="2. volatile （理解 见java内存模型）"></a>2. volatile （理解 见java内存模型）</h2><p>原理：</p>
<ul>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
</li>
<li><p>禁止进行指令重排序。</p>
</li>
</ul>
<p>实现：  </p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”   </p>
<p>—- 《深入理解Java虚拟机》   </p>
<p>lock前缀相当于 内存屏障 会提供 3 个功能：    </p>
<ul>
<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>它会强制将对缓存的修改操作立即写入主存；</p>
</li>
<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
<p>面试答题思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>保证了 可见性； 禁止了指令重排；</span><br><span class="line">    解释可见性（主内存 和 工作内存）</span><br><span class="line">    解释有序性（jvm指令重排）</span><br><span class="line"></span><br><span class="line">实现方式是通过加入lock前缀指令（内存屏障）</span><br><span class="line">    解释内存屏障（禁止重拍，先写后读，缓存失效）</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>该方案不能很好的利用线程2终止线程1的工作，需要加上 volatile关键字给stop变量,解释如下：</p>
<ul>
<li><p>使用volatile关键字会强制将修改的值立即写入主存；</p>
</li>
<li><p>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
</li>
<li><p>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
</li>
</ul>
<p>引申： （ztp的理解）  </p>
<p>“当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）”  </p>
<p>解决mysql 和 redis的缓存一致性的问题，可以从这一点学到：  </p>
<ul>
<li><p>增：先写mysql，redis缓存失效</p>
</li>
<li><p>删：删除mysql,redis缓存失效</p>
</li>
<li><p>改：先改mysql，redis缓存失效</p>
</li>
<li><p>查：先查redis，有就返回；redis没有，则读库，然后更新redis缓存</p>
</li>
</ul>
<h2 id="3-ReentranLock"><a href="#3-ReentranLock" class="headerlink" title="3. ReentranLock"></a>3. ReentranLock</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/03/27/concurrent/" data-id="ckebizjxj003d647k1dbq8do1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-%E5%B9%B6%E5%8F%91/" rel="tag">java - 并发</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">dubbo - 微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/financial/" rel="tag">financial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-OOM/" rel="tag">java - OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">java - SpringCloud - 微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-mysql/" rel="tag">java - mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-reflect/" rel="tag">java - reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-sort/" rel="tag">java - sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">java - 动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E5%B9%B6%E5%8F%91/" rel="tag">java - 并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-activemq/" rel="tag">中间件 - activemq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BE%9B%E5%BA%94%E9%93%BE/" rel="tag">供应链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" rel="tag">前后端分离</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">牛客网 - 二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%95%B0%E7%BB%84/" rel="tag">牛客网 - 数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E9%93%BE%E8%A1%A8/" rel="tag">牛客网 - 链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE-%E9%9D%A2%E8%AF%95/" rel="tag">项目 - 面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 16px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySql/" style="font-size: 10px;">MySql</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">dubbo - 微服务</a> <a href="/tags/financial/" style="font-size: 10px;">financial</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java-OOM/" style="font-size: 10px;">java - OOM</a> <a href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">java - SpringCloud - 微服务</a> <a href="/tags/java-mysql/" style="font-size: 10px;">java - mysql</a> <a href="/tags/java-reflect/" style="font-size: 10px;">java - reflect</a> <a href="/tags/java-sort/" style="font-size: 10px;">java - sort</a> <a href="/tags/java-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">java - 动态规划</a> <a href="/tags/java-%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">java - 并发</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-activemq/" style="font-size: 10px;">中间件 - activemq</a> <a href="/tags/%E4%BE%9B%E5%BA%94%E9%93%BE/" style="font-size: 10px;">供应链</a> <a href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" style="font-size: 10px;">前后端分离</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">牛客网 - 二叉树</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%95%B0%E7%BB%84/" style="font-size: 10px;">牛客网 - 数组</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">牛客网 - 链表</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 12px;">读书</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12px;">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE-%E9%9D%A2%E8%AF%95/" style="font-size: 12px;">项目 - 面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/09/threadLearn6/">多线程与高并发（六）Wait-Notify与LockSupport</a>
          </li>
        
          <li>
            <a href="/2020/05/07/threadLearn5-2/">多线程与高并发（五）JUC同步工具(2)</a>
          </li>
        
          <li>
            <a href="/2020/05/06/threadLearn5/">多线程与高并发（五）JUC同步工具(1)</a>
          </li>
        
          <li>
            <a href="/2020/05/01/threadLearn4/">多线程与高并发（四）CAS与Atomic</a>
          </li>
        
          <li>
            <a href="/2020/05/01/threadLearn3/">多线程与高并发（三）Volatile关键字</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zhutianpeng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>