<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ztxpp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ztxpp&#39;s Blog">
<meta property="og:url" content="ztxpp.cc/page/2/index.html">
<meta property="og:site_name" content="Ztxpp&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhutianpeng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ztxpp&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ztxpp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="ztxpp.cc"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mybatis源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/02/mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2019-11-02T07:28:42.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">mybatis源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>软件开发工程师进阶，必须要学会阅读源码，以mybatis的源码为例进行源码阅读的训练和学习，重点有二，一是学习mybatis的设计模式和编码方式，二是学习阅读源码的方式。参照资料：<a target="_blank" rel="noopener" href="https://ke.qq.com/course/435473?tuin=7b49ac1d">深入浅出MyBatis技术内幕</a></p>
</blockquote>
<p>注：看源码的过程中，发现自己不熟悉的知识点： java泛型，lambda表达式，一些设计模式等。</p>
<h1 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h1><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191105142603.png" alt="mybatis整体架构"></p>
<h1 id="2-日志模块"><a href="#2-日志模块" class="headerlink" title="2. 日志模块"></a>2. 日志模块</h1><h2 id="2-0-需求分析"><a href="#2-0-需求分析" class="headerlink" title="2.0 需求分析"></a>2.0 需求分析</h2><p>需求：</p>
<ul>
<li>MyBatis没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各<br>不相同，而MyBatis统一提供了trace、debug、warn、error四个级别。</li>
<li>自动扫描日志实现，并且第三方日志插件加载优先级如下：slf4J → commonsLoging → Log4J2 → Log4J<br>→ JdkLog;</li>
<li>日志的使用要优雅的嵌入到主体功能中；</li>
</ul>
<p>解决方式：</p>
<ul>
<li>功能点一：client和提供者的功能相近，只是接口不匹配（第三方日志组件和），可以使用适配器模式。</li>
<li>功能点二：通过静态代码块的形式设置日志加载优先级顺序。</li>
<li>功能点三：运用动态代理的方式实现 日志功能优雅的嵌入到主体功能中</li>
</ul>
<h2 id="2-1-日志的适配器"><a href="#2-1-日志的适配器" class="headerlink" title="2.1 日志的适配器"></a>2.1 日志的适配器</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191107140626.png" alt="MyBatis日志的适配器"></p>
<p>Mybatis的日志模块采用适配器模式来进行组织，做第三方插件与目标接口之间的适配工作。诸多适配器类，实现org.apache.ibatis.logging.Log接口, 在适配器内部做了函数功能的适配，举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Log4jjImpl 适配器类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl.class.getName();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;   <span class="comment">// 此处的Logger 是真实提供功能的 org.apache.log4j.Logger接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = Logger.getLogger(clazz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//下面几个方法是主要转换部分，相当于把 org.apache.log4j.Logger的不同等级，</span></span><br><span class="line">  <span class="comment">// 转化为 org.apache.ibatis.logging.Log的 对应等级。其他的适配器也是类似。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.DEBUG, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.TRACE, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.WARN, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Log4j2LoggerImpl应该是根据情况有两种转换方式，其中一种Log4j2AbstractLoggerImpl通过装饰者模式做了一些功能的增强，这里不做细致研究。</p>
<h2 id="2-2-静态代码块实现加载的优先级"><a href="#2-2-静态代码块实现加载的优先级" class="headerlink" title="2.2 静态代码块实现加载的优先级"></a>2.2 静态代码块实现加载的优先级</h2><p>诸多第三方日志的加载顺序，是在MyBatis的代码中写死的！ 通过LogFactory的静态代码块来实现。 </p>
<ul>
<li>静态代码块是给类初始化的，而构造代码块是给对象初始化的。</li>
<li>执行顺序： 静态代码块（JVM加载类时加载）&gt; 构造块（创建对象时加载，给这个类所有的对象使用）&gt; 构造方法（创建对象时加载，给特异性对象使用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LogFactory类 静态代码块部分</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">    tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">    tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">    tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   上述的lamda的写法相当于一个匿名内部类（实现了Runnable的实现类），转化成下面的写法：</span></span><br><span class="line"><span class="comment">    (由于tryImplementation方法需要一个Runnable参数)</span></span><br><span class="line"><span class="comment">    tryImplementation(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">      @Override</span></span><br><span class="line"><span class="comment">      public void run() &#123;</span></span><br><span class="line"><span class="comment">        LogFactory.useSlf4jLogging();</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//    tryImplementation(()-&gt;LogFactory.useSlf4jLogging());</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-动态代理嵌入日志功能"><a href="#2-3-动态代理嵌入日志功能" class="headerlink" title="2.3 动态代理嵌入日志功能"></a>2.3 动态代理嵌入日志功能</h2><p>说道优雅的嵌入某功能，想到Spring AOP的思想，其本质是动态代理模式，参看<a href="https://ztxpp.cc/2019/10/21/designPattern2/#%E5%9B%9B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F#JDK_PROXY_PATTERN"> 设计模式-动态代理章节</a>， MyBatis使用的是JDK动态代理模式。</p>
<p>打印日志需求：</p>
<ul>
<li>在创建prepareStatement时，打印执行的SQL语句</li>
<li>访问数据库时，打印参数的类型和值</li>
<li>查询出结构后，打印结果数据条数</li>
</ul>
<p>MyBatis的jdbc包里，是这样设计的：</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191107163632.png" alt="MyBatis的动态代理模式"></p>
<p>四个Logger类负责了不同时期打印信息的功能，均实现了InvocationHandler接口。观察一个connect的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">newInstance</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">  InvocationHandler handler = <span class="keyword">new</span> ConnectionLogger(conn, statementLog, queryStack);</span><br><span class="line">  ClassLoader cl = Connection.class.getClassLoader();</span><br><span class="line">  <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际生成的并不是原始的Connection接口的实现类，而是 <strong>由JDK的 Proxy类动态生成的，实现了Connection接口的，聚合了InvocationHandler接口实现类</strong> 的： $Proxy 类。</p>
<p>这四个类之间的关联顺序如下：</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191107173622.png" alt="关联"></p>
<h1 id="3-数据源模块"><a href="#3-数据源模块" class="headerlink" title="3. 数据源模块"></a>3. 数据源模块</h1><h2 id="3-0-需求分析"><a href="#3-0-需求分析" class="headerlink" title="3.0 需求分析"></a>3.0 需求分析</h2><p>数据源工厂 -&gt; 数据源 -&gt; 数据库连接</p>
<p>DataSourceFactory -&gt; DataSource -&gt; Connection</p>
<ul>
<li>常见的数据源需要实现 javax.sql.DataSource接口</li>
<li>MyBatis不但要能集成第三方的数据源组件，自身也提供了数据源的实现</li>
<li>一般情况下，数据源的初始化过程参数较多，比较复杂,客户端不应该关注这个创建数据源的过程</li>
</ul>
<h2 id="3-1-由数据源工厂产生数据源"><a href="#3-1-由数据源工厂产生数据源" class="headerlink" title="3.1 由数据源工厂产生数据源"></a>3.1 由数据源工厂产生数据源</h2><ul>
<li>工厂模式 or 简单工厂模式</li>
</ul>
<ol>
<li>工厂模式的分析见这篇博客， MyBatis使用的是简单工厂模式，由数据源工厂产生数据源。只不过datasource包分为了两种产生连接的类型： Pool和 unPool。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnpooledDataSourceFactory类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建对象的几种方式及其特点：</li>
</ol>
<ul>
<li>new对象： 创建简单对象使用，对象创建和对象使用 混杂在一起，违反单一职责原则； 业务扩展可能修改代码，违反开闭原则</li>
<li>反射创建对象： 同上。</li>
<li>工厂类创建对象：提取出创建对象的同一语句，方便修改和维和。扩展时只需要增加对应的工厂，符合开闭原则。</li>
</ul>
<h2 id="3-2-由数据源（连接池）产生连接"><a href="#3-2-由数据源（连接池）产生连接" class="headerlink" title="3.2 由数据源（连接池）产生连接"></a>3.2 由数据源（连接池）产生连接</h2><ul>
<li>连接池的数据结构</li>
<li>获取连接的算法流程</li>
</ul>
<ol>
<li>连接池的数据结构就是两个 ArrayList<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数据源模块项目结构：</span><br><span class="line">datasource</span><br><span class="line">    ├─  pooled  使用连接池的包</span><br><span class="line">    │    ├─ PooledDataSourceFactory     数据源工厂类</span><br><span class="line">    │    ├─ PooledDataSource            一个简单、同步、安全的数据库连接池类</span><br><span class="line">    │    ├─ PooledConnection            使用动态代理增强的数据库连接    </span><br><span class="line">    │    └─ PoolState                   用于管理PooledConnection对象状态的组件，通过两个list分别 管理空闲状态的连接资源和活跃状态的连接资源</span><br><span class="line">    │ </span><br><span class="line">    └─  unpooled  不使用连接池的包</span><br><span class="line">         ├─ UnpooledDataSourceFactory   数据源工厂类</span><br><span class="line">         └─ UnpooledDataSource          数据库连接池类  </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>PoolState中保存着两个List:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  空闲的连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 活跃的，使用中的连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>使用List是因为具有先后顺序，可以记录connection的使用时间，判断是否超时，只需看队首的元素。</li>
<li>这两个List随PoolState对象一起保存在JVM堆中，线程公有，需要注意并发问题。</li>
</ul>
<ol start="2">
<li><p>获取连接的算法流程</p>
<p> 参考这里，先略过<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/37671851">https://blog.csdn.net/luanlouis/article/details/37671851</a></p>
</li>
</ol>
<h1 id="4-缓存模块"><a href="#4-缓存模块" class="headerlink" title="4. 缓存模块"></a>4. 缓存模块</h1><h2 id="4-1-应用：-MyBatis有两级缓存机制"><a href="#4-1-应用：-MyBatis有两级缓存机制" class="headerlink" title="4.1 应用： MyBatis有两级缓存机制"></a>4.1 应用： MyBatis有两级缓存机制</h2><ul>
<li>一级缓存: SqlSession级别</li>
<li>二级缓存：Mapper级别</li>
</ul>
<h2 id="4-2-需求分析"><a href="#4-2-需求分析" class="headerlink" title="4.2 需求分析"></a>4.2 需求分析</h2><ul>
<li>MyBatis的缓存底层是基于Map来实现的，核心功能是从缓存中读取数据</li>
<li>缓存模块附加了很多额外功能，如：防止缓存击穿，添加缓存清空策略（FIFO,LRU）,序列化， 日志能力，定时清空.这些功能如何添加。</li>
<li>附加功能如何任意组合使用。</li>
</ul>
<h2 id="4-3-装饰器模式实现缓存模块的附加功能及其任意叠加"><a href="#4-3-装饰器模式实现缓存模块的附加功能及其任意叠加" class="headerlink" title="4.3 装饰器模式实现缓存模块的附加功能及其任意叠加"></a>4.3 装饰器模式实现缓存模块的附加功能及其任意叠加</h2><ul>
<li><p>装饰器模式，参考<a href="https://ztxpp.cc/2019/10/21/designPattern2">这篇博客</a>。 </p>
</li>
<li><p>装饰器模式使用案例：IO中输入流和输出流的设计</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c://a.txt&quot;</span>)))</span><br></pre></td></tr></table></figure></li>
<li><p>MyBatis的缓存模块的项目结构</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191109164827.png" alt="缓存模块：装饰者模式"></p>
<p>  MyBatis的缓存接口Cache,有很多实现，每一个实现都是一个装饰器，对原始的Cache进行包装和功能增强。 装饰器内部含有Cache对象（接口对象，由于多态能存下任意的实现对象）。所以可以将各种装饰者进行<strong>任意叠加</strong>。</p>
<p>  比如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BlockingCache(<span class="keyword">new</span> FifoCache(<span class="keyword">new</span> LoggingCache())); <span class="comment">//伪代码</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-4-详细分析一个装饰者实现类：BlockingCache"><a href="#4-4-详细分析一个装饰者实现类：BlockingCache" class="headerlink" title="4.4 详细分析一个装饰者实现类：BlockingCache"></a>4.4 详细分析一个装饰者实现类：BlockingCache</h2><p>用途：防止缓存雪崩</p>
<ul>
<li>缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统统造成很大的压力。</li>
<li>缓存穿透：如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会导致大量的请求在缓存中拿不到数据而去请求数据库，就会对后端系统造成很大的压力。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeout; <span class="comment">//设置过期时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;  <span class="comment">// 装饰者模式中的concrete impl</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//用ConcurrentHashMap来当锁，key是缓存本身的值，value是一把重入锁</span></span><br><span class="line">  <span class="comment">// 比起直接用lock， 把缓存作为key,能减小锁粒度：</span></span><br><span class="line">  <span class="comment">//    访问同一个缓存的线程 用同一把锁; 访问不同缓存的线程，不相互影响。很聪明！</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BlockingCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    <span class="keyword">this</span>.locks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.getSize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      delegate.putObject(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      releaseLock(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓存：</span></span><br><span class="line"><span class="comment">//    逻辑是取缓存值需要锁，取到了缓存释放锁，取不到缓存继续等待。 以此防止大量线程访问数据库（缓存雪崩）</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    acquireLock(key);</span><br><span class="line">    Object value = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      releaseLock(key); <span class="comment">//这里表示，第一个线程如果能在缓存中找到这个元素，则释放锁；没有找到，后面的线程就别想再找到这个元素了（拿不到锁）。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">    releaseLock(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegate.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key存在，则找到这个lock；如果不存在，则创建一把新锁（第一次访问，锁不存在，需要创建）给这个key作为value</span></span><br><span class="line">    <span class="keyword">return</span> locks.computeIfAbsent(key, k -&gt;  <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">   <span class="comment">// return locks.computeIfAbsent(key, k -&gt; &#123;return new ReentrantLock();&#125;);  </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Lock lock = getLockForKey(key);</span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t get a lock in &quot;</span> + timeout + <span class="string">&quot; for the key &quot;</span> +  key + <span class="string">&quot; at the cache &quot;</span> + delegate.getId());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Got interrupted while trying to acquire lock for key &quot;</span> + key, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = locks.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-5-装饰器的添加"><a href="#4-5-装饰器的添加" class="headerlink" title="4.5 装饰器的添加"></a>4.5 装饰器的添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在CacheBuilder中找到例子</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">      <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">        metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> ScheduledCache(cache); <span class="comment">//添加了ScheduledCache装饰器</span></span><br><span class="line">        ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> SerializedCache(cache); <span class="comment">//添加了SerializedCache装饰器</span></span><br><span class="line">      &#125;</span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);<span class="comment">//添加了LoggingCache装饰器</span></span><br><span class="line">      cache = <span class="keyword">new</span> SynchronizedCache(cache);<span class="comment">//添加了 SynchronizedCache装饰器</span></span><br><span class="line">      <span class="comment">//注意这里添加的SynchronizedCache装饰器，可以防止二级缓存的线程安全问题。</span></span><br><span class="line">      <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Error building standard cache decorators.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-5-缓存与数据库同步机制"><a href="#4-5-缓存与数据库同步机制" class="headerlink" title="4.5 缓存与数据库同步机制"></a>4.5 缓存与数据库同步机制</h2><ul>
<li><p>数据实时同步失效</p>
<ul>
<li>强一致性</li>
<li>增：写库，更新缓存； 删：删库； 改； 查</li>
</ul>
</li>
<li><p>数据准实时同步</p>
<ul>
<li>准一致性</li>
</ul>
</li>
<li><p>任务调度更新</p>
<ul>
<li>最终一致性</li>
</ul>
</li>
</ul>
<h1 id="5-反射模块"><a href="#5-反射模块" class="headerlink" title="5. 反射模块"></a>5. 反射模块</h1><h2 id="5-1-反射模块概述"><a href="#5-1-反射模块概述" class="headerlink" title="5.1 反射模块概述"></a>5.1 反射模块概述</h2><p>普通ORM框架查询数据的过程：</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191116144917.png" alt="orm框架的作用"></p>
<p>反射模块的作用是后面两个部分：</p>
<ul>
<li>实例化目标对象</li>
<li>对象属性的赋值</li>
</ul>
<p>反射核心类：</p>
<ul>
<li><p>ObjectFactory（接口）: 利用工厂模式创建对象的实例</p>
</li>
<li><p>ReflectorFactory: 利用工厂模式创建 Reflector</p>
<ul>
<li>Reflector： <strong>类的元数据的封装</strong>；对JDK提供的反射j进行了<strong>功能增强、性能提升</strong></li>
</ul>
</li>
<li><p>ObjectWrapperFactory：ObjectWrapper 的工厂类，用于创建ObjectWrapper</p>
<ul>
<li>ObjectWrapper： <strong>对象的封装</strong>，抽象了对象的属性信息，他定义了一系列查询对象属性信息的方法，以及更新属性的方法</li>
</ul>
</li>
</ul>
<h2 id="5-2-ObjectFactory"><a href="#5-2-ObjectFactory" class="headerlink" title="5.2 ObjectFactory"></a>5.2 ObjectFactory</h2><ul>
<li>主要作用：根据Class创建对象实例</li>
<li>反射创建实例对象的两种方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：通过class创建对象：</span></span><br><span class="line">Class classType = Class.forName(<span class="string">&quot;com.ztxpp.Person&quot;</span>);</span><br><span class="line">Object obj = classType.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：通过构造器创建对象</span></span><br><span class="line">Constructor&lt;Person&gt; con = Person.class.getConstructor(String.class,<span class="keyword">int</span>.class); </span><br><span class="line">    <span class="comment">//这里的参数是构造器的入参</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">&quot;lxf&quot;</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>DefaultObjectFactory, ObjectFactory接口的实现类相应代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,List&lt;Object&gt;constructorArgs)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate = resolveInterface(type);</span><br><span class="line">  <span class="comment">// we know types are assignable</span></span><br><span class="line">  <span class="keyword">return</span> (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes,List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">//如果创建对象时没有传参数，直接用默认构造器创建对象：</span></span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      constructor = type.getDeclaredConstructor();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          <span class="comment">//如果构造器是private，暴力方式变成 public：</span></span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果创建对象时传了参数：</span></span><br><span class="line">    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Clas[constructorArgTypes.size()]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.siz()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Objec[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGe(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    String argValues = Optional.ofNullable(constructorArgs).orElseGe(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> +argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析接口类型，用对应的实现类类型替代</span></span><br><span class="line"><span class="comment">// 引用： 在面向对象的开发中我们会提倡面对接口而不是面向具体实现的编程原则，但是在创建对象时则必须指定一个具体的类，为了解决这个问题，mybatis对常用的集合超类指定了具体的实现类：</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate;</span><br><span class="line">  <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">    classToCreate = ArrayList.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">    classToCreate = HashMap.class;</span><br><span class="line">  &#125; else if (type == SortedSet.class) &#123; // issue #510 Collections Support</span><br><span class="line">    classToCreate = TreeSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">    classToCreate = HashSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    classToCreate = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classToCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ObjectFactory objectFactory= <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  TestUserPojo testUserPojo = objectFactory.create(TestUserPojo.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 成功创建对象...</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-Reflector-amp-amp-ReflectorFactory"><a href="#5-3-Reflector-amp-amp-ReflectorFactory" class="headerlink" title="5.3 Reflector &amp;&amp; ReflectorFactory"></a>5.3 Reflector &amp;&amp; ReflectorFactory</h2><ol>
<li>Reflector： <strong>类的元数据的封装</strong>；对JDK提供的反射j进行了<strong>功能增强、性能提升</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line"><span class="comment">//POJO类的元数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type; <span class="comment">//类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames; <span class="comment">//属性有get方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames; <span class="comment">//属性有set方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 保存get方法： &lt;id, getId()&gt;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 保存set方法： &lt;id, setId()&gt;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// set方法的入参类型：&lt;id, Long&gt;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// get方法的返回参数：&lt;id, Long&gt;</span></span><br><span class="line">  <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor; <span class="comment">// 默认的构造方法</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可见，Reflector实际是对 bean的类的封装。 在MyBatis启动时，就已经将bean对象的元数据加载带 Reflector中了，当通过反射调用方法，或者属性时，其实是从Reflector的容器中获取的。这样提高了jdk原始反射的性能和效率。 – “空间换时间”</p>
<ol start="2">
<li><p>ReflectorFactory: 的实现类 DefaultReflectorFactory</p>
<ul>
<li>工厂模式，将reflector的创建和使用分开了</li>
<li>用线程安全的Map做缓存，在MyBatis刚启动的时候，将所有的bean用reflector封装起来，并且保存在这个ConcurrentHashMap中。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用这个线程安全的Map做缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (classCacheEnabled) &#123; <span class="comment">//如果缓存打开</span></span><br><span class="line">    <span class="comment">//computeIfAbsent方法的含义： ConcurrentHashMap 中找到则返回；找不到则创建新的，填入type对应的value中，然后返回</span></span><br><span class="line">    <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflectorFactoryTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">  Reflector reflector = reflectorFactory.findForClass(TestUserPojo.class);</span><br><span class="line">  Constructor&lt;?&gt; constructor = reflector.getDefaultConstructor();</span><br><span class="line">  String[] getablePropertyNames = reflector.getGetablePropertyNames();</span><br><span class="line">  String[] setablePropertyNames = reflector.getSetablePropertyNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-ObjectWrapper"><a href="#5-4-ObjectWrapper" class="headerlink" title="5.4 ObjectWrapper"></a>5.4 ObjectWrapper</h2><ul>
<li>主要作用：为对象实例赋值</li>
<li>主要方式：采用反射方式，获取set方法，来进行赋值</li>
</ul>
<h2 id="5-5-MetaObject-amp-amp-SystemMetaObject"><a href="#5-5-MetaObject-amp-amp-SystemMetaObject" class="headerlink" title="5.5 MetaObject &amp;&amp; SystemMetaObject"></a>5.5 MetaObject &amp;&amp; SystemMetaObject</h2><p>采用门面模式，包装上述核心类，提供给外部使用反射模块的功能</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191117160149.png" alt="门面模式"></p>
<p>SystemMetaObject中包含了MetaObject，将上述过程在内部完成，用静态方法的形式对外界提供简单易用的接口：</p>
<p>采用门面模式之前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">objectWrapperTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ObjectFactory objectFactory= <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  TestUserPojo testUserPojo = objectFactory.create(TestUserPojo.class);</span><br><span class="line">  ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">  MetaObject metaObject = MetaObject.forObject(testUserPojo,objectFactory,<span class="keyword">new</span> DefaultObjectWrapperFactory(),reflectorFactory);</span><br><span class="line">  ObjectWrapper wrapper = <span class="keyword">new</span> BeanWrapper(metaObject,testUserPojo);</span><br><span class="line"></span><br><span class="line">  PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  wrapper.set(prop,<span class="string">&quot;ztxpp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用门面模式之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemMetaObjectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TestUserPojo testUserPojo = SystemMetaObject.DEFAULT_OBJECT_FACTORY.create(TestUserPojo.class);</span><br><span class="line">  MetaObject metaObject = SystemMetaObject.forObject(testUserPojo);</span><br><span class="line">  metaObject.setValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;a&#x27;ming&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-模拟Mybatis使用反射模块"><a href="#5-6-模拟Mybatis使用反射模块" class="headerlink" title="5.6 模拟Mybatis使用反射模块"></a>5.6 模拟Mybatis使用反射模块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  TestUserPojo testUserPojo = SystemMetaObject.DEFAULT_OBJECT_FACTORY.creat(TestUserPojo.class);</span><br><span class="line">  MetaObject metaObject = SystemMetaObject.forObject(testUserPojo);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1,从数据库获取数据(模拟)</span></span><br><span class="line">  Map&lt;String, Object&gt; dbResult = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  dbResult.put(<span class="string">&quot;id&quot;</span>,<span class="keyword">new</span> Long(<span class="number">1</span>));</span><br><span class="line">  dbResult.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ztxpp&quot;</span>);</span><br><span class="line">  dbResult.put(<span class="string">&quot;good_student&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 从xml文件获取映射规则（模拟）</span></span><br><span class="line">  Map&lt;String,String&gt; mapper = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  mapper.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  mapper.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  mapper.put(<span class="string">&quot;goodStudent&quot;</span>,<span class="string">&quot;good_student&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 使用反射模块将数据生成pojo对象</span></span><br><span class="line">  <span class="keyword">for</span> (String key : mapper.keySet()) &#123;</span><br><span class="line">    String propName = key;</span><br><span class="line">    Object propValue = dbResult.get(mapper.get(key));</span><br><span class="line">    metaObject.setValue(propName,propValue);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(metaObject.getOriginalObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后记：<br>Mybatis的源码量较大，这次学习只涉及到：日志模块、数据源模块、缓存模块、反射模块 这四个模块，甚至没有涉及到源码的运行流程，只是停留在基础组件层。 学习源码的过程先看文档，再分层，然后梳理流程找入口，最后多调试。这只是开始，后续需要学习jdk并发部分和Spring的源码。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/11/02/mybatis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" data-id="ckebizjxn003e647kfpt74shm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-designPattern3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/22/designPattern3/" class="article-date">
  <time datetime="2019-10-22T12:25:40.000Z" itemprop="datePublished">2019-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/22/designPattern3/">设计模式（三）行为型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是参照 <a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a>和 <a target="_blank" rel="noopener" href="http://www.phperz.com/article/15/0814/148654.html">设计模式</a>总结的设计模式学习系列博客（三）。</p>
<h1 id="一-观察者模式"><a href="#一-观察者模式" class="headerlink" title="一. 观察者模式"></a>一. 观察者模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li><p>一对多依赖关系，subject的state一旦改变，所有observers均会受到通知，做出响应</p>
</li>
<li><p>又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>
</li>
<li><p>分类：</p>
<ul>
<li>push模式：subject向observer推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</li>
<li>pull模式：subject推送少量信息，observer接收到通知，如果需要，自行去拉取</li>
<li>区分：update()方法传递了参数的：push。</li>
</ul>
</li>
<li><p>应用：典型的MVC设计模式是基于 观察者模式， model是subject，view是observer，controller是两者之间的中介mediator。当model数据改变时，view将自动改变其显示内容。</p>
</li>
</ul>
<h2 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191021220805.png" alt="观察者模式"></p>
<h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h2><ul>
<li>类图中拉取模型的<a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/ObserverPattern/example">例子</a>： </li>
<li>使用jdk自带的observer包的:<a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/ObserverPattern/defaultClass">例子</a> </li>
</ul>
<h1 id="二-策略模式"><a href="#二-策略模式" class="headerlink" title="二.策略模式"></a>二.策略模式</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>不用硬编码（if…else; 或者将方法放在一个类中，用写死的方法名称调用），怎么管理“算法簇”</li>
<li>将每一个算法封装在一个类中，称一个“策略”,为了保证策略有规范，实现同一个 “策略接口”</li>
<li>官方定义：策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</li>
<li>角色：<ul>
<li>Context: 环境类</li>
<li>Strategy: 抽象策略类</li>
<li>ConcreteStrategy: 具体策略类</li>
</ul>
</li>
</ul>
<h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191022161431.png" alt="策略模式举例"></p>
<ul>
<li><p>三种不同的策略实现自同一个接口，Context含有这个策略，但是执行方法是由策略类的实现类来控制。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd()); <span class="comment">//这里也可以改成反射调用，根据策略名称来调用</span></span><br><span class="line">System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/StrategyPattern">示例代码</a></p>
</li>
<li><p>实用：</p>
<ul>
<li>策略模式包含了几个相同的策略类，可以配合工厂模式使用，利用工厂模式生产出对应的策略。</li>
<li>如果算法是由几个小算法模块流程串联起来的，可以用将Context中保存一个策略的list,循环执行。</li>
</ul>
</li>
</ul>
<h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><ul>
<li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </li>
<li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </li>
<li>JAVA AWT 中的 LayoutManager。</li>
</ul>
<h1 id="3-状态模式"><a href="#3-状态模式" class="headerlink" title="3. 状态模式"></a>3. 状态模式</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>一个对象在其内部状态（一个值）改变时改变它的行为</li>
<li>省略大if…else</li>
<li>角色<ul>
<li>Context 环境类：就是状态管理器(state Manager), 可以在环境类中对状态进行<strong>切换</strong>操作。</li>
<li>State 抽象类</li>
<li>具体State实现类</li>
</ul>
</li>
</ul>
<h2 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2. 类图"></a>2. 类图</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191023153455.png" alt="状态模式"></p>
<ul>
<li>Context<ul>
<li>持有State状态</li>
<li>changeState() 在环境类中可以切换状态</li>
<li>reuqest() 调用具体状态的方法</li>
</ul>
</li>
<li>State<ul>
<li>handle() 该状态实现类根据自己的状态处理的方法</li>
</ul>
</li>
</ul>
<h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3. 举例"></a>3. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191023155255.png" alt="TCP statePattern"></p>
<ul>
<li>适合于状态转移的场景</li>
<li>工作流：尚未办理，正在办理，正在批示，正在审核；游戏</li>
</ul>
<h1 id="4-责任链模式"><a href="#4-责任链模式" class="headerlink" title="4.责任链模式"></a>4.责任链模式</h1><h2 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li><p>每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
</li>
<li><p>职责链将请求的发送者和请求的处理者解耦，请求的发送者无需关系请求处理的细节。请求被层层传递，直到可以被处理为止。</p>
</li>
<li><p>在处理消息的时候以过滤很多道</p>
</li>
<li><p>补充：</p>
<ul>
<li>责任链可能是一条直线，一个环链或者树状结构的一部分。</li>
</ul>
</li>
<li><p>应用：</p>
<ul>
<li>web中使用责任链较多，例如 Filter， 对erquest和 response的过滤。</li>
</ul>
</li>
<li><p>示意图：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/photo_2019-10-24_16-24-41.jpg" alt="责任链模式示意图"></p>
</li>
</ul>
<h2 id="2-举例类图"><a href="#2-举例类图" class="headerlink" title="2. 举例类图"></a>2. 举例类图</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191024163248.png" alt="责任链模式"></p>
<ul>
<li>链表的方式，先建立，安插好一条责任链。</li>
<li>关键：AbstractLogger的 Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</li>
<li>也可以用一个 chainManager 来保存 这条链，而不是元素之间 串起来。 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/10/22/designPattern3/" data-id="ckebizjwd000q647k5bwx6l53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-designPattern2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/21/designPattern2/" class="article-date">
  <time datetime="2019-10-21T10:18:38.000Z" itemprop="datePublished">2019-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/21/designPattern2/">设计模式（二）结构型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是参照 <a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a>和 <a target="_blank" rel="noopener" href="http://www.phperz.com/article/15/0814/148654.html">设计模式</a>总结的设计模式学习系列博客（二）。</p>
<h1 id="一-适配器模式"><a href="#一-适配器模式" class="headerlink" title="一. 适配器模式"></a>一. 适配器模式</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li><p>类似于电源适配器的设计和编码技巧被称为适配器模式</p>
</li>
<li><p>现有的类提供了客户想要的功能，但是接口格式不是客户想要的，这种情况下，写一个适配器类即可。</p>
</li>
<li><p>成员：</p>
<ul>
<li>Target：目标抽象类</li>
<li>Adapter：适配器类</li>
<li>Adaptee：适配者类</li>
<li>Client：客户类</li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li>类适配器：</li>
<li>对象适配器</li>
<li>缺省适配器</li>
</ul>
</li>
<li><p>经典应用：</p>
<p>  Sun公司在1996年公开了Java语言的数据库连接工具JDBC，JDBC使得Java语言程序能够与数据库连接，并使用SQL语言来查询和操作数据。JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。抽象的JDBC接口和各个数据库引擎API之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p>
</li>
</ul>
<h2 id="2-类适配器"><a href="#2-类适配器" class="headerlink" title="2. 类适配器"></a>2. 类适配器</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191021171812.png" alt="类适配器"></p>
<ul>
<li>Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的</li>
<li>是静态的定义方式</li>
</ul>
<h2 id="3-对象适配器"><a href="#3-对象适配器" class="headerlink" title="3. 对象适配器"></a>3. 对象适配器</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191021172326.png" alt="对象适配器"></p>
<ul>
<li>Adapter与Adaptee是委派关系，这决定了适配器模式是对象的</li>
<li>是动态组合的方式</li>
</ul>
<h2 id="4-缺省适配器"><a href="#4-缺省适配器" class="headerlink" title="4. 缺省适配器"></a>4. 缺省适配器</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191021173028.png" alt="缺省适配器"></p>
<ul>
<li>为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。</li>
<li>举例：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">鲁智深和尚</a></li>
</ul>
<h2 id="5-举例"><a href="#5-举例" class="headerlink" title="5. 举例"></a>5. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191021193707.png" alt="举例"></p>
<ul>
<li>client使用者，server提供服务。</li>
<li>clientPlayer 想使用 serverPlayer的某个功能，但是接口不匹配</li>
<li>通过添加Adapter， 将serverPlayer的功能适配到 client上使用 </li>
</ul>
<h1 id="二-装饰者模式"><a href="#二-装饰者模式" class="headerlink" title="二. 装饰者模式"></a>二. 装饰者模式</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>子类复子类，子类何其多</li>
<li>给一个类或者对象添加多的行为，不想用“继承”的方式，可以选择“关联”的方式</li>
<li>将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li>
<li>成员<ul>
<li>Component: 抽象构件</li>
<li>ConcreteComponent: 具体构件</li>
<li>Decorator: 抽象装饰类</li>
<li>ConcreteDecorator: 具体装饰类</li>
</ul>
</li>
<li>装饰器模式强就抢在：可以级联几个装饰器，来任意组装、叠加： 例如IO流； 例如：MyBatis的缓存模块</li>
</ul>
<h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3. 举例"></a>3. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191022113802.png" alt="装饰者模式举例"></p>
<ul>
<li>想给 Circle 的 draw方法 增加一些行为，但是不希望继承Circle，对Circle不造成影响</li>
<li>增加一个 RedShapeDecoprator, ，持有circle对象，并改写其draw方法，在draw方法中增加“红边框颜色”这个行为。</li>
<li>Circle与RedShapeDecorator上层类有一些联系（shape,ShapeDecorator）保证了规范。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/DecoratorPattern">代码</a></li>
</ul>
<h1 id="三-外观模式-门面模式"><a href="#三-外观模式-门面模式" class="headerlink" title="三. 外观模式/门面模式"></a>三. 外观模式/门面模式</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>门面模式提供一个高层次的接口，使得外部不需要感知内部各种子系统的细节，通过统一的门面对象进行交互。</li>
<li>遵循了“迪米特法则”，违背了“开闭原则”。</li>
<li>拓展<ul>
<li>外观类不为子系统增加新行为</li>
<li>遵循“迪米特法则”：一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合度；外观模式降低了 其他模块对于本模块子系统的耦合度</li>
<li>违背了“开闭原则”：对新增开放，对修改关闭（子系统增加或者修改时，要改外观类），解决方式是：面向接口编程，添加接口外观类。 client程序根据接口外观类在编写，本系统子系统发生改变时，直接替换掉原有外观类即可。不会影响client程序的依赖。</li>
</ul>
</li>
</ul>
<h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191030124155.png" alt="外观模式"></p>
<ul>
<li>将子系统画形状的三个实现类，用一个ShapeMaker来统一管理，ShapeMaker持有三个实现类的对象，分发并调用对应的功能。</li>
<li>外观模式，不添加新的功能，只起到一个包装，聚合，解耦的作用。</li>
</ul>
<h1 id="四-代理模式"><a href="#四-代理模式" class="headerlink" title="四. 代理模式"></a>四. 代理模式</h1><h2 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>通过聚合（而非继承）的方式，对原有的方法做增强。</li>
<li>与装饰者模式，适配器模式的区别：<ul>
<li>从意义上来说：<ul>
<li>装饰者模式： 为了对原有的类做增强</li>
<li>代理模式  ： 为了对原有的类做增强</li>
<li>适配器模式： 为了对原有类的接口做适配</li>
</ul>
</li>
<li>从实现上来说：<ul>
<li>装饰者模式： 通过新增类中，增加新的方法 </li>
<li>代理模式  ： 通过新增类中，增强原有方法（一般在方法前后增加一些功能，aop）</li>
<li>适配器模式： 通过新增类中，新增方法（是实现了client端的接口）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-举例-1"><a href="#2-举例-1" class="headerlink" title="2. 举例"></a>2. 举例</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191104145910.png" alt="代理模式举例"></p>
<h2 id="3-静态代理"><a href="#3-静态代理" class="headerlink" title="3. 静态代理"></a>3. 静态代理</h2><ul>
<li><p>定义：代理对象和目标对象需要实现一样的接口</p>
</li>
<li><p>缺点：冗余：代理类过多； 不易维护：接口增加方法，目标对象和代理对象都要修改。（不符合开闭原则）</p>
<div id="JDK_PROXY_PATTERN">这里是指定位置</div>

</li>
</ul>
<h2 id="4-JDK动态代理"><a href="#4-JDK动态代理" class="headerlink" title="4. JDK动态代理"></a>4. JDK动态代理</h2><h3 id="4-1-原理："><a href="#4-1-原理：" class="headerlink" title="4.1 原理："></a>4.1 原理：</h3><ul>
<li><p>定义：利用JDK提供的API, 动态地在内存中构建代理对象，从而实现对目标对象的代理功能。又称JDK代理或者接口代理。</p>
</li>
<li><p>优势：不需要新建代理类，而是动态构建。（减少冗余）</p>
</li>
<li><p>动态代理模式原理：</p>
<ul>
<li>不手动新建代理类，而是由 jdk &gt; rt.jar &gt; reflect包下的 两个类提供辅助功能： Proxy, InvocationHandler</li>
<li>Proxy.newProxyInstance( ): 运行时生成 实现了被代理接口的proxy类，proxy中聚合有 InvocationHandler接口的实现类。并且动态地加载到内存中。</li>
<li>调用被代理对象，实际上调用的是 proxy对象（这里是通过多态实现，由于被代理对象和proxy对象均实现了target接口，创建对象的实际类型是 $proxy ）。 调用 target的实现类的 目标方法，实际是调用 proxy类中的的经过增强的invoke()方法，在此invoke()方法中，运用<strong>反射</strong>调用了 被代理对象的 目标方法。</li>
</ul>
</li>
<li><p>动态代理的流程：</p>
<ol>
<li>Proxy.newProxyInstance( ): 创建实现了target接口的proxy对象。</li>
<li>MyInvocationHandler.invoke( ): 调用target接口的实现类的目标方法，实际调用的是 InvocationHandler的实现类MyInvocationHandler的invoke方法。 </li>
</ol>
</li>
</ul>
<h3 id="4-2-实例："><a href="#4-2-实例：" class="headerlink" title="4.2 实例："></a>4.2 实例：</h3><ul>
<li>使用示例：<a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/ProxyPattern/DynamicProxy">代码</a></li>
<li>例子中的流程解析：<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191104223802.png" alt="动态代理模式示意图"><ul>
<li>第一步：首先动态创建myProxy类，此类中聚合了MyInvocationHandler, MyInvocationHandler中的invoke方法即是强化方法。</li>
<li>第二步： 调用MyInvocationHandler.invoke(),会通过反射调用UserDao的真实save方法。</li>
</ul>
</li>
</ul>
<h2 id="5-cglib代理（Code-Generation-Library）"><a href="#5-cglib代理（Code-Generation-Library）" class="headerlink" title="5. cglib代理（Code Generation Library）"></a>5. cglib代理（Code Generation Library）</h2><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><ul>
<li><p>定义：对于对象行为增强的方式一般有两种，一种是聚合，一种是继承，cglib采用继承的方式，动态地生成target类的子类，来进行对象行为的增强。使用的</p>
</li>
<li><p>区别：</p>
<ul>
<li><p>JDK动态代理：采用聚合的方式增强，缺点是必须有接口类。生成的类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$Proxy4</span><br></pre></td></tr></table></figure></li>
<li><p>cglib代理：采用继承的方式增强，对代理类无侵入。生成的类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao$$EnhancerByCGLIB$$<span class="number">552188</span>b6</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="5-2-实例"><a href="#5-2-实例" class="headerlink" title="5.2 实例"></a>5.2 实例</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zhutianpeng/design-pattern-example/tree/master/src/main/java/ProxyPattern/cglibDynamicProxy">代码</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/10/21/designPattern2/" data-id="ckebizjwc000p647k7dly2qp8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-designPattern1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/20/designPattern1/" class="article-date">
  <time datetime="2019-10-20T12:21:40.000Z" itemprop="datePublished">2019-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/20/designPattern1/">设计模式（一）创建型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是参照 <a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a>和 <a target="_blank" rel="noopener" href="http://www.phperz.com/article/15/0814/148654.html">设计模式</a>总结的设计模式学习系列博客（一）。</p>
<h1 id="零-先导知识"><a href="#零-先导知识" class="headerlink" title="零. 先导知识"></a>零. 先导知识</h1><h2 id="1-设计模式分类"><a href="#1-设计模式分类" class="headerlink" title="1. 设计模式分类"></a>1. 设计模式分类</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191022103422.png" alt="设计模式"></p>
<h2 id="2-设计模式的六个原则"><a href="#2-设计模式的六个原则" class="headerlink" title="2. 设计模式的六个原则"></a>2. 设计模式的六个原则</h2><ul>
<li><p><strong>单一职责原则</strong>：</p>
<ul>
<li>定义： 一个类或者一个接口只负责唯一项职责，尽量设计出功能单一的接口；</li>
<li>梗概： 职责单一</li>
<li>举例： 一个 getUserById的方法，不应当包含建立数据库连接、写日志等功能。</li>
</ul>
</li>
<li><p><strong>依赖倒转原则</strong>：</p>
<ul>
<li>定义：高层模块不应该依赖低层模块具体实现，解耦高层与低层。既面向接口编程，当实现发生变化时，只需提供新的实现类，不需要修改高层模块代码;</li>
<li>梗概：面向接口编程</li>
<li>举例：jdbc</li>
</ul>
</li>
<li><p><strong>开放-封闭原则</strong>：</p>
<ul>
<li>定义：程序对外扩展开放，对修改关闭；换句话说，当需求发生变化时，我们可以通过添加新模块来满足新需求，而不是通过修改原来的实现代码来满足新需求；</li>
<li>梗概：少改已有的代码，可以新增。 </li>
</ul>
</li>
<li><p><strong>迪米特法则</strong>：</p>
<ul>
<li>定义：一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合度；</li>
<li>梗概：解耦合</li>
<li>举例：外观模式</li>
</ul>
</li>
<li><p>里氏代换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象；</p>
</li>
<li><p>接口隔离原则：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上；</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/10/20/designPattern1/" data-id="ckebizjwb000m647k0u9fgevg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-redis2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/redis2/" class="article-date">
  <time datetime="2019-09-19T07:53:55.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/redis2/">redis系列（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了深入学习 <strong>redis相关知识</strong> 的系统，开始了<a target="_blank" rel="noopener" href="https://ke.qq.com/course/442946?tuin=7b6410e7">享学课堂</a>的学习。 注：仅用于个人的学习记录。</p>
<h1 id="3-redis五种数据类型的应用"><a href="#3-redis五种数据类型的应用" class="headerlink" title="3. redis五种数据类型的应用"></a>3. redis五种数据类型的应用</h1><h2 id="1-String应用"><a href="#1-String应用" class="headerlink" title="1. String应用"></a>1. String应用</h2><h3 id="1-INCR原子性操作："><a href="#1-INCR原子性操作：" class="headerlink" title="1. INCR原子性操作："></a>1. INCR原子性操作：</h3><ul>
<li>文章浏览数 ++ ：在多操作（先读再写）的情况下不会重复出错（需要保证操作的原子性）</li>
<li>论坛回帖数 ++ ：先进行redis中的帖子数 INCR, 会返回加完的值，然后去写库，保证不会有重复的帖子序号出现。</li>
</ul>
<h3 id="2-数据库主键自增的实现（类似auto-increment）"><a href="#2-数据库主键自增的实现（类似auto-increment）" class="headerlink" title="2. 数据库主键自增的实现（类似auto increment）"></a>2. 数据库主键自增的实现（类似auto increment）</h3><ul>
<li>redis是单线程模型，如果大量的请求（比如10万）同时到达，都要获取自己的序号（主键），redis会排队执行，但是速度较慢。 解决方法是： 在web server前端加上nginx分流，分到不同的server上，再去请求redis的时候，redis直接返回1<del>1000个序号给server1,并缓存在server本地（预生成），redis返回 1001</del>2000给server2,并缓存在server2上… 这样可以节省redis的吞吐量。</li>
</ul>
<h3 id="3-session共享"><a href="#3-session共享" class="headerlink" title="3. session共享"></a>3. session共享</h3><ul>
<li>session信息存在redis里，多台机器能获取到一个用户的同一个session信息。</li>
</ul>
<h3 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h3><ul>
<li><p>问题：为了分布式中解决重复调用的问题（可能是调用一个远端的服务）。（单机中的防止重复调用，直接加锁，比如synchronized即可，但是无法解决分布式环境下的问题。）</p>
</li>
<li><p>解决：将单机的锁升级为分布式锁。 -&gt; 使用redis实现分布式锁。</p>
</li>
<li><p>设计：</p>
<ul>
<li>加锁： SETNX + 缓存有效期 </li>
<li>解锁： LUA脚本</li>
</ul>
</li>
<li><p>解释： </p>
<ul>
<li><p>锁的表示【SETNX】： set if not exist, 成功插入则返回1， key存在则返回0。 以此作为锁，set成功则拿到锁；失败则表示锁此时被人占用。</p>
</li>
<li><p>解决死锁【缓存有效期】：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx ticket 123615243123654 px 1;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>表示这把锁最长维持1s，需要在这段时间能完成业务，否则自动key失效，相当于自动是释放了锁
- 解锁【lua脚本】：主要为了保持操作的整体原子性，包含三个操作：
    - 获取数据
    - 判断一致性
    - 删除数据</code></pre>
<ul>
<li>实现：</li>
</ul>
<p>RedisLock实现Lock接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String  KEY = <span class="string">&quot;LOCK_KEY&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> JedisConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//阻塞式的加锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1.尝试加锁</span></span><br><span class="line">		<span class="keyword">if</span>(tryLock())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.加锁失败，当前任务休眠一段时间</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);<span class="comment">// 性能浪费</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.递归调用，再次去抢锁</span></span><br><span class="line">		lock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//阻塞式加锁,使用setNx命令返回OK的加锁成功，并生产随机值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//产生随机值，标识本次锁编号</span></span><br><span class="line">		String uuid = UUID.randomUUID().toString();</span><br><span class="line">		Jedis jedis = (Jedis) factory.getConnection().getNativeConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * key:我们使用key来当锁</span></span><br><span class="line"><span class="comment">		 * uuid:唯一标识，这个锁是我加的，属于我</span></span><br><span class="line"><span class="comment">		 * NX：设入模式【SET_IF_NOT_EXIST】--仅当key不存在时，本语句的值才设入</span></span><br><span class="line"><span class="comment">		 * PX：给key加有效期</span></span><br><span class="line"><span class="comment">		 * 1000：有效时间为 1 秒</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String ret = jedis.set(KEY, uuid,<span class="string">&quot;NX&quot;</span>,<span class="string">&quot;PX&quot;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设值成功--抢到了锁</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;OK&quot;</span>.equals(ret))&#123;</span><br><span class="line">			local.set(uuid);<span class="comment">//抢锁成功，把锁标识号记录入本线程--- Threadlocal</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//key值里面有了，我的uuid未能设入进去，抢锁失败</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正确解锁方式</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//读取lua脚本</span></span><br><span class="line">		String script = FileUtils.getScript(<span class="string">&quot;unlock.lua&quot;</span>);</span><br><span class="line">		<span class="comment">//获取redis的原始连接</span></span><br><span class="line">		Jedis jedis = (Jedis) factory.getConnection().getNativeConnection();</span><br><span class="line">		<span class="comment">//通过原始连接连接redis执行lua脚本</span></span><br><span class="line">		jedis.eval(script, Arrays.asList(KEY), Arrays.asList(local.get()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//-----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//模拟卖票业务处理</span></span><br><span class="line">        amount++;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解锁的Lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Hash应用"><a href="#2-Hash应用" class="headerlink" title="2. Hash应用"></a>2. Hash应用</h2><h3 id="1-保存对象-gt-淘宝购物车的实现"><a href="#1-保存对象-gt-淘宝购物车的实现" class="headerlink" title="1. 保存对象 -&gt; 淘宝购物车的实现"></a>1. 保存对象 -&gt; 淘宝购物车的实现</h3><ul>
<li><p>需求：</p>
<ul>
<li>全选购物车中的商品</li>
<li>获取购物车商品数量</li>
<li>删除购物车商品</li>
<li>增加或减少商品的数量</li>
</ul>
</li>
<li><p>使用hash来实现，当前登录用户ID号做为KEY，商品ID号为Field, 加入购物车数量为value。</p>
</li>
<li><p>每次增量操作时，先操作db，再操作redis，保证原子性；其中操作redis的方式就是上述提供的操作hash的方式。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:001 product:01 1 product:02 1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-List应用"><a href="#3-List应用" class="headerlink" title="3. List应用"></a>3. List应用</h2><h3 id="1-实现队列、栈、阻塞队列"><a href="#1-实现队列、栈、阻塞队列" class="headerlink" title="1. 实现队列、栈、阻塞队列"></a>1. 实现队列、栈、阻塞队列</h3><ul>
<li>队列：lpush + rpop</li>
<li>栈：lpush + lpop</li>
<li>阻塞队列 blockqueue：lpush + brpop （监听，如果有消息就接收，没有消息阻塞监听）</li>
</ul>
<h3 id="2-微信公众号订阅文章（用redis的List实现）"><a href="#2-微信公众号订阅文章（用redis的List实现）" class="headerlink" title="2. 微信公众号订阅文章（用redis的List实现）"></a>2. 微信公众号订阅文章（用redis的List实现）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CSDN发布了一条消息ID为999</span><br><span class="line">lpush mes:004 999</span><br><span class="line"></span><br><span class="line"># 男子别输在说话上也发布了一条消息ID为1000</span><br><span class="line">lpush mes:004 1000</span><br><span class="line"></span><br><span class="line"># 那么左图Lison老师的微信消息列表实现如下</span><br><span class="line">lrange mes:004 0 5</span><br></pre></td></tr></table></figure>

<h2 id="4-Set应用"><a href="#4-Set应用" class="headerlink" title="4. Set应用"></a>4. Set应用</h2><h3 id="1-set集合的元素不重复性"><a href="#1-set集合的元素不重复性" class="headerlink" title="1. set集合的元素不重复性"></a>1. set集合的元素不重复性</h3><ul>
<li><p>抽奖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 当Lison点击参与抽奖时，数据放入set集合</span><br><span class="line">sadd act:001  004</span><br><span class="line"></span><br><span class="line"># 开始抽奖2名中奖者</span><br><span class="line">srandmember act:001 2 或 spop act:001 2</span><br><span class="line"></span><br><span class="line"># 查看有多少用户参加了本次抽奖</span><br><span class="line">smembers act:001</span><br></pre></td></tr></table></figure>
</li>
<li><p>点赞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 张三用户ID 为userId:01</span><br><span class="line"></span><br><span class="line"># 1）张三对消息ID008点赞</span><br><span class="line">sadd zan:008  userId:01</span><br><span class="line"></span><br><span class="line"># 2)张三取消了对消息008的点赞</span><br><span class="line">srem zan:008  userId:01</span><br><span class="line"></span><br><span class="line"># 3）检查用户是否点过赞</span><br><span class="line">sismember zan:008  userId:01</span><br><span class="line"></span><br><span class="line"># 4）获取消息ID008所有的点赞用户列表</span><br><span class="line">smembers zan:008</span><br><span class="line"></span><br><span class="line"># 5）消息ID008的点赞数计算</span><br><span class="line">scard zan:008</span><br></pre></td></tr></table></figure>
</li>
<li><p>投票，黑名单</p>
</li>
</ul>
<h3 id="2-set集合的集合运算性（交并补）"><a href="#2-set集合的集合运算性（交并补）" class="headerlink" title="2. set集合的集合运算性（交并补）"></a>2. set集合的集合运算性（交并补）</h3><p>举例：微博的微关系设计</p>
<h2 id="5-zset应用"><a href="#5-zset应用" class="headerlink" title="5. zset应用"></a>5. zset应用</h2><h3 id="1-zset的集合性"><a href="#1-zset的集合性" class="headerlink" title="1. zset的集合性"></a>1. zset的集合性</h3><ul>
<li>元素不重复</li>
<li>集合运算：交并补</li>
</ul>
<h3 id="2-zset的可排序性"><a href="#2-zset的可排序性" class="headerlink" title="2. zset的可排序性"></a>2. zset的可排序性</h3><p>百度热度榜,排行榜</p>
<ul>
<li>将日期作为Key</li>
<li>按照点赞数排序,解决数据库排序的压力</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1)点击话题</span><br><span class="line">zincrby topic:20190912 1 军嫂怒怼张馨予</span><br><span class="line"></span><br><span class="line"># 2)右侧排行实现,展示今日前9排名</span><br><span class="line">zrevrange  topic:20190912 0 20  withscores</span><br><span class="line"></span><br><span class="line"># 3)统计近3日点击数据(集合运算：求并集)</span><br><span class="line">zunionstore topic:3day 3  topic:20190910  topic:20190911 topic:20190912</span><br><span class="line"></span><br><span class="line"># 4)展示近3日的排行前9名</span><br><span class="line">zrevrange topic:20190910-20190912 0 9  withscores</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/19/redis2/" data-id="ckebizjwm001d647k192k17u9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/17/redis/" class="article-date">
  <time datetime="2019-09-17T14:33:14.000Z" itemprop="datePublished">2019-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/17/redis/">redis系列（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为了深入学习 <strong>redis相关知识</strong> 的系统，开始了<a target="_blank" rel="noopener" href="https://ke.qq.com/course/442946?tuin=7b6410e7">本课程</a>的学习。 </p>
<h1 id="1-redis快速入门"><a href="#1-redis快速入门" class="headerlink" title="1. redis快速入门"></a>1. redis快速入门</h1><h2 id="1-redis的特性："><a href="#1-redis的特性：" class="headerlink" title="1. redis的特性："></a>1. redis的特性：</h2><ul>
<li>速度快：基于内存型存储</li>
<li>基于键值对的数据结构服务器</li>
<li>数据类型比较丰富：<ul>
<li>key：String</li>
<li>value: String, hash, list, set, zset</li>
</ul>
</li>
<li>简单稳定</li>
<li>持久化</li>
<li>主从复制</li>
<li>高可用和分布式转移</li>
<li>客户端API较多<ul>
<li>java：Jedis</li>
</ul>
</li>
</ul>
<h2 id="2-redis的应用场景"><a href="#2-redis的应用场景" class="headerlink" title="2. redis的应用场景"></a>2. redis的应用场景</h2><ul>
<li>缓存数据库</li>
<li>排行榜</li>
<li>计数器应用</li>
<li>社交网络</li>
<li>消息队列</li>
<li>分布式锁</li>
<li>session共享</li>
</ul>
<h2 id="3-redis的相关配置文件说明"><a href="#3-redis的相关配置文件说明" class="headerlink" title="3. redis的相关配置文件说明"></a>3. redis的相关配置文件说明</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918134934.png" alt="redis的相关配置文件说明"></p>
<ul>
<li>linux关闭redis的方式<ul>
<li>错误方式：直接kill进程，会丢失数据</li>
<li>正确方式：./redis-cli -h 192.168.xx.xx -p 6379 -a xxxx shutdown，  数据不会丢失</li>
</ul>
</li>
</ul>
<h1 id="2-redis五种数据结构"><a href="#2-redis五种数据结构" class="headerlink" title="2. redis五种数据结构"></a>2. redis五种数据结构</h1><h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><p>常用指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ex：10秒后过期</span><br><span class="line">set age 23 ex 10 </span><br><span class="line"># ttl： 查看此 key的有效时间</span><br><span class="line">ttl age</span><br><span class="line"></span><br><span class="line"># setnx: set if not exist （如果key不存在则set，返回1；key存在则不进行任何操作，返回0） </span><br><span class="line">setnx name test</span><br><span class="line"></span><br><span class="line"># 批量设值</span><br><span class="line">mset country china city beijing address haidian (设置了三个键值对)</span><br><span class="line"># 批量获取</span><br><span class="line">mget country city address</span><br><span class="line"></span><br><span class="line"># 原子性操作</span><br><span class="line">incr age                # 整数自增，非整数则返回错误，无此key则会先set</span><br><span class="line">decr age                # 整数自减</span><br><span class="line">incrby age 2            # 以2自增</span><br><span class="line">decrby age 2            # 以2自减</span><br><span class="line">incrbyfloat score 1.1   # 以浮点数自增</span><br></pre></td></tr></table></figure>

<h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918163212.png" alt="Hash数据存储"></p>
<p>类似这种数据存储，String可是实现，但是会出现Key值的冗余多占存储空间。而hash比较适合“对象类型存储”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 设置key为 user:1,  value为一个field(map)，其中name：james； age：18</span><br><span class="line">hmset user:1 name james age18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令   hset key field value</span><br><span class="line"></span><br><span class="line">设值：hset user:1 name james           &#x2F;&#x2F;成功返回1，失败返回0</span><br><span class="line">取值：hget user:1 name                 &#x2F;&#x2F;返回james</span><br><span class="line">删值：hdel user:1 age                  &#x2F;&#x2F;返回删除的个数</span><br><span class="line">计算个数：hset user:1 name james; hset user:1 age 23; </span><br><span class="line">         hlen user:1                  &#x2F;&#x2F;返回2，user:1有两个属性值</span><br><span class="line">批量设值：hmset user:2 name james age 23 sex boy &#x2F;&#x2F;返回OK</span><br><span class="line">批量取值：hmget user:2 name age sex    &#x2F;&#x2F;返回三行：james 23 boy</span><br><span class="line">判断field是否存在：hexists user:2 name &#x2F;&#x2F;若存在返回1，不存在返回0</span><br><span class="line">获取所有field: hkeys user:2            &#x2F;&#x2F; 返回name age sex三个field</span><br><span class="line">获取user:2所有value：hvals user:2     &#x2F;&#x2F; 返回james 23 boy</span><br><span class="line">获取user:2所有field与value：hgetall user:2 &#x2F;&#x2F;name age sex james 23 boy值</span><br><span class="line">增加1： hincrby user:2 age 1          &#x2F;&#x2F;age+1</span><br><span class="line">       hincrbyfloat user:2 age 2     &#x2F;&#x2F;浮点型加2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比较：三种方案实现用户信息存储优缺点</p>
<ul>
<li><p>原生：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set user:1:name james; </span><br><span class="line">set user:1:age 23;  </span><br><span class="line">set user:1:sex boy; </span><br></pre></td></tr></table></figure>

<p>  优点：简单直观，每个键对应一个值<br>  缺点：键数过多，占用内存多，用户信息过于分散，不用于生产环境  </p>
</li>
<li><p>将对象序列化存入redis:  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set user:1 serialize(userInfo); </span><br></pre></td></tr></table></figure>

<p>  优点：编程简单，若使用序列化合理内存使用率高<br>  缺点：序列化与反序列化有一定开销，更新属性时需要把userInfo全取出来进行反序列化，更新后再序列化到redis  (操作简单但是更新难)</p>
</li>
<li><p>使用hash类型：  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name james age 23 sex boy  </span><br></pre></td></tr></table></figure>

<p>  优点：简单直观，使用合理可减少内存空间消耗<br>  缺点：要控制ziplist与hashtable两种编码转换，且hashtable会消耗更多内存erialize(userInfo);  </p>
</li>
</ul>
<h2 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918165946.png" alt="list"></p>
<ul>
<li>用来存储多个有序的字符串，一个列表最多可存2的32次方减1个元素</li>
<li>lpush从左侧插值，rpush从右侧插值</li>
<li>有序：可以通过索引下标获取元素或某个范围内元素列表，列表元素可以重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">添加命令：</span><br><span class="line"> rpush james c b a &#x2F;&#x2F;从右向左插入cba, 返回值3</span><br><span class="line"> lrange james 0 -1 &#x2F;&#x2F;从左到右获取列表所有元素 返回 c b a</span><br><span class="line"> lpush key c b a &#x2F;&#x2F;从左向右插入cba</span><br><span class="line"> linsert james before b teacher &#x2F;&#x2F;在b之前插入teacher, after为之后，使					                用lrange james 0 -1 查看：c teacher b a</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">查找命令：</span><br><span class="line"> lrange key start end &#x2F;&#x2F;索引下标特点：从左到右为0到N-1</span><br><span class="line"> lindex james -1 &#x2F;&#x2F;返回最右末尾a，-2返回b</span><br><span class="line"> llen james        &#x2F;&#x2F;返回当前列表长度</span><br><span class="line"> lpop james       &#x2F;&#x2F;把最左边的第一个元素c删除</span><br><span class="line"> rpop james      &#x2F;&#x2F;把最右边的元素a删除</span><br></pre></td></tr></table></figure>

<h2 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. set</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918171115.png" alt="set"></p>
<ul>
<li>应用场景：用户标签（求集合交集），社交，查询有共同兴趣爱好的人（求集合交集）,智能推荐</li>
<li>多元素，不重复，无序，</li>
<li>一个集合最多可存2的32次方减1个元素，除了支持增删改查，还支持集合运算：交集、并集、差集；</li>
</ul>
<p>基础操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exists user             &#x2F;&#x2F;检查user键值是否存在</span><br><span class="line">sadd user a b c         &#x2F;&#x2F;向user插入3个元素，返回3</span><br><span class="line">sadd user a b           &#x2F;&#x2F;若再加入相同的元素，则重复无效，返回0</span><br><span class="line">smember user            &#x2F;&#x2F;获取user的所有元素,返回结果无序</span><br><span class="line"></span><br><span class="line">srem user a             &#x2F;&#x2F;返回1，删除a元素</span><br><span class="line"></span><br><span class="line">scard user              &#x2F;&#x2F;返回2，计算元素个数</span><br></pre></td></tr></table></figure>

<p>集合运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">标签，社交，查询有共同兴趣爱好的人,智能推荐</span><br><span class="line">使用方式：</span><br><span class="line">给用户添加标签：</span><br><span class="line">  sadd user:1:fav basball fball pq</span><br><span class="line">  sadd user:2:fav basball fball   </span><br><span class="line"> </span><br><span class="line">或给标签添加用户</span><br><span class="line">  sadd basball:users user:1 user:2</span><br><span class="line">  sadd fball:users user:1 user:2</span><br><span class="line"> </span><br><span class="line">计算出共同感兴趣的人：</span><br><span class="line">  sinter user:1:fav user2:fav</span><br></pre></td></tr></table></figure>

<h2 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918173717.png" alt="sort set"></p>
<ul>
<li>常用于排行榜，如视频网站需要对用户上传视频做排行榜，或点赞数</li>
<li>与集合有联系，不能有重复的成员,集合中的每一项多了一个权重，可以进行排序</li>
</ul>
<p>普通指令： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member......]</span><br><span class="line">zadd user:zan 200 james                                   &#x2F;&#x2F;james的点赞数1, 返回操作成功的数1</span><br><span class="line">zadd user:zan 200 james 120 mike 100 lee    &#x2F;&#x2F; 返回3</span><br><span class="line">zadd test:1 nx 100 james                     &#x2F;&#x2F;键test:1必须不存在，主用于添加</span><br><span class="line">zadd test:1 xx incr 200 james             &#x2F;&#x2F;键test:1必须存在，主用于修改,此时为300</span><br><span class="line">zadd test:1 xx ch incr -299 james      &#x2F;&#x2F;返回操作结果1，300-299&#x3D;1</span><br><span class="line"></span><br><span class="line">zrange test:1 0 -1 withscores   &#x2F;&#x2F;查看点赞（分数）与成员名</span><br><span class="line"></span><br><span class="line">zcard test:1       &#x2F;&#x2F;计算成员个数， 返回1</span><br></pre></td></tr></table></figure>

<p>排名场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd user:3 200 james 120 mike 100 lee      &#x2F;&#x2F;先插入数据</span><br><span class="line">zrange user:3 0 -1 withscores                         &#x2F;&#x2F;查看分数与成员</span><br><span class="line"></span><br><span class="line">zrank user:3 james           &#x2F;&#x2F;返回名次：第3名返回2，从0开始到2，共3名</span><br><span class="line">zrevrank user:3 james     &#x2F;&#x2F;返回0， 反排序，点赞数越高，排名越前</span><br></pre></td></tr></table></figure>

<p>比较：<br>list vs Set vs sorted set</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190918194618.png" alt="list set zset"></p>
<h2 id="redis全局命令"><a href="#redis全局命令" class="headerlink" title="redis全局命令"></a>redis全局命令</h2><p>redis键的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看所有键：</span><br><span class="line">    keys * </span><br><span class="line">键总数 ：</span><br><span class="line">    dbsize         &#x2F;&#x2F;2个键，如果存在大量键，线上禁止使用此指令</span><br><span class="line">检查键是否存在：</span><br><span class="line">    exists key    &#x2F;&#x2F;存在返回1，不存在返回0</span><br><span class="line">删除键：</span><br><span class="line">    del key      &#x2F;&#x2F;del hello school, 返回删除键个数，删除不存在键返回0</span><br><span class="line">键过期：</span><br><span class="line">    expire key seconds        &#x2F;&#x2F;set name test  expire name 10,表示10秒过期</span><br><span class="line">    ttl key                   &#x2F;&#x2F; 查看剩余的过期时间</span><br><span class="line">键的数据结构类型：</span><br><span class="line">    type key                  &#x2F;&#x2F;返回string,键不存在返回none</span><br></pre></td></tr></table></figure>

<p>redis数据库管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换0号数据库（共0~15）</span><br><span class="line">select 0</span><br><span class="line"># 清空该数据库 （危险操作）</span><br><span class="line">flushdb</span><br><span class="line"># 清空所有数据库（危险操作）</span><br><span class="line">flushall</span><br><span class="line"># 键的总数</span><br><span class="line">dbsize</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/17/redis/" data-id="ckebizjwm001b647k2hfec235" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jianzhi-offer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/jianzhi-offer/" class="article-date">
  <time datetime="2019-09-06T08:49:49.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/jianzhi-offer/">jianzhi_offer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1. 赋值运算符函数"></a>1. 赋值运算符函数</h2><h2 id="2-实现singleton模式"><a href="#2-实现singleton模式" class="headerlink" title="2. 实现singleton模式"></a>2. 实现singleton模式</h2><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><ul>
<li><p>题目：数组里的所有数字都在0到n-1的范围内</p>
</li>
<li><p>法1： set（循环存入set，contains函数判断） </p>
</li>
<li><p>法2： 利用n长度的数组，存储</p>
</li>
</ul>
<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h2><ul>
<li>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</li>
<li>从左下角开始找，大则向右，小则向上</li>
</ul>
<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><ul>
<li>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</li>
<li>解法：直接替换</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/06/jianzhi-offer/" data-id="ckebizjwk0017647kfpn25lwy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ali" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/04/ali/" class="article-date">
  <time datetime="2019-09-04T03:21:35.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/04/ali/">ali</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今年暑假，在阿里巴巴-新零售事业群-供应链平台事业部实习了2个半月的时间。作为后端实习开发，前期主要学习阿里中间件（pandora,hsf,metaq）; 之后投身于到“服务化升级”项目中，设计并实现了“规则转化模块”，参与了“dstunnel下载组件”的升级改造调研。</p>
<h1 id="服务化项目的规则转化模块"><a href="#服务化项目的规则转化模块" class="headerlink" title="服务化项目的规则转化模块"></a>服务化项目的规则转化模块</h1><ul>
<li><p>目的：利用配置化替代手工修改代码：</p>
<ul>
<li>旧版：开发同学 手工添加数据库字段，修改代码实体类定义，重写sql，重跑ODPS生成数据</li>
<li>新版：业务同学 使用配置化的方式，设置规则添加字段，点击运行，前端页面显示</li>
</ul>
</li>
<li><p>挑战：</p>
<ul>
<li>怎么将前端的复杂配置，抽象为代码中可以保存和传递的数据模型；</li>
<li>怎么将模型转化为可以在ODPS平台中可以运行的sql语句。（类似于hive）</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li><p>细化需求，提取相似的结构，抽象成为领域模型（一个结构表示一个同维数据，跨纬数据需要group by来聚合）</p>
</li>
<li><p>分析sql的语法规律，尝试用统一的方式来生成sql： </p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190904104752.png" alt="SQL"></p>
</li>
<li><p>解决了一个 循环依赖的问题</p>
</li>
</ol>
</li>
</ul>
<h1 id="Dstunnel组件优化设计"><a href="#Dstunnel组件优化设计" class="headerlink" title="Dstunnel组件优化设计"></a>Dstunnel组件优化设计</h1><ul>
<li>问题：下载较慢</li>
<li>通过阅读源码，发现项目中存在的问题<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190904105321.png"></li>
<li>问题;<ul>
<li>泛化调用性能较弱。（原因是基础域的公共服务，没有引入其他小组的数据接口的二方包）</li>
<li>metaQ的“串行化”处理可以转为“并行化”处理，先对数据做分片，然后多线程消费。<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190904111446.png"></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/04/ali/" data-id="ckebizjw8000h647k1io9acaw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-并发基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2019-09-03T08:00:35.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/">并发基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903180002.png" alt="进程与线程的比较"></p>
<h2 id="2-进程调度算法"><a href="#2-进程调度算法" class="headerlink" title="2. 进程调度算法"></a>2. 进程调度算法</h2><ul>
<li><p>批处理系统</p>
<ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>最短剩余时间优先</li>
</ul>
</li>
<li><p>交互式系统</p>
<ul>
<li>时间片轮转</li>
<li>优先级调度</li>
<li>多级反馈队列</li>
</ul>
</li>
<li><p>实时系统</p>
</li>
</ul>
<h2 id="3-进程间同步"><a href="#3-进程间同步" class="headerlink" title="3. 进程间同步"></a>3. 进程间同步</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915170015.png" alt="进程间同步"></p>
<h2 id="4-进程间通信"><a href="#4-进程间通信" class="headerlink" title="4. 进程间通信"></a>4. 进程间通信</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915170835.png" alt="进程间通信"></p>
<h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><h2 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190915171216.png" alt="线程的5种状态"></p>
<ul>
<li>创建</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止</li>
</ul>
<p>就绪态 &lt;-&gt; 运行态：</p>
<p>就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
<p>运行态 -&gt; 阻塞态 -&gt; 就绪态：</p>
<p>IO等待，或者手动调用 wait 或者 join 函数；</p>
<p>等待结束，或者notify, notify all.</p>
<h2 id="2-实现多线程的方式"><a href="#2-实现多线程的方式" class="headerlink" title="2. 实现多线程的方式"></a>2. 实现多线程的方式</h2><ul>
<li>实现 Runnable接口</li>
<li>实现 Callable接口</li>
<li>继承 Thread</li>
<li>Executor</li>
</ul>
<h1 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h1><h2 id="1-java内存模型"><a href="#1-java内存模型" class="headerlink" title="1. java内存模型"></a>1. java内存模型</h2><ul>
<li><p>原子性：使用synchronized 和 lock实现</p>
</li>
<li><p>可见性：利用 volatile实现</p>
</li>
<li><p>有序性：利用 happen-before原则实现</p>
</li>
</ul>
<h2 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2. 线程安全"></a>2. 线程安全</h2><ul>
<li><p>不可变：final, String, 枚举类型， Number</p>
</li>
<li><p>阻塞同步（悲观锁）：synchronized, ReentranLock</p>
</li>
<li><p>非阻塞同步（乐观锁）：乐观锁（CAS锁）</p>
</li>
<li><p>无同步方案：栈封闭（局部变量）； 单线程； 可重入 </p>
</li>
</ul>
<h2 id="3-关键词"><a href="#3-关键词" class="headerlink" title="3. 关键词"></a>3. 关键词</h2><ul>
<li><p>volatile: </p>
<ul>
<li>可见性</li>
<li>禁止指令重排</li>
</ul>
</li>
<li><p>Synchronized:</p>
<p>  修饰</p>
<ul>
<li>类： 锁类的所有对象</li>
<li>静态方法： 锁调用这个方法的所有对象</li>
<li>代码块： 锁调用这个方法块的对象</li>
<li>方法： 锁调用这个方法的对象</li>
</ul>
</li>
<li><p>ReentranLock:</p>
<ul>
<li>可重入</li>
<li>condition</li>
<li>公平、非公平</li>
</ul>
</li>
</ul>
<h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><ul>
<li><p>公平锁/非公平锁: 多个线程获取锁的顺序是/不是按照申请锁的顺序</p>
</li>
<li><p>可重入锁： 又叫递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p>
<ul>
<li>ReentrantLock</li>
<li>Synchronized</li>
</ul>
</li>
<li><p>独享锁/共享锁：</p>
<ul>
<li>独享锁是指该锁一次只能被一个线程所持有。ReentrantLock，Synchronized</li>
<li>共享锁是指该锁可被多个线程所持有。ReadWriteLock</li>
</ul>
</li>
<li><p>互斥锁/读写锁：</p>
</li>
</ul>
<ul>
<li><p>乐观锁/悲观锁：</p>
<ul>
<li>悲观锁适合写操作非常多的场景，悲观锁在Java中的使用，就是利用各种锁。</li>
<li>乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
</ul>
</li>
<li><p>分段锁 (细化锁的粒度)</p>
<p>  分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。<br>  当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>  但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。</p>
<p>  分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
</li>
<li><p>偏向锁/轻量级锁/重量级锁: 这三种锁是指锁的状态，并且是针对Synchronized</p>
<ul>
<li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</li>
<li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
</li>
<li><p>自旋锁</p>
<p>  在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
</li>
</ul>
<h1 id="4-并发包：java-util-concurrent"><a href="#4-并发包：java-util-concurrent" class="headerlink" title="4. 并发包：java.util.concurrent"></a>4. 并发包：java.util.concurrent</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/03/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" data-id="ckebizjwy0021647kcyefe3z2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-computer-network" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/02/computer-network/" class="article-date">
  <time datetime="2019-09-02T07:15:54.000Z" itemprop="datePublished">2019-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/02/computer-network/">计算机网络 常见知识点整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903145606.png"><br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903145652.png"><br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903145722.png"></p>
<p><a target="_blank" rel="noopener" href="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20190903145508.png">整图浏览</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="ztxpp.cc/2019/09/02/computer-network/" data-id="ckebizjwa000l647k1xkq5vhg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">dubbo - 微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/financial/" rel="tag">financial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-OOM/" rel="tag">java - OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">java - SpringCloud - 微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-mysql/" rel="tag">java - mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-reflect/" rel="tag">java - reflect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-sort/" rel="tag">java - sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">java - 动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E5%B9%B6%E5%8F%91/" rel="tag">java - 并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-activemq/" rel="tag">中间件 - activemq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BE%9B%E5%BA%94%E9%93%BE/" rel="tag">供应链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" rel="tag">前后端分离</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">牛客网 - 二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%95%B0%E7%BB%84/" rel="tag">牛客网 - 数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E9%93%BE%E8%A1%A8/" rel="tag">牛客网 - 链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE-%E9%9D%A2%E8%AF%95/" rel="tag">项目 - 面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 16px;">Docker</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 18px;">Java</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MySql/" style="font-size: 10px;">MySql</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/dubbo-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">dubbo - 微服务</a> <a href="/tags/financial/" style="font-size: 10px;">financial</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java-OOM/" style="font-size: 10px;">java - OOM</a> <a href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">java - SpringCloud - 微服务</a> <a href="/tags/java-mysql/" style="font-size: 10px;">java - mysql</a> <a href="/tags/java-reflect/" style="font-size: 10px;">java - reflect</a> <a href="/tags/java-sort/" style="font-size: 10px;">java - sort</a> <a href="/tags/java-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">java - 动态规划</a> <a href="/tags/java-%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">java - 并发</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6-activemq/" style="font-size: 10px;">中间件 - activemq</a> <a href="/tags/%E4%BE%9B%E5%BA%94%E9%93%BE/" style="font-size: 10px;">供应链</a> <a href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/" style="font-size: 10px;">前后端分离</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">牛客网 - 二叉树</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E6%95%B0%E7%BB%84/" style="font-size: 10px;">牛客网 - 数组</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E7%BD%91-%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">牛客网 - 链表</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 12px;">读书</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12px;">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE-%E9%9D%A2%E8%AF%95/" style="font-size: 12px;">项目 - 面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/09/threadLearn6/">多线程与高并发（六）Wait-Notify与LockSupport</a>
          </li>
        
          <li>
            <a href="/2020/05/07/threadLearn5-2/">多线程与高并发（五）JUC同步工具(2)</a>
          </li>
        
          <li>
            <a href="/2020/05/06/threadLearn5/">多线程与高并发（五）JUC同步工具(1)</a>
          </li>
        
          <li>
            <a href="/2020/05/01/threadLearn4/">多线程与高并发（四）CAS与Atomic</a>
          </li>
        
          <li>
            <a href="/2020/05/01/threadLearn3/">多线程与高并发（三）Volatile关键字</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 zhutianpeng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>