<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/default" title="Ztxpp's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="ztxpp.cc/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Ztxpp's Blog</title>
  <meta name="generator" content="Hexo 5.1.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ztxpp's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/Base/">
        <li class="mobile-menu-item">文档
          </li>
      </a><a href="/life/">
        <li class="mobile-menu-item">生活
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ztxpp's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/Base/">
            文档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/life/">
            生活
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/09/threadLearn6/">多线程与高并发（六）Wait-Notify与LockSupport</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-09
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>前文讲述了JUC同步器的用法，JUC同步器大都使用AQS作为实现方式。而java锁和同步器框架的核心AQS，就是通过LockSupport的<code>park()</code>、<code>unpark()</code>方法，来实现线程的阻塞和唤醒的。因此，本文关注<code>LockSupport</code>类的用法，以及其与<code>Object</code>类的<code>Wait()</code>、<code>Notify()</code>方法之间的区别（因为两者都能实现最基本的对线程的阻塞和唤醒）。最后比较了基于<code>synchronized</code>的<code>wait-notify</code>与基于<code>reentrantLock</code>的<code>Condition</code>的<code>await-signal</code>之间的区别。</p>
</blockquote>
<p>（六）Wait-Notify与LockSupport</p>
<h1 id="Wait-Notify"><a href="#Wait-Notify" class="headerlink" title="Wait-Notify"></a>Wait-Notify</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li><code>wait()</code>、<code>notify()</code>方法都要在<code>synchronized</code>块中使用，否则会抛出异常。三者使用的对象必须一致。</li>
<li><code>wait()</code>会释放锁。</li>
<li><code>notify()</code>并不会释放锁，得等<code>synchronized</code>块结束，才会释放锁。</li>
<li><strong>线程A处于<code>wait()</code>状态时，其他线程调用了<code>notify()</code>方法，并不会立刻唤醒线程A，线程A首先需要拿到锁，才能接着<code>wait()</code>的地方运行。</strong></li>
</ul>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><ul>
<li><p>例1：</p>
<p>  在本例中，线程t1希望打印出线程t2对count累加100次的结果。但是下面的这种写法事与愿违。因为线程t2，在<code>notify()</code>后，并未交还自己的<code>object锁</code>，而是继续进行。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;count is:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waiting</span><br><span class="line">count is:200</span><br></pre></td></tr></table></figure>
</li>
<li><p>例2：</p>
<p>  在例2中对上述代码加以改进即可实现在线程t2累加100次时，让线程t1打印结果。方法是让线程t2在累加完100次时，交出<code>object锁</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;count is:&quot;</span>+ count);</span><br><span class="line">                object.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                object.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waiting</span><br><span class="line">count is:100</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><ul>
<li>定义：<ul>
<li>LockSupport类，是JUC包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞原语</li>
<li>LockSupport可以用于对线程进行阻塞和唤醒。核心方法：<code>park()</code>和<code>unpark()</code>，其中<code>park()</code>方法用来阻塞当前调用线程，<code>unpark()</code>方法用于唤醒指定线程。</li>
<li>原理是使用Permit（许可）概念来实现阻塞和唤醒。</li>
</ul>
</li>
<li>特点：<ul>
<li>LockSupport不需要synchronized加锁就可以实现线程的阻塞和唤醒。</li>
<li>可以先使用<code>unpark()</code>,再使用<code>park()</code>。（相当于先赋予一张令牌，再阻塞的时候就直接放行）</li>
<li><code>park()</code>让线程进入<code>waiting</code>状态，<code>unpark()</code>让线程重新进入<code>Runnable</code>状态。</li>
<li>调用<code>park()</code>让线程进入<code>waiting</code>状态后，如果再连续调用一次<code>park()</code>，线程将永远无法唤醒。</li>
</ul>
</li>
</ul>
<h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><ul>
<li><p>例1：</p>
<p>  先赋予一张令牌，再调用<code>park()</code>,则不阻塞，直接放行：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">5</span>)&#123;</span><br><span class="line">                    LockSupport.park(); <span class="comment">// 此处5s后执行</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); </span><br><span class="line">        LockSupport.unpark(t);  <span class="comment">//此处先执行完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例2：</p>
<p>  在例2中，如果不加注释2处，先<code>park()</code>后<code>unpark(t)</code>，线程正常阻塞与唤醒；加上了注释两处后，即是在线程<code>waitting</code>状态下继续调用<code>park()</code>,即使调用两次<code>unpark(t)</code>,线程也永远无法被唤醒。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">5</span>)&#123;</span><br><span class="line">                    LockSupport.park();  <span class="comment">//首次调用，线程已经处于waitting状态</span></span><br><span class="line">                    <span class="comment">// LockSupport.park();  //再次调用，线程将永远无法被唤醒。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            LockSupport.unpark(t);</span><br><span class="line">            <span class="comment">// LockSupport.unpark(t);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="两道面试题"><a href="#两道面试题" class="headerlink" title="两道面试题"></a>两道面试题</h1><p>LockSupport相比于Wait-Notify，不需要使用<code>synchronized</code>加锁就能实现线程的阻塞与唤醒。下面在两道题目中，让二者实现同样的功能，进行比较。</p>
<h2 id="1-实时监控，即时打印"><a href="#1-实时监控，即时打印" class="headerlink" title="1. 实时监控，即时打印"></a>1. 实时监控，即时打印</h2><ul>
<li><p>要求：实现一个容器，提供两个方法<code>add</code>,<code>size</code>。需要有两个线程。线程1：不停添加10个元素到容器中；线程2：实时监控容器的size，个数到5时，及时打印，结束线程2.</p>
</li>
<li><p>使用wait-notify实现：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_NotifyHoldingLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3_NotifyHoldingLock t = <span class="keyword">new</span> T3_NotifyHoldingLock();</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2启动&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (t.size()!=<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 开始&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    t.add(<span class="keyword">new</span> Object());</span><br><span class="line">                    System.out.println(<span class="string">&quot;add &quot;</span>+ i);</span><br><span class="line">                    <span class="keyword">if</span> (t.size()==<span class="number">5</span>)&#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用LockSupport实现：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Thread t1=<span class="keyword">null</span>, t2=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T3_LockSupport t = <span class="keyword">new</span> T3_LockSupport();</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 启动&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.size()!=<span class="number">5</span>)&#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 结束&quot;</span>);</span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 开始&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                t.add(<span class="keyword">new</span> Object());</span><br><span class="line">                System.out.println(<span class="string">&quot;add &quot;</span>+ i);</span><br><span class="line">                <span class="keyword">if</span> (t.size()==<span class="number">5</span>)&#123;</span><br><span class="line">                    LockSupport.unpark(t2);</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他实现方式：还可以用<code>CountDownLatch(1)</code>来实现锁的功能。</p>
</li>
</ul>
<h2 id="2-生产者-消费者-（固定容量的同步容器）"><a href="#2-生产者-消费者-（固定容量的同步容器）" class="headerlink" title="2. 生产者-消费者 （固定容量的同步容器）"></a>2. 生产者-消费者 （固定容量的同步容器）</h2><ul>
<li><p>要求：实现一个固定容量的同步容器，拥有get,put方法，具有支持2个生产者线程和10个消费者线程的同步调用。</p>
</li>
<li><p>使用<code>synchronized</code>的<code>wait-notify</code>方法实现线程的阻塞与唤醒：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T4_MyContainer_waitNotify</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (lists.size()==MAX)&#123; <span class="comment">// 思考此处为什么不用 if</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(t);</span><br><span class="line">         <span class="comment">// 此处唤醒的是所有阻塞的线程，而不针对消费者线程，是一个缺点。</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(lists.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = lists.removeFirst();</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T4_MyContainer_waitNotify&lt;String&gt; c = <span class="keyword">new</span>   T4_MyContainer_waitNotify&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Consumer&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Producer&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的实现方式，有两个需要思考的地方：</p>
<ul>
<li>为什么使用<code>while</code>循环来检查，而不使用<code>if</code>检查：当容器满时，生产者进入wait等待，只有当其他线程唤醒它时，才能继续<code>add</code>元素。试想此时恰好其他生产者在同时将容器又填满了，那么本线程再<code>add</code>就会出错。所以在<code>add</code>之时需要再次检查。</li>
<li>本例中，生产者线程，会使用<code>notifyAll()</code>唤醒所有线程，而然只需要唤醒消费者线程即可（如果唤醒的是生产者线程，则又会重复<code>wait</code>,浪费资源。），同理，消费者线程也会使用<code>notifyAll()</code>唤醒所有线程。</li>
</ul>
</li>
<li><p>使用<code>reentrantLock</code>的<code>condition</code>加以改进</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T4_MyContainer_ReentrantLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> LinkedList&lt;T&gt; lists = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> MAX =<span class="number">10</span>;</span><br><span class="line">    ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition consumer = reentrantLock.newCondition();</span><br><span class="line">    Condition producer = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size()==MAX)&#123;</span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(t);</span><br><span class="line">            consumer.signalAll();  <span class="comment">//此处只唤醒消费者</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T t= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span>(lists.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            t=lists.removeFirst();</span><br><span class="line">            producer.signalAll(); <span class="comment">//此处只唤醒生产者</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T4_MyContainer_ReentrantLock c = <span class="keyword">new</span> T4_MyContainer_ReentrantLock   ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息内容： &quot;</span>+ c.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Consumer&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line">                    c.put(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Producer&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面的例子可以看出，<code>reentantLock</code>比<code>synchronized</code>更加精细，可以控制哪些线程需要唤醒。</p>
<ul>
<li><code>Condition</code>本质就是一个等待队列。上面的例子中包含了两个等待队列。比起<code>synchronized</code>只有一个等待队列，更加精确。</li>
</ul>
</li>
</ul>
<blockquote>
<p>后记：本文介绍了<code>LockSupport</code>,和<code>object</code>的<code>wait-notify</code>。<code>wait-notify</code>需要在<code>sychronized</code>锁中使用，<code>LockSupport</code>可以直接使用。 同样在锁中，又比较了<code>synchronized</code>与<code>reentrantLock</code>之间的区别，前者只包含一个等待队列，后者则可以使用<code>condition</code>创建多个等待队列，对线程的唤醒，更加精确。后文则从AQS的原理和数据结构入手进行分析。</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/07/threadLearn5-2/">多线程与高并发（五）JUC同步工具(2)</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-07
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（五）JUC同步工具（2）</p>
<p>对于JUC同步工具的学习思路，首先从用法开始了解，之后再探讨原理。本文主要关注各同步工具的用法，后续文章逐渐深入原理。本文讨论的JUC同步工具包括：</p>
<ul>
<li>ReentrantLock</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li><code>Phaser</code></li>
<li><code>ReadWriteLock</code></li>
<li><code>Semaphore</code></li>
<li><code>Exchanger</code></li>
</ul>
<h1 id="Phaser-多阶段栅栏"><a href="#Phaser-多阶段栅栏" class="headerlink" title="Phaser - 多阶段栅栏"></a>Phaser - 多阶段栅栏</h1><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><ul>
<li><code>Phaser</code>的功能与 CyclicBarrier和CountDownLatch有些类似，类似于一个多阶段的栅栏。是比较复杂的一种同步器。</li>
<li><code>Phaser</code>中的一些概念：<ul>
<li>phase（阶段）：栅栏的名称叫做phase，在任意时间点，Phaser只处于某一个phase(阶段)，初始阶段为0，最大达到Integerr.MAX_VALUE，然后再次归零。当所有parties参与者都到达后，phase值会递增。</li>
<li>parties(参与者)：CyclicBarrier中的参与者在初始构造指定后就不能变更，而Phaser既可以在初始构造时指定参与者的数量，也可以中途通过register、bulkRegister、arriveAndDeregister等方法注册/注销参与者。</li>
<li>unarrive(未到达) / arrive(到达) / advance(进阶)：<ul>
<li>Phaser注册完parties（参与者）之后，参与者的初始状态是unarrived</li>
<li>当某个参与者到达（arrive）当前阶段（phase）后，该参与者状态就会变成arrived</li>
<li>当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生进阶（advance）——也就是phase值+1。</li>
</ul>
</li>
</ul>
</li>
<li>比较：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">同步器</th>
<th align="left">特点</th>
<th align="left">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CountDownLatch</td>
<td align="left">倒数门栓</td>
<td align="left">初始时设定参与者个数，参与线程执行到<code>await</code>方法时等待。当计数器归零时，所有待线程放行;</td>
</tr>
<tr>
<td align="left">CyclicBarrier</td>
<td align="left">循环栅栏</td>
<td align="left">当参与者线程到达<code>await</code>方法时等待。当到达线程数满足<code>parties</code>个数时放行。与数门栓相比，可以循环使用。</td>
</tr>
<tr>
<td align="left">Phaser</td>
<td align="left">多阶段栅栏</td>
<td align="left">可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设的数量后，会进行阶段升级</td>
</tr>
</tbody></table>
<h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>本例使用<code>Phaser</code>来管理多线程的几个阶段。7个人（5个参与者线程，1个新郎线程，1个新娘线程）参与一项婚礼，分为4个步骤进行：到场，吃饭，离开，洞房。要求是所有线程全部完成某一阶段，才能进入下一阶段。（相当于分阶段控制）；而且不同的阶段，还能按照不同的参与者的身份进行控制（洞房阶段只有新郎新娘两人参与，其他人不能参与）。下面是具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T4_Phaser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> MarriagePhaser phaser = <span class="keyword">new</span> MarriagePhaser();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">milliSleep</span><span class="params">(<span class="keyword">int</span> milli)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(milli);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        phaser.bulkRegister(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;p&quot;</span>+i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新郎&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(<span class="string">&quot;新娘&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*  Override了onAdvance：</span></span><br><span class="line"><span class="comment">        最后一个参与者到达时，会触发onAdvance方法,</span></span><br><span class="line"><span class="comment">        相当于CyclicBarrier中的barrierAction任务。*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phaser, <span class="keyword">int</span> registerParties)</span></span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(phaser)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人到齐了，人数：&quot;</span>+registerParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都吃完了，人数：&quot;</span>+registerParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;所有人都离开了，人数：&quot;</span>+ registerParties);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;婚礼结束，新郎新娘抱抱。人数：&quot;</span>+ registerParties);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span></span>&#123;</span><br><span class="line">            milliSleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 到达现场 \n&quot;</span>, name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            milliSleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 吃完 \n&quot;</span>,name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">()</span></span>&#123;</span><br><span class="line">            milliSleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s 离开 \n&quot;</span>,name);</span><br><span class="line">            phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hug</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(<span class="string">&quot;新郎&quot;</span>)||name.equals(<span class="string">&quot;新娘&quot;</span>))&#123;</span><br><span class="line">                milliSleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s 洞房 \n&quot;</span>,name);</span><br><span class="line">                phaser.arriveAndAwaitAdvance(); <span class="comment">// 等待其它参与者线程到达</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                phaser.arriveAndDeregister();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            arrive();;</span><br><span class="line">            eat();</span><br><span class="line">            leave();</span><br><span class="line">            hug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary>输出</summary>
<pre>
p1 到达现场 
新郎 到达现场 
p4 到达现场 
p3 到达现场 
新娘 到达现场 
p0 到达现场 
p2 到达现场 
所有人到齐了，人数：7

<p>新郎 吃完<br>p1 吃完<br>新娘 吃完<br>p0 吃完<br>p3 吃完<br>p4 吃完<br>p2 吃完<br>所有人都吃完了，人数：7</p>
<p>新娘 离开<br>p2 离开<br>p4 离开<br>p1 离开<br>新郎 离开<br>p3 离开<br>p0 离开<br>所有人都离开了，人数：7 </p>
<p>新郎 洞房<br>新娘 洞房<br>婚礼结束，新郎新娘抱抱。人数：2<br></pre></p>
</details>

<h1 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock - 读写锁"></a>ReadWriteLock - 读写锁</h1><h2 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h2><ul>
<li>可重入(Reentrant)：<code>synchronized</code>和<code>ReentrantLock</code>具有可重入性</li>
<li>可中断/不可中断：<code>synchronized</code>不可中断，<code>Lock</code>接口可中断</li>
<li>公平/非公平：<code>synchronized</code>是非公平锁。<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>，在默认情况下是非公平锁，可以设置为公平锁。</li>
<li>读写锁/互斥锁：为了解决锁的互斥与共享引入的概念。<code>synchronized</code>获取锁的线程一律互斥。<code>ReentrantReadWriteLock</code>具有读与读之间共享的特点。</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="ReadWriteLock接口："><a href="#ReadWriteLock接口：" class="headerlink" title="ReadWriteLock接口："></a>ReadWriteLock接口：</h3><ul>
<li><p>定义：ReadWriteLock接口是一个单独的接口（未继承Lock接口），该接口提供了获取读锁和写锁的方法: <code>readLock()</code>和<code>writeLock()</code>。</p>
</li>
<li><p>特点：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">读锁</th>
<th align="center">写锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读锁</td>
<td align="center">非阻塞</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">写锁</td>
<td align="center">阻塞</td>
<td align="center">阻塞</td>
</tr>
</tbody></table>
<ul>
<li>使用场景：读多写少、读较为耗时</li>
</ul>
<h3 id="ReentrantReadWriteLock-实现类"><a href="#ReentrantReadWriteLock-实现类" class="headerlink" title="ReentrantReadWriteLock 实现类"></a>ReentrantReadWriteLock 实现类</h3><ul>
<li><p>定义： ReentrantReadWriteLock类是通过定义内部类实现AQS框架的API来实现独占/共享的功能。从而实现ReadWriteLock接口。</p>
</li>
<li><p>特点：</p>
<ul>
<li>支持公平/非公平策略</li>
<li>支持锁重入<ul>
<li>同一读线程在获取了读锁后还可以获取读锁；</li>
<li>同一写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li>
</ul>
</li>
<li>支持锁降级<ul>
<li>先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。</li>
<li>但是，读锁不能升级到写锁。</li>
</ul>
</li>
<li>Condition条件支持</li>
</ul>
</li>
</ul>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>本例中，主要比较读写锁与互斥锁的执行效率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T5_ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 1. 直接使用互斥锁</span></span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="comment">// 2. 使用读写锁</span></span><br><span class="line">    <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;read over, value=&quot;</span>+value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = v;</span><br><span class="line">            System.out.println(<span class="string">&quot;write over, set value to: &quot;</span>+value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 直接使用互斥锁</span></span><br><span class="line">        <span class="comment">// Runnable readR = ()-&gt;read(lock);</span></span><br><span class="line">        <span class="comment">// Runnable writeR = ()-&gt;write(lock,new Random().nextInt());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 使用读写锁</span></span><br><span class="line">        Runnable readR = ()-&gt;read(readLock);</span><br><span class="line">        Runnable writeR = ()-&gt;write(writeLock,<span class="keyword">new</span> Random().nextInt());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="keyword">new</span> Thread(writeR).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) <span class="keyword">new</span> Thread(readR).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效率比较：</p>
<p>使用读写锁效率更高，18个读线程可以在1秒完成，另外两个写线程各占1秒；使用互斥锁，所有线程相互互斥，各占1秒，一般需要20秒完成。读写锁在这个应用场景中，效率更高。</p>
<h1 id="semaphore-限流信号量"><a href="#semaphore-限流信号量" class="headerlink" title="semaphore - 限流信号量"></a>semaphore - 限流信号量</h1><h2 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h2><ul>
<li>读音： [ˈseməfɔːr] </li>
<li>Semaphore维护了一个许可集，其实就是一定数量的“许可证”。</li>
<li>当有线程想要访问共享资源时，需要先获取(acquire)的许可；如果许可不够了，线程需要一直等待，直到许可可用。当线程使用完共享资源后，可以归还(release)许可，以供其它需要的线程使用。</li>
<li>另外，Semaphore支持公平/非公平策略，这和ReentrantLock类似</li>
</ul>
<h2 id="构造器与接口申明"><a href="#构造器与接口申明" class="headerlink" title="构造器与接口申明"></a>构造器与接口申明</h2><ul>
<li>构造器：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含permits个许可令的、非公平（默认）的信号量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 创建一个包含permits个许可令的、公平/非公平的信号量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>常用接口申明： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取令牌</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放令牌</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="用例：-1"><a href="#用例：-1" class="headerlink" title="用例："></a>用例：</h2><p>本例可以看出<code>Semaphore</code>具有限流的作用。当然了，当初始化为1时可以当做锁来用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T6_Semaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 is running...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 is running...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exchanger-交换器"><a href="#Exchanger-交换器" class="headerlink" title="Exchanger - 交换器"></a>Exchanger - 交换器</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><ul>
<li>这个类主要作用是两个线程之间的交换数据。</li>
<li>先到的线程会阻塞等待后到的线程，交换完数据后，再同时放行。</li>
<li>应用:游戏中交换装备、可以实现简单的生产者-消费者模式。</li>
</ul>
<h2 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h2><p>本例可以看出，先到的线程会阻塞等待后到的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T7_Exchanger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T1&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 begins running&quot;</span>);</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1 continue runs&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+s);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main threads sleep&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            String s = <span class="string">&quot;T2&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 begins running...&quot;</span>);</span><br><span class="line">                s = exchanger.exchange(s);</span><br><span class="line">                System.out.println(<span class="string">&quot;t2 continue runs.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+s);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details>
<summary>输出</summary>
<pre>
t1 begins running
main threads sleep
t2 begins running...
t2 continue runs.
t1 continue runs
t2 T1
t1 T2
</pre>
</details>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>ReentrantLock： 可重入锁</p>
<ul>
<li><code>lock.tryLock()</code></li>
<li><code>lock.lockInterruptibly()</code></li>
<li>可设置“公平/非公平”</li>
</ul>
</li>
<li><p>CountDownLatch： 倒数门栓</p>
<ul>
<li><code>await()</code> + <code>countDown()</code></li>
</ul>
</li>
<li><p>CyclicBarrier - 循环栅栏</p>
<ul>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code> + <code>await()</code></li>
</ul>
</li>
<li><p>Phaser - 多阶段的栅栏</p>
<ul>
<li>参与者个数可变，达到数量后会进行阶段升级</li>
<li><code>bulkRegister(int x)</code> + <code>arriveAndAwaitAdvance()</code> or <code>arriveAndDeregister()</code></li>
</ul>
</li>
<li><p>ReadWriteLock - 读写锁</p>
<ul>
<li>读写锁 与 互斥锁的 概念</li>
<li>实现类<code>ReentrantReadWriteLock</code>的特点</li>
</ul>
</li>
<li><p>Semophare - 限流信号量</p>
<ul>
<li><code>acquire()</code> + <code>release()</code></li>
</ul>
</li>
<li><p>Exchanger - 交换器</p>
<ul>
<li>两个线程之间的阻塞交换</li>
<li><code>exchanger(V x)</code></li>
</ul>
</li>
</ul>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015558984">透彻理解Java并发编程系列</a></li>
</ul>
<blockquote>
<p>后记：本着先实践后原理的原则，JUC同步工具（1）、（2）两文，不求甚解的把所有的J.U.C同步工具列举出来，重点放在了用法和用例上。后面的文章，会在几道题目中加深理解。对于其原理，这些同步工具大都是使用了AQS进行实现，后面会就AQS的源码和其数据结构进行分析。</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/06/threadLearn5/">多线程与高并发（五）JUC同步工具(1)</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-06
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（五）JUC同步工具（1）</p>
<p>对于JUC同步工具的学习思路，首先从用法开始了解，之后再探讨原理。本文主要关注各同步工具的用法，后续文章逐渐深入原理。本文讨论的JUC同步工具包括：</p>
<ul>
<li><code>ReentrantLock</code></li>
<li><code>CountDownLatch</code></li>
<li><code>CyclicBarrier</code></li>
<li>Phaser</li>
<li>ReadWriteLock</li>
<li>Semaphore</li>
<li>Exchanger</li>
</ul>
<h1 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock - 可重入锁"></a><code>ReentrantLock</code> - 可重入锁</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>基本用法：能完成与Synchronized的可重入锁的功能，但是需要手动释放锁:<code>unlock()</code>。（Synchronized锁定会由JVM管理，出现异常情况会自动释放锁，ReentrantLock需要手动释放锁）</li>
<li>特性：<ol>
<li><code>lock.tryLock()</code>：为了防止在长时间获取不到锁的情况下，出现阻塞的情况，可以使用<code>tryLock()</code>进行尝试锁定。无论是否成功，方法将继续执行下去。</li>
<li><code>lock.lockInterruptibly()</code>:可以被打断的锁。后序可以通过<code>t.interrupt();</code>将正在运行的<code>线程t</code>，进行打断。 （就是叫<code>线程t</code>别跑了，也别等了。）</li>
<li>可以设定<code>公平锁和非公平锁</code>。公平锁（true）对于等待的线程讲究先来后到，满足FIFO；非公平锁(false)就看哪个线程能争抢上，没有先后顺序。ReentrantLock默认是非公平锁。<ul>
<li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</li>
<li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><ul>
<li><p>基本用法：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_ReentrantLock1</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//  基础用法：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();  <span class="comment">//手动上锁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//手动解锁，一定要都放在try...finally块中，保证异常情况下也能解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;m2 ...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_ReentrantLock1 t = <span class="keyword">new</span> T1_ReentrantLock1();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果为m1方法全部执行完之后，m2方法才开始执行，表示锁生效了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>lock.tryLock()</code>:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_ReentrantLock2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//此处m1执行时间的长短，表示占有锁的时间长短</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            locked = lock.tryLock(<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (locked)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;m2: get lock&quot;</span>);</span><br><span class="line">                <span class="comment">// do something...</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;m2: don&#x27;t get lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_ReentrantLock2 t = <span class="keyword">new</span> T1_ReentrantLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当t1执行时间较短（在t2的等待时间之内），t2线程拿到了锁，可以do something…</p>
<p>  当t1执行时间较长（超过了t2的等待时间），t2线程即使拿不到锁，也不会一直阻塞下去，可以执行拿不到锁的else代码块。</p>
<p>  由此可见代码的灵活性更高，可以自行决定是否wait下去，如果是synchronized拿不到锁，就会一直阻塞下去。</p>
</li>
<li><p><code>lock.lockInterruptibly()</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_ReentrantLock3</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly(); <span class="comment">//允许被打断的锁</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupyed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_ReentrantLock3 t = <span class="keyword">new</span> T1_ReentrantLock3();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t::m1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t::m2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.interrupt(); <span class="comment">//这里可以手动终止t2的线程运行。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置公平与非公平锁</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_ReentrantLock4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>+<span class="string">&quot; 循环次数： &quot;</span>+i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_ReentrantLock4 t = <span class="keyword">new</span> T1_ReentrantLock4();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上述例子中，公平锁与非公平锁的设置，执行结果不一样：非公平锁情况下,t1,t2会相互争抢着进行；公平锁情况下，t1,t2会交替进行。</p>
</li>
</ul>
<h1 id="CountDownLatch-倒数门栓"><a href="#CountDownLatch-倒数门栓" class="headerlink" title="CountDownLatch - 倒数门栓"></a><code>CountDownLatch</code> - 倒数门栓</h1><h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><p>用<code>CountDownLatch</code>可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p>
<p>CountDownLatch类只提供了一个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;&#125;;  <span class="comment">//参数count为计数值</span></span><br></pre></td></tr></table></figure>
<p>然后下面这3个方法是CountDownLatch类中最重要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;;   </span><br><span class="line"></span><br><span class="line"> <span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123; &#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h2><p>有100个线程Ai,以及一个线程B。要使线程B在线程Ai全部执行完之后再执行，可以用<code>CountDownLatch</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        usingCountDownLatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usingCountDownLatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread[] threadList = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadList.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadList.length; i++) &#123;</span><br><span class="line">            threadList[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                    result+=j;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+ result);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;,<span class="string">&quot;A&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadList.length; i++) &#123;</span><br><span class="line">            threadList[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待子线程运行中...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;所有子线程运行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; run&quot;</span>),<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier - 循环栅栏"></a><code>CyclicBarrier</code> - 循环栅栏</h1><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><ul>
<li><p>构造器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数parties指让多少个线程或者任务等待至barrier状态；</span></span><br><span class="line"><span class="comment">// 参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要方法：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程挂起，直到有parties个数的线程到达barrier状态，即可继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123; &#125;  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上了等待时间，防止阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException,   BrokenBarrierException,TimeoutException </span>&#123; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：与<code>CountDownLatch</code>相比，二者本质上都是对线程的一种控制器（门栓、栅栏），判断是否执行完毕。但是<code>CyclicBarrier</code>可以重复使用，所以叫“循环”</p>
</li>
</ul>
<h2 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h2><p>例1：（重复使用特点）</p>
<p> 本例是102个线程，每满20个线程，就放行；如果不满20个，满足等待时间，也放行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">20</span>,()-&gt; System.out.println(<span class="string">&quot;人满发车&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">102</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待时间到，发车&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary>输出</summary>
<pre>
人满发车
人满发车
人满发车
人满发车
人满发车
等待时间到，发车
java.util.concurrent.BrokenBarrierException
    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:250)
    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)
    at c5.T3_CyclicBarrier.lambda$main$1(T3_CyclicBarrier.java:14)
    at java.lang.Thread.run(Thread.java:748)
java.util.concurrent.TimeoutException
    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:257)
    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:435)
    at c5.T3_CyclicBarrier.lambda$main$1(T3_CyclicBarrier.java:14)
    at java.lang.Thread.run(Thread.java:748)
</pre>
</details>

<p>例2: （具体业务场景）</p>
<p>本例是要进行一个复杂的业务逻辑<code>nextBusinessLogic</code>前，必须先获取来自不同数据源的数据（这是耗时操作），如果顺序执行：<code>读数据库数据-&gt; 读网络数据-&gt; 读文件数据</code>，则需要较长时间，可以使用并行操作。那么可以使用<code>CyclicBarrier</code>来保证：这三个线程执行完毕，才能进行后续操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_CyclicBarrier2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>,()-&gt;&#123;</span><br><span class="line">            nextBusinessLogic();</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        businessLogic(threads,<span class="string">&quot;读数据库数据&quot;</span>,<span class="number">2000</span>,cyclicBarrier);</span><br><span class="line">        businessLogic(threads,<span class="string">&quot;读网络数据&quot;</span>,<span class="number">4000</span>,cyclicBarrier);</span><br><span class="line">        businessLogic(threads,<span class="string">&quot;读文件数据&quot;</span>,<span class="number">3000</span>,cyclicBarrier);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            threads.get(i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">businessLogic</span><span class="params">( List&lt;Thread&gt; threadList, String threadName, <span class="keyword">int</span> waitTime, CyclicBarrier barrier)</span></span>&#123;</span><br><span class="line">        threadList.add(<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在执行...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(waitTime);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;获取数据完毕，等待其他线程获取完毕&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,threadName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextBusinessLogic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库,网络,文件的数据都获取完毕，执行下面的业务...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
<summary>输出</summary>
<pre>
线程读数据库数据正在执行...
线程读文件数据正在执行...
线程读网络数据正在执行...
线程读数据库数据获取数据完毕，等待其他线程获取完毕
线程读文件数据获取数据完毕，等待其他线程获取完毕
线程读网络数据获取数据完毕，等待其他线程获取完毕
数据库,网络,文件的数据都获取完毕，执行下面的业务...
</pre>
</details>


        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/01/threadLearn4/">多线程与高并发（四）CAS与Atomic</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-01
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（四）CAS与Atomic</p>
<h1 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h1><p>线程安全性设计上，包括四种方式:</p>
<ul>
<li>不可变：<ul>
<li>变量不可变，则不需要考虑线程安全问题：</li>
<li>举例：final修饰、String、枚举类型、Number部分子类：Long，Double，BigInteger, BigDecimal 等</li>
</ul>
</li>
<li>阻塞同步（互斥同步） （悲观锁）<ul>
<li>synchronized</li>
<li>ReentranLock （重入锁）</li>
</ul>
</li>
<li>非阻塞同步 （乐观锁）<ul>
<li>先进行操作，判断没有其他线程共享资源，则操作成功；否则采取补偿措施（重试直到成功），此之谓非阻塞。</li>
<li>乐观锁需要 硬件支持原子性操作：<code>CAS(compare and set)</code></li>
</ul>
</li>
<li>无同步方案<ul>
<li>栈封闭（多线程访问方法的局部变量，属于线程私有的，没有安全性问题）</li>
<li>线程本地存储（将需要共享数据的 多块代码，放进一个线程里面，一次性搞定，例如“web的request就是一个thread”）</li>
</ul>
</li>
</ul>
<p>可以看出乐观锁的实现方式需要基于CAS，(Compare-and-Swap)，又叫“无锁”，是<strong>原子性</strong>的操作。</p>
<p>这里对CAS的底层实现原理不做深入分析,只做简单描述。</p>
<ul>
<li><p>在java语言层面：</p>
<p>  对于<code>AtomicInteger</code>的<code>incrementAndGet()</code>方法而言，采用了CAS。<code>AtomicInteger</code>类调用了<code>Unsafe</code>类的如下方法。最终调用的是<code>native</code>方法 <code>compareAndSwapInt</code>。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class AtomicInteger</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Unsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2,<span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>
<p>  将上述方法做一个转换即是下面的表达，意思是：如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update；反之，如果进入compareAndSwapInt方法后，发现obj内的value已经和expect不一致了（被其他线程修改过了），那就采用自旋的方式继续进行CAS操作（补偿一次操作，是乐观锁的思想）。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compareAndSwapInt（var1, var2, var5, var5 + var4）</span></span><br><span class="line"><span class="comment">// 转换之后的代码</span></span><br><span class="line">compareAndSwapInt（obj, offset, expect, update）</span><br></pre></td></tr></table></figure></li>
<li><p>JDK源码层：</p>
<p>  可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5a73cbbff265da4e807783f5">这篇博客</a>。</p>
</li>
</ul>
<h1 id="CAS的应用-Atomic类"><a href="#CAS的应用-Atomic类" class="headerlink" title="CAS的应用 - Atomic类"></a>CAS的应用 - Atomic类</h1><p><code>concurrent.atomic</code>包下的工具类都用到了CAS。下面的例子是典型的<code>count++</code>的操作，如果用悲观锁来实现，需要在<code>m()</code>方法加上<code>synchronized</code>关键字，有可能升级为重量级的锁，没有本例中的<code>AtomicInteger</code>的执行效率高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//atomic类方法本身是原子性的，但是不能保证多个方法连续调用的原子性。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_AtomicInteger</span> </span>&#123;</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_AtomicInteger t = <span class="keyword">new</span> T1_AtomicInteger();</span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadList.add(<span class="keyword">new</span> Thread(t::m,<span class="string">&quot;thread-&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        threadList.forEach((o)-&gt;o.start());</span><br><span class="line"></span><br><span class="line">        threadList.forEach((o)-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h1><ul>
<li><p>ABA问题</p>
<ul>
<li>起因：在执行CAS操作时，目标值被其他线程 修改了两次 A-&gt;B-&gt;A, 对于基本类型没有影响。对于引用类型，就是中间经历了别的对象。</li>
<li>解决方式：添加版本号：<code>atomic</code>中的<code>AtomicStampedReference</code>类可以用于解决此问题。</li>
</ul>
</li>
<li><p>自旋时间开销大问题</p>
<ul>
<li>CAS执行不成功，如果长时间自旋会给cpu带来较大的执行开销（在大量线程的情况下）。下面的例子<code>T2_Sync_Atomic_LongAddr</code>可以看出。</li>
</ul>
</li>
</ul>
<h1 id="多线程中自增的三种写法"><a href="#多线程中自增的三种写法" class="headerlink" title="多线程中自增的三种写法"></a>多线程中自增的三种写法</h1><p>多线程中的自增是最常见的一种情况，比如说秒杀，有如下三种线程安全的实现方式：</p>
<ul>
<li>synchronized</li>
<li>atomic类</li>
<li>LongAdder类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_Atomic_Sync_LongAddr</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> AtomicLong count2 = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">static</span> LongAdder count3 = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> testType,<span class="keyword">int</span> testNum)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (testType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Object object = <span class="keyword">new</span> Object();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; testNum; j++) &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                                count1++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; testNum; j++) &#123;</span><br><span class="line">                            count2.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                    threads[i] = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; testNum; j++) &#123;</span><br><span class="line">                            count3.increment();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) t.start();</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;m1: &quot; + m(1,1000));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;m2: &quot; + m(2,1000));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;m3: &quot; + m(3,1000));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;m1: &quot;</span> + m(<span class="number">1</span>,<span class="number">10000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;m2: &quot;</span> + m(<span class="number">2</span>,<span class="number">10000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;m3: &quot;</span> + m(<span class="number">3</span>,<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;m1: &quot; + m(1,100000));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;m2: &quot; + m(2,100000));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;m3: &quot; + m(3,100000));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述例子，分别在三种CASE中，对1000个线程，每个线程中进行<code>若干次</code>自增操作，来模拟较高的并发情况。三种CASE分别由<code>synchronized</code>、<code>atomic</code>和<code>LongAdder</code>来实现。经过粗糙的测试有如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1000次</span><br><span class="line">m1: 93</span><br><span class="line">m2: 73</span><br><span class="line">m3: 75</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;10000次</span><br><span class="line">m1: 553</span><br><span class="line">m2: 219</span><br><span class="line">m3: 95</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;100000次</span><br><span class="line">m1: 1800</span><br><span class="line">m2: 2006 </span><br><span class="line">m3: 246  &#x2F;&#x2F; 可以发现在大量线程进行测试情况下，LongAddr类效率较高。</span><br></pre></td></tr></table></figure>
<p>上述时间单位为ms，可以发现：</p>
<ul>
<li>1000次及以下的时候：三者差异不大，执行效率：atomic ≈ LongAdder &gt; synchronized</li>
<li>10000次：执行效率：atomic ≈ LongAdder &gt; synchronized</li>
<li>100000次：执行效率：LongAdder &gt; synchronized &gt; atomic </li>
</ul>
<p>究其原因：</p>
<ul>
<li>在并发量较小的情况下：乐观锁的执行效率高于悲观锁，因为乐观锁的执行成功率较高。乐观锁，线程较少，自旋的情况较少；而悲观锁synchronized可能锁升级，去操作系统申请重量级锁，这种情况下较为耗时。</li>
<li>在并发量较大的情况下：在竞争激烈的情况下，CAS操作不断的失败，就会有大量的线程不断的自旋尝试 CAS 会造成 CPU 的极大的消耗。CAS此时暴露出“自旋时间开销大”的问题。</li>
<li>LongAddr整体表现比较优秀，其原因是使用了分段锁。</li>
</ul>
<h1 id="LongAddr类"><a href="#LongAddr类" class="headerlink" title="LongAddr类"></a>LongAddr类</h1><ul>
<li><p>特点：</p>
<p>  参看<code>LongAddr</code>的javadoc：</p>
<blockquote>
<p>This class is usually preferable to {@link AtomicLong} when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control.  Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption.</p>
</blockquote>
<p>  LongAddr在在低更新争用情况下，和AtomicLong类相比具有相似的特性；高争用的情况下，LongAddr类的预期吞吐量会显著提高，但会牺牲更高的空间消耗。与AtomicLong相比，LongAddr更适合去做 统计数据的收集，而不是细粒度的锁控制。</p>
<p>  总结来看，LongAddr的优缺点如下：</p>
<ul>
<li>优点：解决了 AtomicLong 类，在极高竞争下的性能问题。</li>
<li>缺点：对于自增ID的生成，不适合再使用LongAddr,因为LongAdder 在统计的时候如果   有并发更新，可能导致统计的数据有误差。此时首选AtomicLong。</li>
</ul>
</li>
<li><p>底层实现：</p>
<ul>
<li>使用了一个 cell 列表去承接并发的 cas, 分散竞争，逐步升级竞争。</li>
<li>详细实现可以参考：<a target="_blank" rel="noopener" href="https://xilidou.com/2018/11/27/LongAdder/">从 LongAdder 中窥见并发组件的设计思路</a></li>
</ul>
</li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/05/01/threadLearn3/">多线程与高并发（三）Volatile关键字</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-05-01
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>马士兵老师的多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（三）Volatile关键字</p>
<h1 id="java内存模型的承诺"><a href="#java内存模型的承诺" class="headerlink" title="java内存模型的承诺"></a>java内存模型的承诺</h1><ul>
<li><p>原子性（Atomicity）</p>
<ul>
<li>由Java内存模型来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以认为基础数据类型的访问和读写是具备原子性的。</li>
<li>如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—synchronized关键字，因此在synchronized块之间的操作也具备原子性。</li>
</ul>
</li>
<li><p>可见性（Visibility）</p>
<ul>
<li>可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的</li>
<li>普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。</li>
<li>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。<ul>
<li>synchronized同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的。</li>
<li>final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见final字段的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>有序性（Ordering）</p>
<ul>
<li>Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。</li>
<li>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性<ul>
<li>volatile关键字本身就包含了禁止指令重排序的语义</li>
<li>synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Volatile的两特性"><a href="#Volatile的两特性" class="headerlink" title="Volatile的两特性"></a>Volatile的两特性</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><ul>
<li><p>java内存模型：</p>
<ul>
<li><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
</li>
<li><p>JVM运行的实体是线程，线程创建时JVM会为其创建一个工作内存，而JMM规定所有变量都保存在主内存中，供所有线程访问，属于公共空间。线程自己的工作空间对其他线程不可见。</p>
</li>
<li><p>线程对工作变量的一次操作过程：从主内存拷贝到自己的工作内存，操作变量，再写回主内存中。过程如下：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B/JMM1.png" alt="JMM"></p>
</li>
<li><p>注意不要弄混java内存模型（虚拟概念）和硬件内存架构（真实硬件）之间的关系：多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中。下图表示是一种交叉的关系。<br>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B/JMM%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="java内存模型（虚拟概念）和硬件内存架构（真实硬件）之间的关系"></p>
</li>
</ul>
</li>
<li><p>Volatile保证可见性的原理：</p>
<ol>
<li>使用volatile关键字会强制将修改的值立即写入主存；</li>
<li>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量   缓存行无效；</li>
<li>由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次去主存读取变量的值。</li>
</ol>
</li>
<li><p>例证：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_Visibility</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* volatile */</span> <span class="keyword">boolean</span> running =<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m start...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;m end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_Visibility t = <span class="keyword">new</span> T1_Visibility();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.running=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  上述例子，在不给running添加volatile关键字时，线程不会停止运行，原因是main线程   修改running的值后，t1线程感知不到（没有去更新缓存）。当添加volatile关键字后，t1线程可终止。</p>
</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>举例：在单例模式的双重锁校验过程中的volatile分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_Ordering</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="comment">/* volatile */</span> <span class="keyword">static</span> T2_Ordering INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T2_Ordering</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T2_Ordering <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;                     <span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (T2_Ordering.class) &#123;      //(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;             <span class="comment">//(3)</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> T2_Ordering();   <span class="comment">//(4)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;                            <span class="comment">//(5)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; System.out.println(T2_Ordering.getInstance().hashCode())).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式的 DCL（double check lock）是在 线程安全的懒汉式的基础上，将方法上的synchronized关键字，范围缩小到单例对象初始化的代码块中，提高了运行效率。</p>
<p>上述的DCL的写法中，添加了volatile的正常流程是：</p>
<ul>
<li>线程t1与线程t2同时到达（1），单例对象还未初始化，同时竞争锁。</li>
<li>线程t1抢到锁，到（3），（4），初始化单例对象，后释放锁。</li>
<li>线程t2立马进入（2），但是被拦在（3）处，也释放锁，顺利拿到t1创建的对象。</li>
</ul>
<p>但是在没有添加volatile的情况下，单例对象的初始化过程由于不是原子性操作，分为了下面三个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.获取对象地址 </span><br><span class="line">b.在对象地址上初始化一个T2_Ordering对象；</span><br><span class="line">c.将INSTANCE引用指向对象地址</span><br></pre></td></tr></table></figure>
<p>由于指令重排可能出现 a-&gt;b-&gt;c, 或者 a-&gt;c-&gt;b两种情况。当出现后面一种情况时，可能出错的情形如下：</p>
<ul>
<li>线程t1到达（4）处，且经过a-&gt;c-&gt;b的步骤，刚刚进行到c, 此时INSTANCE指向的对象还没有被初始化，地址是1750862512（但其实这个位置还没有被初始化出对象）；</li>
<li>在这一瞬间，线程t2到达（1）处，INSTANCE不为空，是1750862512，则直接跳出到（5）拿对象。这时发现在对应的地址中，没有对象 -&gt; 空指针异常。</li>
</ul>
<p>添加了volatile则可以防止这种指令重排问题。（注：本例在实验环境中很难测试出出错的情形）。</p>
<h2 id="原子性（无）"><a href="#原子性（无）" class="headerlink" title="原子性（无）"></a>原子性（无）</h2><p>volatile不保证原子性，在一些非原子性操作的时候，还需要添加synchronized来保护线程安全，反例如下。这个例子输出结果可能会小于10000，分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_Atomicity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T3_Atomicity t = <span class="keyword">new</span> T3_Atomicity();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                    t.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//这里写的不好,需要确认上面的步骤全部进行完毕</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是典型的count++的问题，count++不是原子性操作，包含了下面三个步骤：</p>
<ul>
<li>a.从主内存中读取，并拷贝到线程的工作内存中</li>
<li>b.修改count值</li>
<li>c.写回主内存</li>
</ul>
<p>由于没有对increase方法加锁，可能会出现下面的错误情形：</p>
<ul>
<li>线程t1从主内存中读取count的值，为10,准备进行修改操作。此时线程调度器激活线程t2,t2从主内存中读取到count的值为10。</li>
<li>线程t1进行count修改的操作，并写回主内存。</li>
<li>其他线程t3,t4再读到count的时候，均是11。但是t2已经将count读进自己的工作内存，不会重复在主内存中读一次，所以t2接着进行修改操作，写回主内存的还是count=11。</li>
</ul>
<p>对比例1和例3：</p>
<ul>
<li>例子1中，因为是while语句，线程会不断读取running的值来判断是否为false，每一次判断都是一个操作。这里是从缓存中读取。单个读取操作是具有原子性的，所以当例子1中的主线程修改了running时，由于volatile变量的可见性，线程1的 <strong>下一个操作</strong> 中再读取running时是最新的值，为true。</li>
<li>而例子3中，为什么自增操作会出现那样的结果呢？可以知道自增操作是三个原子操作组合而成的复合操作。 <strong>在一个操作中</strong>，读取了count变量后，是不会再读取的inc的，所以它的值还是之前读的10，它的下一步是自增操作。</li>
</ul>
<blockquote>
<p>总结: volatile保证了可见性和有序性。可见性在CPU层级，使用的是缓存一致性来实现；有序性是在虚拟机层级，通过添加读写屏障实现。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xtayfjpk/article/details/41969915">深入理解Java虚拟机笔记—原子性、可见性、有序性</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/72772461">全面理解Java内存模型(JMM)及volatile关键字</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/30/threadLearn2/">多线程与高并发（二）Synchronized关键字</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-30
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>马士兵老师的多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（二）Synchronized关键字</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>synchronized 是 Java 中的关键字，是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p>
<ul>
<li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p>
</li>
<li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ul>
<li>对象锁：<ul>
<li>目的：持有这个对象的线程争抢这把锁。</li>
<li>用法：<ul>
<li>修饰非静态方法</li>
<li>修饰代码块</li>
</ul>
</li>
</ul>
</li>
<li>类锁：<ul>
<li>目的：持有这个类的所有对象的线程，争抢同一把锁，因为T.class是唯一的。</li>
<li>用法：<ul>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h1><h2 id="1-对象锁"><a href="#1-对象锁" class="headerlink" title="1. 对象锁"></a>1. 对象锁</h2><p>object 对象锁修饰代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_Synchronized1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object(); <span class="comment">//使用object这个对象当锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+ count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_Synchronized1 t = <span class="keyword">new</span> T1_Synchronized1();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 这句话如果放这，就相当于10个线程持有10个不同的对象，不是同一把锁</span></span><br><span class="line">            <span class="comment">// T1_Synchronized1 t = new T1_Synchronized1(); </span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本对象修饰代码块, 和上述一样的功能，锁定的是某一个对象，不是代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_Synchronized2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+ count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_Synchronized2 t = <span class="keyword">new</span> T1_Synchronized2();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象锁修饰非静态方法（如果是修饰静态方法，就是用的类锁了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_Synchronized3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+ count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T1_Synchronized3 t = <span class="keyword">new</span> T1_Synchronized3();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                t.m();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-类锁"><a href="#2-类锁" class="headerlink" title="2. 类锁"></a>2. 类锁</h2><p>类锁的目的是持有这个类的所有对象的线程，争抢同一把锁，下面三种方式的作用相同：</p>
<ul>
<li>修饰静态方法</li>
<li>修饰静态代码块</li>
<li>修饰非静态代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_Synchronized4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 修饰静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修饰静态代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (T1_Synchronized4.class)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修饰非静态代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (T1_Synchronized4.class)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; count = &quot;</span>+count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//            T1_Synchronized4 t = new T1_Synchronized4();</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                T1_Synchronized4.m1();</span><br><span class="line"><span class="comment">//                T1_Synchronized4.m2();</span></span><br><span class="line"><span class="comment">//                t.m3();</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="脏读问题"><a href="#脏读问题" class="headerlink" title="脏读问题"></a>脏读问题</h1><h2 id="1-同步方法和非同步方法同时调用"><a href="#1-同步方法和非同步方法同时调用" class="headerlink" title="1. 同步方法和非同步方法同时调用"></a>1. 同步方法和非同步方法同时调用</h2><p>同步方法和非同步方法是可以同时调用的，互不影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_Synchronized_noSynchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; m1 start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; m1 end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; m2 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T2_Synchronized_noSynchronized t = <span class="keyword">new</span> T2_Synchronized_noSynchronized();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m2).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 上述表达相当于</span></span><br><span class="line"><span class="comment">         new Thread(()-&gt;t.m1()).start();   </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  jdk1.8以前的写法</span></span><br><span class="line"><span class="comment">        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                t.m1();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步方法和非同步方法同时调用，引申一下，可能导致下面的脏读问题。</p>
<h2 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2. 脏读"></a>2. 脏读</h2><p>将上述的加锁的方法和不加锁的方法，转换成为对 Account的写方法和读方法，则会出现脏读问题，若给读方法加锁，则不会出现脏读问题。</p>
<ul>
<li>给读方法加锁：读效率较低</li>
<li>不给读方法加锁：可能出现脏读</li>
</ul>
<p>主要看业务是否允许脏读，隔离等级如何。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">double</span> balance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.balance=balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* synchronized */</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T2_Account account = <span class="keyword">new</span> T2_Account();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; account.set(<span class="number">100.0</span>)).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可重入特点"><a href="#可重入特点" class="headerlink" title="可重入特点"></a>可重入特点</h1><ul>
<li><p>定义：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。</p>
</li>
<li><p>synchronized 是可重入锁</p>
</li>
<li><p>实例验证：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_ReentrantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;father end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T3_ReentrantTestChild().m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T3_ReentrantTestChild</span> <span class="keyword">extends</span> <span class="title">T3_ReentrantTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child start...&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.m();</span><br><span class="line">        System.out.println(<span class="string">&quot;child end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child start...</span><br><span class="line">father start...</span><br><span class="line">father end</span><br><span class="line">child end</span><br></pre></td></tr></table></figure>
<p>  如果不是可重入锁，会出现死锁。</p>
</li>
<li><p>实现原理概述：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p>
</li>
</ul>
<h1 id="异常时，锁是否中断"><a href="#异常时，锁是否中断" class="headerlink" title="异常时，锁是否中断"></a>异常时，锁是否中断</h1><ul>
<li>程序执行过程中如果出现异常，默认情况下锁会被释放</li>
<li>在web app中，多个servlet访问同一个资源，如果异常没有处理合适，在第一个线程出现异常时，其他等待的线程会涌入同步代码区，有可能访问到异常的数据。</li>
<li>要非常小心处理 同步业务逻辑中的异常</li>
<li>实例验证：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T4_Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; start...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">5</span>) &#123;   </span><br><span class="line">                <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;  <span class="comment">//会出现异常的区域</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(T4_Exception::m,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(T4_Exception::m,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照程序设计，t1线程在运行时，t2线程永远不会开始。但是由于t1线程出现了异常退出，t2乱入。输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t1 start...</span><br><span class="line">t1 count &#x3D; 1</span><br><span class="line">t1 count &#x3D; 2</span><br><span class="line">t1 count &#x3D; 3</span><br><span class="line">t1 count &#x3D; 4</span><br><span class="line">t1 count &#x3D; 5</span><br><span class="line">Exception in thread &quot;t1&quot; t2 start...</span><br><span class="line">t2 count &#x3D; 6</span><br><span class="line">java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">	at c2.T4_Exception.m(T4_Exception.java:20)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">t2 count &#x3D; 7</span><br><span class="line">t2 count &#x3D; 8</span><br><span class="line">t2 count &#x3D; 9</span><br></pre></td></tr></table></figure>

<p>改进方法是将可能出现异常的区域 int i=1/0， 使用try…catch包裹，之后t1的循环会继续。修改后输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 start...</span><br><span class="line">t1 count &#x3D; 1</span><br><span class="line">t1 count &#x3D; 2</span><br><span class="line">t1 count &#x3D; 3</span><br><span class="line">t1 count &#x3D; 4</span><br><span class="line">t1 count &#x3D; 5</span><br><span class="line">t1 count &#x3D; 6</span><br><span class="line">java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">	at c2.T4_Exception.m(T4_Exception.java:21)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">t1 count &#x3D; 7</span><br><span class="line">t1 count &#x3D; 8</span><br></pre></td></tr></table></figure>

<h1 id="以对象作锁，最好是final"><a href="#以对象作锁，最好是final" class="headerlink" title="以对象作锁，最好是final"></a>以对象作锁，最好是final</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T6_ObjectLock_Final</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* final */</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        T6_ObjectLock_Final t = <span class="keyword">new</span> T6_ObjectLock_Final();</span><br><span class="line">        <span class="keyword">new</span> Thread(t::m,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t::m,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="comment">//如果锁对象是final的，这句话不通过，t2将没有机会运行</span></span><br><span class="line">        t.object = <span class="keyword">new</span> Object(); </span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁是由对象头上的两位来作标识的，修改了对象，就去访问别的对象的两位了，上一个对象的两位就没有参考意义了（锁就没用了）。以对象作为锁的时候，不要让其改变，加上final修饰。</p>
<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>锁的底层实现，和锁的优化过程，可以参照 <a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_38083619/article/details/82527461">这篇博客</a><br>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/tongdanping/article/details/79647337">这篇博客</a></p>
<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>关于使用synchronized进行优化的内容，参照这篇博客</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/29/threadLearn1/">多线程与高并发（一）线程的基本概念</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-29
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>多线程与高并发 的系列学习笔记，不仅仅停留在理论层面，尽量落到实地，以代码的形式实践、总结。</p>
</blockquote>
<p>（一）线程的基本概念</p>
<h1 id="创建线程的5种方式"><a href="#创建线程的5种方式" class="headerlink" title="创建线程的5种方式"></a>创建线程的5种方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1_HowToCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyRun&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyCall&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    启动线程的5种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1. 继承Thread</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line"><span class="comment">//        2. 实现Runnable</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br><span class="line"><span class="comment">//        3. Lamda表达式匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread3&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"><span class="comment">//        4. 带返回值的 FutureTask&lt;&gt;(Callable())</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCall())).start();</span><br><span class="line"><span class="comment">//        5. 线程池 创建的方式</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadPool&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的基本方法-sleep-yield-join"><a href="#线程的基本方法-sleep-yield-join" class="headerlink" title="线程的基本方法 sleep yield join"></a>线程的基本方法 sleep yield join</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T2_Sleep_Yield_Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//        testSleep();</span></span><br><span class="line"><span class="comment">//        testYield();</span></span><br><span class="line">        testJoin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  sleep:当前线程休眠一段时间，留给其他线程运行。睡眠时间到线程复活。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  yield: 当前线程从Running-&gt;Ready，然后和其他线程同时开始争夺资源，让出CPU，重新竞争。</span></span><br><span class="line"><span class="comment">//  可能是当前线程继续运行，更大可能是重等待队列中选出一个线程来运行。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testYield</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------B&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    join: t1正在运行，t2.join(),这时t1会等t2运行完再执行。（自己join自己没有意义）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testJoin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;A&quot;</span>+i);</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>+i);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h1><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png" alt="线程的六种状态"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T3_ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span>+ Thread.currentThread().getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(i);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;，“<span class="number">0</span>”);</span><br><span class="line">        System.out.println(<span class="string">&quot;new线程的状态: &quot;</span>+t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>); </span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">&quot;线程0的状态: &quot;</span>+t.getState()+<span class="string">&quot;  currentThread:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot; currentThreadState: &quot;</span>+ Thread.currentThread().getState());</span><br><span class="line">            <span class="comment">//此处时而显示  线程0的状态: RUNNABLE ， 时而显示 线程0的状态: TIMED_WAITING</span></span><br><span class="line">            <span class="comment">//最终将显示： 线程0的状态: TERMINATED</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B/c1%E8%BE%93%E5%87%BA.png" alt="状态输出"></p>
<ul>
<li>New: Thread t = new Thread()。 线程被创建出来就是New状态。</li>
<li>RUNNABLE: 线程在线程调度器执行的状态。（可以看到1处，主线程和0线程同时处于RUNNABLE状态，如果是单核CPU,那么可以猜想得知：0线程是处于Ready，main线程是Running；我的测试机是多核CPU, 两者的状态未知，可以都处于Running。）</li>
<li>TIMED_WAITING: Thread.sleep(xx)。 在0线程sleep的时候，0线程即处于TIMED_WAITING状态，其状态与main线程是否sleep无关。</li>
</ul>
<blockquote>
<p>可见多线程的运行，跟机器的CPU的核数有关系。单核CPU采用时间片轮转方式来实现并发，而多核CPU能实现真正的并行。</p>
</blockquote>
<h1 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h1><ul>
<li>并发（concurrency ）：时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行，使其在宏观上具有多个线程同步执行的效果。</li>
<li>并行（parallelism ）：时间段和同一时间点上都有多个线程或进程在执行。</li>
</ul>
<h1 id="单核、多核"><a href="#单核、多核" class="headerlink" title="单核、多核"></a>单核、多核</h1><p>都是一个CPU，不同的是每个CPU上的核心数。一个核心只能同时执行一个线程。</p>
<ul>
<li><p>单核：（并发）</p>
<p>  单核CPU上运行的多线程程序, 同一时间只能一个线程在跑, 系统帮你切换线程而已, 系统给每个线程分配时间片来执行, 每个时间片大概10ms左右, 看起来像是同时跑, 但实际上是每个线程跑一点点就换到其它线程继续跑，效率不会有提高，切换线程反倒会增加开销。</p>
</li>
<li><p>多核：（并行）</p>
<p>  多核CPU是多个CPU的替代方案，同时也减少了功耗。可以真正意义上做到并行。</p>
<ul>
<li>物理核：物理核心数量=CPU数(机器实装的CPU数)*每个CPU的核心数</li>
<li>虚拟核：所谓的4核8线程，4核指的是物理核心，通过超线程技术，用一个物理核模拟两个虚拟核，每个核两个线程，总数为8线程（逻辑处理器）。</li>
</ul>
<p>windows下通过指令查看CPU个数和物理核心与线程数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> # 查看cpu个数</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> # 查看细节信息</span><br><span class="line">wmic</span><br><span class="line">cpu get *</span><br><span class="line"># 或者：cpu get NumberOfCores, NumberOfLogicalProcessors</span><br></pre></td></tr></table></figure>

</li>
</ul>
<div align="center">
<img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B/win%E6%9F%A5%E7%9C%8B%E6%A0%B8%E5%BF%83.png" ><br>
<sup>NumberOfCores 物理核心,  NumberOfLogicalProcessors 线程数（逻辑处理器）</sup>
</div>

<p>不同核数和任务适合的线程数：</p>
<ul>
<li>多核CPU——计算密集型任务:此时要尽量使用多线程，可以提高任务执行效率，例如加密解密，数据压缩解压缩（视频、音频、普通数据），否则只能使一个核心满载，而其他核心闲置。</li>
<li>单核CPU——计算密集型任务：此时的任务已经把CPU资源100%消耗了，就没必要也不可能使用多线程来提高计算效率了；如果要做人机交互，最好还是要用多线程，避免用户没法对计算机进行操作。</li>
<li>单核CPU——IO密集型任务，使用多线程还是为了人机交互方便。</li>
<li>多核CPU——IO密集型任务，这就更不用说了，跟单核时候原因一样。（防止单线程由于IO阻塞）</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8132ebc8e99d">进程和线程、并行和并发、单核和多核CPU</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ksws0292756/article/details/79119961">Windows下查看电脑的CPU个数，核心数，线程数</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/25/webPushTec/">服务器推送技术</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-25
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>为解决Web应用中server向client“主动”发起请求的需求，出现了服务器推送技术。本文对服务器推送技术进行分类，然后分析其具体应用场景，例如淘宝，微信的web端的扫码登录的流程。</p>
</blockquote>
<h1 id="1-服务器推送技术分类"><a href="#1-服务器推送技术分类" class="headerlink" title="1. 服务器推送技术分类"></a>1. 服务器推送技术分类</h1><p>http协议为无状态，单向性的协议，必须有客户端发起请求，服务端接受请求，做出响应。在此特性下，要实现服务端“主动”发起的推送技术，有如下几种实现方式：</p>
<ul>
<li>Ajax短轮询</li>
<li>Comet<ul>
<li>Ajax长轮询</li>
<li>http streaming</li>
</ul>
</li>
<li>SSE</li>
<li>WebSocket</li>
<li>基于MQ</li>
</ul>
<h2 id="1-Ajax短轮询"><a href="#1-Ajax短轮询" class="headerlink" title="1. Ajax短轮询"></a>1. Ajax短轮询</h2><ul>
<li>定义： 短轮询是指客户端定时向服务器发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。Ajax短轮询其实就是：“脚本发送的http请求。”</li>
<li>举例：   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span></span><br><span class="line">    showTime();</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.get(<span class="string">&quot;showTime&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#serverTime&quot;</span>).html(data);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="built_in">setInterval</span>(showTime,<span class="number">1000</span>); <span class="comment">//重点在于定时发送</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-Comet"><a href="#2-Comet" class="headerlink" title="2. Comet"></a>2. Comet</h2><ul>
<li>定义：Alex Russell（Dojo Toolkit 的项目 Lead）称基于 HTTP 长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。</li>
<li>分类：<ul>
<li>基于 AJAX 的长轮询（long-polling）方式</li>
<li>基于 Iframe 及 htmlfile 的流（streaming）方式</li>
</ul>
</li>
</ul>
<h3 id="2-1-基于-AJAX-的长轮询（long-polling）方式"><a href="#2-1-基于-AJAX-的长轮询（long-polling）方式" class="headerlink" title="2.1 基于 AJAX 的长轮询（long-polling）方式"></a>2.1 基于 AJAX 的长轮询（long-polling）方式</h3><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/%E8%BD%AE%E8%AF%A2%E4%B8%8E%E9%95%BF%E8%BD%AE%E8%AF%A2.png" alt="轮询与长轮询"></p>
<ul>
<li><p>定义：在普通轮询过程中，client接受响应的速度受制于定时器的发送频率。长轮询中，当server接受到client发送的请求后，hold住一段时间，若有消息，则立刻返回。client接受到响应（1）、或者超时（2）、或者异常（3）时，重新发起一次新的请求。</p>
</li>
<li><p>应用：在一些使用Pull模式消费的消息系统，会使用Long Polling技术进行优化。例如下图是MetaQ推送的服务端设计，实际是利用的长轮询的原理。</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/metaq%E7%9A%84push.png" alt="metaQ的push"></p>
</li>
</ul>
<h3 id="2-2-基于Iframe及htmlfile的流（streaming）方式"><a href="#2-2-基于Iframe及htmlfile的流（streaming）方式" class="headerlink" title="2.2 基于Iframe及htmlfile的流（streaming）方式"></a>2.2 基于Iframe及htmlfile的流（streaming）方式</h3><ul>
<li>定义：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。</li>
<li>实现方式：iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，服务器端将返回的数据作为客户端 JavaScript 函数的参数传递；客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码。（即是在返回的数据中嵌入JS脚本），例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;js_func(“data from server ”)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：Google 使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk 产品中。</li>
</ul>
<h2 id="3-SSE-（Server-Sent-Events）"><a href="#3-SSE-（Server-Sent-Events）" class="headerlink" title="3. SSE （Server-Sent Events）"></a>3. SSE （Server-Sent Events）</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/SSE.png" alt="SSE"></p>
<ul>
<li>定义：服务器向客户端声明，接下来要发送的是流信息（streaming）。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。本质上是以流信息的方式，完成一次用时很长的下载。</li>
<li>应用：视频播放</li>
<li>实现方式，参考 阮一峰的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程</a></li>
</ul>
<h2 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a>4. WebSocket</h2><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/websocket.png" alt="http与WebSocket"></p>
<ul>
<li>定义：WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。</li>
<li>特点：可以发送文本，也可以发送二进制数据。协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>
<li>基于client：javascript 和 server：java的实现：</li>
</ul>
<ol>
<li>maven添加websocket库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-websocket&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;exclusion&gt;</span><br><span class="line">  &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>server：</p>
<p> 有两种创建服务器端代码的方法：</p>
</li>
</ol>
<ul>
<li>注解方式(Annotation-driven): 通过在POJO加上注解, 开发者就可以处理WebSocket 生命周期事件。</li>
<li>实现接口方式(Interface-driven): 开发者可以实现Endpoint接口和声明周期的各个方法。</li>
</ul>
<p>添加配置类 WebSocketConfig 代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加处理连接和处理消息类 MyWebSocket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/websocket&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在线人数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> online = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//所有的对象，用于群发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;MyWebSocket&gt; webSockets = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//会话</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">getSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        online++;</span><br><span class="line">        webSockets.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接关闭</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        online--;</span><br><span class="line">        webSockets.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到客户端的消息</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">onMessage</span><span class="params">(String text, Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;client message: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>client:</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.WebSocket) &#123;</span><br><span class="line">  <span class="comment">// Create WebSocket connection.</span></span><br><span class="line">  <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080/websocket&#x27;</span>);</span><br><span class="line">  <span class="comment">// Connection opened</span></span><br><span class="line">  socket.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Connection closed</span></span><br><span class="line">  socket.addEventListener(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;I am leave!&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Listen for messages</span></span><br><span class="line">  socket.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 延时给服务端发送一条消息</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-基于MQ"><a href="#5-基于MQ" class="headerlink" title="5. 基于MQ"></a>5. 基于MQ</h2><ul>
<li>一般由webserver向webclient进行消息推送，中间并不包含第三者（中间件）。但是如对需要推送的消息具有更高层面的要求，例如 架构上松耦合、异步处理、消息管理、持久化、削峰填谷等。则可以利用消息中间件来完成消息的传递。而将webserver作为消息的生产者，发送消息经过MQ，传递到webclient的过程，就完成了基于MQ的服务器端的推送。</li>
<li>关于消息中间件可以参看这篇：<a href="https://ztxpp.cc/2019/05/06/MQ/">以activemq为例的消息中间件浅析</a></li>
<li>一种实现方式： js client(STOMP.js) + activeMQ + java server</li>
</ul>
<h1 id="2-推送技术的对比分析"><a href="#2-推送技术的对比分析" class="headerlink" title="2. 推送技术的对比分析"></a>2. 推送技术的对比分析</h1><ul>
<li><p>Ajax短轮询：</p>
<ul>
<li><p>优点：不用配置，非常简单，就是一个定时器。</p>
</li>
<li><p>缺点：</p>
<ol>
<li><p>轮询的时间间隔需要进行仔细考虑。<br>轮询的间隔过长，延迟高。会导致用户不能及时接收到更新的数据；轮询的间隔过短，server压力大。查询请求过多，增加服务器端的负担（每次轮询都会进行一次完整的HTTP请求，如果没有数据更新，相当于是一次“浪费”的请求）。</p>
</li>
<li><p>一旦遇到页面有大量任务或者返回时间特别耗时，页面可能会出现‘假死’，无法响应用户行为。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Comet：</p>
<ul>
<li>优点：减少了不必要的http请求次数。</li>
<li>缺点：连接挂起（hold）也会导致资源的浪费。</li>
<li>分析：轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是”在服务器端数据有了变化后，可以主动推送给客户端”,这种”主动型”服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案</li>
</ul>
</li>
<li><p>SSE:</p>
<ul>
<li>SSE单工，WebSocket双工</li>
<li>SSE 默认支持断线重连，WebSocket 需要自己实现。</li>
<li>一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li>
<li>SSE使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li>
</ul>
</li>
<li><p>WebSocket:</p>
<ul>
<li>从互联网协议的角度看：之前三者都是应用层基于TCP的HTTP协议，WebSocket则是应用层的另一个基于TCP协议；</li>
<li>是真正意义上的全双工通信。</li>
<li>实现起来，与前三种相比较为复杂。</li>
</ul>
</li>
<li><p>MQ:</p>
<ul>
<li>从协议角度看，消息中间件实现的协议，例如：<ul>
<li>AMQP（AdvancedMessage Queuing Protocol）即高级消息队列协议是应用层协议的一个开放标准</li>
<li>STOMP（Simple (or Streaming) Text Orientated Messaging Protocol），即简单的面向文本/流的消息协议，一般是Stomp Over Websocket，可以理解为基于WebSockets的一个协议。</li>
</ul>
</li>
<li>对于消息而言，可以满足更高层面的需求。</li>
</ul>
</li>
<li><p>几种连接方式的比较：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png" alt="连接方式的比较"></p>
</li>
</ul>
<h1 id="3-服务器推送举例分析"><a href="#3-服务器推送举例分析" class="headerlink" title="3. 服务器推送举例分析"></a>3. 服务器推送举例分析</h1><h2 id="3-1-淘宝网页版扫码登录"><a href="#3-1-淘宝网页版扫码登录" class="headerlink" title="3.1 淘宝网页版扫码登录"></a>3.1 淘宝网页版扫码登录</h2><ul>
<li><p>需求分析：淘宝，京东平台网页版，具有扫码登录环节，需要手机扫码配合完成登录流程。手机登录成功后，server端是如何将消息推送到web client的呢？下面就此进行分析。</p>
</li>
<li><p>抓包分析：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/%E6%B7%98%E5%AE%9D%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png" alt="抓包分析"></p>
<p>  只针对server是如何推送消息到web client这一阶段，进行抓包分析，可知使用的是时间间隔为大约5s的Ajax短轮询。</p>
</li>
<li><p>全流程时序分析</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/%E6%B7%98%E5%AE%9D%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="淘宝网页版扫码登录时序图"></p>
<p>  全流程时序分析不是本文的重点，大致分为三个阶段： 网页获取二维码阶段，网页短轮询阶段，手机扫码登录阶段。</p>
<ul>
<li>网页获取二维码阶段：web browser与 web server进行一次通信，网页显示出二维码信息。web server将此uuid信息返回给browser，并在缓存中以此 uuid为key进行保存，并且设置过期时间。</li>
<li>网页轮询阶段： web browser 通过5s一次的短轮询，希望从web server中获取手机是否已经扫码完成登录的信息，当未过期，或者为获取到userId信息时，重复请求。</li>
<li>手机扫码登录阶段： 手机端通过扫描二维码，获取到uuid和二维码验证信息，并辅以手机端登录态的token信息，向mobile server发起web端登录请求； server比对二维码信息后，恢复是否确认登录；手机端点击确认登陆后，server将此uuid做key, 用手机端登录态token中获取到的userId作value存入缓存中。并回复手机端登陆成功。</li>
<li>网页端轮询阶段：网页端轮询请求至此，web server便可以由uuid获取到 userId的信息，登陆成功，返回web token，跳转至首页。</li>
</ul>
</li>
</ul>
<h2 id="3-2-京东网页版扫码登录"><a href="#3-2-京东网页版扫码登录" class="headerlink" title="3.2 京东网页版扫码登录"></a>3.2 京东网页版扫码登录</h2><p>代码分析，可知是使用的短轮询。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loginGetEid</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span>(getJdEid) == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">                getJdEid(<span class="function"><span class="keyword">function</span>(<span class="params">eid,fp,udfp</span>)</span>&#123;</span><br><span class="line">                    $(<span class="string">&quot;#eid&quot;</span>).prop(<span class="string">&quot;value&quot;</span>, eid);</span><br><span class="line">                    $(<span class="string">&quot;#sessionId&quot;</span>).prop(<span class="string">&quot;value&quot;</span>, fp);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="string">&#x27;loginGetEid(&#x27;</span>+count+<span class="string">&#x27;)&#x27;</span>, <span class="number">300</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            $(<span class="string">&quot;#eid&quot;</span>).prop(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">            $(<span class="string">&quot;#sessionId&quot;</span>).prop(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="string">&#x27;loginGetEid(0)&#x27;</span>, <span class="number">1000</span>); <span class="comment">//1s后执行此方法，可能为了节省轮询的资源（用户不会那么快扫码完成）</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>分析：淘宝网页版的扫码登录，选用了Ajax短轮询技术，完成server向web client的推送。淘宝大约是5s的短轮询，京东登录是大约3s的短轮询。选择使用Ajax短轮询的原因：</p>
<ul>
<li>淘宝、京东网页版需要很高的浏览器兼容性。</li>
<li>与巨量用户在网页端的图片浏览和查询相比，3s和5s一次的短轮询占用带宽很小，而且扫码登录的实时性也不要求太高。在需求的范围内，节省资源。</li>
</ul>
<h2 id="3-3-微信网页版"><a href="#3-3-微信网页版" class="headerlink" title="3.3 微信网页版"></a>3.3 微信网页版</h2><p>微信网页版的扫码登录功能，由图可知，使用的是25s的长轮询。<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E7%89%88%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png" alt="微信网页版扫码登录"></p>
<p>微信网页版通信功能，也是基于长轮询实现。并未采用websocket，个人认为是考虑到 兼容性，和一定程度的实时性。（并未求证，截止2020.4.27日，已经无法登录微信网页版）</p>
<h2 id="3-4-webSocket应用"><a href="#3-4-webSocket应用" class="headerlink" title="3.4 webSocket应用"></a>3.4 webSocket应用</h2><ul>
<li>社交订阅</li>
<li>多玩家游戏</li>
<li>协同编辑/编程</li>
<li>点击流数据</li>
<li>股票基金报价w</li>
<li>体育实况更新</li>
<li>多媒体聊天</li>
<li>基于位置的应用</li>
<li>在线教育</li>
</ul>
<p>上述应用领域，都是在考虑实时性较高的情况下，使用webSocket。</p>
<blockquote>
<p>后文：同时代的技术，没有优劣之分，只有适不适合需求的区别。并非实时性越强越好，有时候需要考虑较多其他的因素。</p>
</blockquote>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#artrelatedtopics">Comet：基于 HTTP 长连接的“服务器推”技术</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://colobu.com/2015/02/27/WebSockets-tutorial-on-Wildfly-8/">Java WebSocket教程</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1589934">说说微信和淘宝扫码登录背后的实现原理</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/03/24/Mourning/">纪念徐中华老师</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-03-24
        </span></div>
    </header>

    <div class="post-content"><p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/%E7%BA%AA%E5%BF%B5%E5%BE%90%E4%B8%AD%E5%8D%8E%E8%80%81%E5%B8%88.jpg" alt="纪念徐中华老师"></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/11/06/java%E6%B3%9B%E5%9E%8B/">java泛型</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-11-06
        </span></div>
    </header>

    <div class="post-content"><blockquote>
<p>泛型的本质是 <strong>参数化类型</strong> 。主要作用是解决容器（类，数组）的继承关系。</p>
</blockquote>
<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><ul>
<li><p>类型参数：将类型作为可变的参数来表示。</p>
</li>
<li><p>有界类型参数：限制类型参数的类型种类范围。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T extends Number</span><br><span class="line">T extends Comparable&lt;T&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型通配符： 使用?代替具体的类型参数, 表示等所有&lt;具体类型实参&gt;的父类。</p>
</li>
<li><p>有界类型通配符</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? </span><br><span class="line">? extends Number</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>补充：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Difference between &lt;？ extends A&gt; and &lt;T extends A&gt; :</span><br><span class="line"></span><br><span class="line">The reason for declaring a T is so that you can refer to it again, which can binding two parameter types, or a return type together.</span><br></pre></td></tr></table></figure>
<h1 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2. 泛型方法"></a>2. 泛型方法</h1><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h2><ul>
<li><p>方法申明关键字： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</p>
</li>
<li><p>入参类型： 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</p>
</li>
<li><p>返回值类型： 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</p>
</li>
<li><p>限制：  泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是基本数据类型。</p>
</li>
</ul>
<h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">printArray</span><span class="params">(E[] inputArray)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inputArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;O&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;整型数组元素为:&quot;</span> );</span><br><span class="line">        printArray(intArray); <span class="comment">// 传递一个整型数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;\n双精度型数组元素为:&quot;</span> );</span><br><span class="line">        printArray(doubleArray); <span class="comment">// 传递一个双精度型数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;\n字符型数组元素为:&quot;</span> );</span><br><span class="line">        printArray(charArray); <span class="comment">// 传递一个字符型数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3. 泛型类"></a>3. 泛型类</h1><h2 id="1-用法-1"><a href="#1-用法-1" class="headerlink" title="1. 用法"></a>1. 用法</h2><ul>
<li>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。</li>
<li>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
</ul>
<h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">    Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">    stringBox.add(<span class="keyword">new</span> String(<span class="string">&quot;ztxpp&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">&quot;整型值为 :%d\n\n&quot;</span>, integerBox.get());</span><br><span class="line">    System.out.printf(<span class="string">&quot;字符串为 :%s\n&quot;</span>, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-类型通配符的PECS原则"><a href="#4-类型通配符的PECS原则" class="headerlink" title="4. 类型通配符的PECS原则"></a>4. 类型通配符的PECS原则</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul>
<li>PESC: Producer Extends Consumer Super<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;? extends T&gt; : 上界通配符</span><br><span class="line">&lt;? <span class="keyword">super</span> T&gt;: 下界通配符</span><br></pre></td></tr></table></figure>
<h2 id="2-举例说明"><a href="#2-举例说明" class="headerlink" title="2. 举例说明"></a>2. 举例说明</h2><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191106232816.png" alt="example1"></li>
</ul>
<p>构造如上的类，继承关系如图所示。</p>
<h3 id="1-有界类型通配符："><a href="#1-有界类型通配符：" class="headerlink" title="1. 有界类型通配符："></a>1. 有界类型通配符：</h3><p>下面两种表达对应下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt;</span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191106233502.png" alt="example2"></p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/20191106233655.png" alt="example2"></p>
<h3 id="2-PECS原则："><a href="#2-PECS原则：" class="headerlink" title="2. PECS原则："></a>2. PECS原则：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// situation1：</span></span><br><span class="line">Plate&lt;? extends Fruit&gt; p1=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple()); </span><br><span class="line">p1.set(<span class="keyword">new</span> Fruit()); <span class="comment">//ERROR</span></span><br><span class="line">p1.set(<span class="keyword">new</span> Apple()); <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line">Fruit fruit = p1.get();  <span class="comment">// OK</span></span><br><span class="line">Food food = p1.get();  <span class="comment">// OK</span></span><br><span class="line">Apple apple = p1.get();  <span class="comment">// ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//situation2:</span></span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p2 = <span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());  </span><br><span class="line">p2.set(<span class="keyword">new</span> Fruit()) <span class="comment">// OK</span></span><br><span class="line">p2.set(<span class="keyword">new</span> Apple()) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">Apple apple = p2.get();  <span class="comment">//ERROR</span></span><br><span class="line">Fruit fruit = p.get();    <span class="comment">//ERROR</span></span><br><span class="line">Object object = p2.get(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>situation1：<ul>
<li>set难：编译器只知道？是Fruit或其子类，但不知道具体是哪一个，万一Plate里面定义的是装 low level的水果，但是用户希望set的是 high level的水果，则不允许。</li>
<li>get易：根据多态，只要申明的类型&gt;=Fruit, 就都可以承载p1.get()出来的东西。</li>
</ul>
</li>
<li>situation2：<ul>
<li>set： 根据多态，plate定义的是可以装下&gt;=Fruit的东西，所以Fruit及其子类都可以set进入。</li>
<li>get: 由于编译器不知道&gt;=Fruit的东西到底是大到什么类型，所以get出来的东西只能用 Object来承载。</li>
</ul>
</li>
</ul>
<p>PESC: </p>
<p>频繁往外读取内容的，适合用上界Extends; 经常往里插入的，适合用下界Super。</p>

        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zhutianpeng</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
