<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="SpringCloud"/><meta name="keywords" content="java - SpringCloud - 微服务, Ztxpp's Blog" /><link rel="alternate" href="/default" title="Ztxpp's Blog" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="zhutianpeng.github.io/2019/04/14/SpringCloud/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>SpringCloud - Ztxpp's Blog</title>
  <meta name="generator" content="Hexo 5.1.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ztxpp's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/Base/">
        <li class="mobile-menu-item">文档
          </li>
      </a><a href="/life/">
        <li class="mobile-menu-item">生活
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ztxpp's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/Base/">
            文档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/life/">
            生活
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">SpringCloud
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-14
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E6%80%BB%E4%BD%93%E6%8A%8A%E6%8F%A1"><span class="toc-text">一.总体把握</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%9A"><span class="toc-text">架构发展史：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-text">组件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%A4%A7%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">两大实现方案：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">组件概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AE%A1%E7%90%86%E5%AD%A6%EF%BC%88%E5%BA%B7%E8%BE%89%E5%AE%9A%E5%BE%8B%EF%BC%89%E3%80%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B2%BE%E9%AB%93%E3%80%91"><span class="toc-text">微服务的管理学（康辉定律）【微服务的精髓】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88Eureka%EF%BC%89"><span class="toc-text">二.服务的注册与发现（Eureka）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">搭建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3"><span class="toc-text">服务注册的一些理解</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><p>SpringCloud系列学习  </p>
<p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。   </p>
<h1 id="一-总体把握"><a href="#一-总体把握" class="headerlink" title="一.总体把握"></a>一.总体把握</h1><h2 id="架构发展史："><a href="#架构发展史：" class="headerlink" title="架构发展史："></a>架构发展史：</h2><p><img src="http://selfstudy.oss-cn-beijing.aliyuncs.com/blog/1.%20%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="架构发展史"></p>
<ul>
<li><p>单一应用架构：</p>
<p>  就一个应用，所有功能聚合在一起，以减少部署节点和成本，ORM是关键</p>
</li>
<li><p>垂直应用架构：</p>
<p>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架（MVC）是关键。</p>
</li>
<li><p>分布式服务架构：</p>
<p>  当垂直应用逐渐增多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快的响应多变的市场需求。此时，用于提高业务复用以及整合的分布式服务框架（RPC）是关键。</p>
<p>  旨在支持应用程序和服务开发，可以利用物理架构由多个自制的处理元素，不共享主内存，但通过网络发送消息合作。</p>
</li>
<li><p>流动计算架构：</p>
<p>  当服务增多，容量的评估，小服务器资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心（SOA）是关键。</p>
</li>
</ul>
<h2 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h2><ul>
<li>服务注册与发现</li>
<li>服务网关：前端路由，连接内外的大门，屏蔽内部细节，路由功能，限流，容错，监控，日志</li>
<li>后端通用服务：（也称中间层服务 Middle Tier Service）</li>
<li>前端服务：(也称边缘服务 Edge Service)：聚合，裁剪后端服务，暴露。<ul>
<li>聚合： eg: 将多个API合并成一个</li>
<li>裁剪： eg: 同一个接口，PC端调用返回得多，移动端调用返回的信息少</li>
</ul>
</li>
</ul>
<h2 id="两大实现方案："><a href="#两大实现方案：" class="headerlink" title="两大实现方案："></a>两大实现方案：</h2><ul>
<li><p>阿里系：</p>
<ul>
<li>Dubbo: 服务化治理</li>
<li>Zookeeper: 服务注册中心</li>
<li>SpringMVC or SpringBoot：</li>
</ul>
</li>
<li><p>Spring Cloud 全家桶:</p>
<ul>
<li><p>Spring Cloud Netflix Eureka</p>
</li>
<li><p>SpringBoot</p>
<p>Spring Cloud 的版本：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><p>参考知乎，以订单服务、库存服务、仓储服务、积分服务为例</p>
<p>具体业务例如：用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态。订单服务调用库存服务，完成相应功能；订单服务调用仓储服务，完成相应功能；订单服务调用积分服务，完成相应功能。</p>
<ul>
<li><p>Eureka：</p>
<ul>
<li><p>EurekaClient：负责将这个服务的信息注册到Eureka Server中</p>
</li>
<li><p>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/2.Eureka%E4%B8%BE%E4%BE%8B.jpg" alt="Eureka举例"></p>
<p>订单服务本地有一个Eureka的client，会去远端的Eureka server询问 需要调用的其他服务（库存、仓储、积分）的地址和端口，并且拉取到本地缓存。 之后订单服务就可以 调用 其他三种服务。</p>
</li>
</ul>
</li>
<li><p>Feign:</p>
<ul>
<li><p>Feign使用了动态代理，Feign Client会在底层根据注解，跟指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/3.Feign%E4%B8%BE%E4%BE%8B.jpg" alt="Feign举例"></p>
<p>对一个接口定义@FeignClient注解，Feign就会针对这个接口创建一个动态代理；接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心；Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址；最后针对这个地址，发起请求、解析响应</p>
</li>
</ul>
</li>
<li><p>Ribbon:</p>
<ul>
<li><p>负载均衡</p>
</li>
<li><p>载均衡默认使用的最经典的Round Robin轮询算法，将服务均匀的依次发送到对应的机器（1,2,3,4,1,2,3,4…）<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/4.Ribbon%E4%B8%BE%E4%BE%8B.jpg" alt="Ribbon举例"></p>
<p>Ribbon是和Feign以及Eureka紧密协作，完成工作的。</p>
</li>
</ul>
<ol>
<li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号；  </li>
<li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器；</li>
<li>Feign就会针对这台机器，构造并发起请求  </li>
</ol>
</li>
<li><p>Hystrix:</p>
<ul>
<li><p>Hystrix是隔离、熔断以及降级的一个框架。</p>
</li>
<li><p>Hystrix会有很多个小小的线程池，每个服务职能调用自己的线程池里面的线程，线程卡住了，不会影响到其他服务的线程调用。</p>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/5.Hystrix%E4%B8%BE%E4%BE%8B.jpg" alt="Hystrix举例"></p>
<p>库存服务、仓储服务、积分服务分别有自己的线程池，当积分服务down掉后，不会影响库存和仓储，积分服务自己会选择做服务熔断或者服务降级，然后去故障数据库里记录数据。</p>
</li>
</ul>
</li>
<li><p>Zuul：</p>
</li>
<li><p>网关</p>
</li>
<li><p>可以做：统一的降级、限流、认证授权、安全</p>
<p>  像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务</p>
</li>
<li><p>整体的架构图：</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/6.%20%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="整体架构图举例"></p>
</li>
</ul>
<h2 id="微服务的管理学（康辉定律）【微服务的精髓】"><a href="#微服务的管理学（康辉定律）【微服务的精髓】" class="headerlink" title="微服务的管理学（康辉定律）【微服务的精髓】"></a>微服务的管理学（康辉定律）【微服务的精髓】</h2><blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.<br>—— 任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致</p>
</blockquote>
<p>ztp: 什么样的系统适合用微服务架构来设计，涉及到系统本身的功能，团队的人员配置与管理。</p>
<ul>
<li>传统团队：将不同能力的人才从资源池里面选调出来完成项目，项目结束后释放人才资源。</li>
<li>微服务团队：人员组织是团队模式，倾向于让团队负责整个服务（模块）的生命周期，以提供更优质的服务。小团队里面要能自己处理从前端到后端，从开发到运维部署的所有事情。  </li>
</ul>
<p><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/11.%E4%BC%A0%E7%BB%9F%E5%9B%A2%E9%98%9F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9B%A2%E9%98%9F.png" alt="传统团队与微服务团队">  </p>
<h1 id="二-服务的注册与发现（Eureka）"><a href="#二-服务的注册与发现（Eureka）" class="headerlink" title="二.服务的注册与发现（Eureka）"></a>二.服务的注册与发现（Eureka）</h1><ul>
<li>Eureka: 属于 Spring-cloud-netflix包下，主要内容是对Netflix公司一系列开源产品的包装</li>
<li>本章节采用基于下列版本来搭建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring-boot:  1.5.4.RELEASE</span><br><span class="line">spring-cloud: Dalston.SR1</span><br></pre></td></tr></table></figure>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2></li>
</ul>
<p>参考 程序猿DD的这篇博客</p>
<ol>
<li><p>使用IDEA创建一个工程Spring-Cloud-Demo</p>
</li>
<li><p>创建 Eureka-server</p>
</li>
</ol>
<ul>
<li>新建一个Module名为 Eureka-server，注意：new -module -&gt; spring initializr -&gt; Cloud Discovery -&gt; Eureka Server</li>
<li>并在pom.xml中引入相应的依赖；【注意对应的版本信息】</li>
<li>在主类中添加这个@EnableEurekaServer注解，启动一个服务注册中心提供给其他应用进行对话</li>
<li>将“服务注册中心自己作为客户端来尝试注册它自己”的功能禁掉。需要在 application.properties/application.yml 配置文件里面添加一些信息，我的application.yml如下：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动工程,访问 <a target="_blank" rel="noopener" href="http://localhost:1001/">http://localhost:1001/</a> ,此时没有任何服务来注册</li>
</ul>
<ol start="3">
<li>创建“服务提供方” Eureka-Client</li>
</ol>
<ul>
<li><p>创建一个基本的Spring Boot应用。命名为 eureka-client</p>
</li>
<li><p>在pom.xml中，加入相应配置， 大概是spring-boot的版本信息，和Spring Cloud的版本信息。</p>
</li>
<li><p>添加相应的接口和服务信息（这一步实际工程会有）</p>
</li>
<li><p>在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现</p>
</li>
<li><p>配置application.properties/application.yml，我的application.yml如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1001/eureka/</span> <span class="comment">#此处应当能找到上面定义的 server</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务，能观察到服务已经被注册进eureka中心<br><img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/7.eureka.png" alt="eureka示例"></p>
</li>
</ul>
<ol start="4">
<li>Eureka的高可用</li>
</ol>
<ul>
<li><p>两个Eureka互相注册</p>
<p>  注意在测试的时候会出现更新不及时的情况，是由于eureka的心跳检测机制引起的，重启eureka即可</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/8.euraka%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="Eureka的高可用"></p>
</li>
<li><p>利用IDEA,Edit configuration -&gt; copy 一份 eureka server， 给两个server修改启动参数的 VM options 分别为 -Dserver.port=8761 和 -Dserver.port=8762。</p>
</li>
<li><p>启动server1前，修改其配置文件如下，并启动server1：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#register-with-eureka: true</span></span><br><span class="line">    <span class="comment"># 表示是否从Eureka Server获取注册信息，默认为true。 如果这是一个单点的 Eureka Server，不需要同步其他节  点的数据，可以设为false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8762/eureka/</span> <span class="comment"># 意思是让server1在server2中注册</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#  关闭自我保护模式，只能在开发环境这样做，生产环境需要打开</span></span><br><span class="line">    <span class="comment">#    port: 1001</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动server2前，修改其配置文件如下，并启动server2：</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#    register-with-eureka: true</span></span><br><span class="line">    <span class="comment"># 表示是否从Eureka Server获取注册信息，默认为true。 如果这是一个单点的 Eureka Server，不需要同步其他节  点的数据，可以设为false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">          <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span>  <span class="comment"># 意思是让server2在server1中注册</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#  关闭自我保护模式，只能在开发环境这样做，生产环境需要打开</span></span><br><span class="line">    <span class="comment">#    port: 1001</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>eureka-client照常启动即可，注意只需要在一个server1中注册，即可将注册信息同步到server2；</p>
<p>  挂掉server1,发现client仍然在server2上面注册存在；</p>
<p>  但是如果server1挂掉了，再重启client,则会发现server2上的client也不复存在，所以最保险的做法应该是如下的配置：(配置多台server的地址)</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">2001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大集群三个eureka的相互注册，延伸一下即可,server之间两两相互注册，并且client注册三个server</p>
<p>  <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/9.eureka%E9%AB%98%E5%8F%AF%E7%94%A8.png" alt="三个eureka的相互注册"></p>
</li>
</ul>
<h2 id="服务注册的一些理解"><a href="#服务注册的一些理解" class="headerlink" title="服务注册的一些理解"></a>服务注册的一些理解</h2><ol>
<li><p>为什么要在分布式系统中使用 “服务发现”：  </p>
<p> <img src="https://selfstudy.oss-cn-beijing.aliyuncs.com/blog/10.eureka%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.png" alt="为什么要在分布式系统中使用 “服务发现”"></p>
</li>
</ol>
<p>随着集群中机器数量的增加，B的数量过多，不适合用写配置文件的方式来记录</p>
<ol start="2">
<li>服务发现的两种分类（需要权衡）：</li>
</ol>
<ul>
<li><p>客户端发现：</p>
<ul>
<li>由A发起，去注册中心找到一个B，然后通过ip地址调用B。关键点在于：使用某种“负载均衡”的机制来选择提供服务的一台机器， 例如： 轮训，随机，哈希等。</li>
<li>优点：简单，不需要代理的介入，client知道所有服务提供方的地址。</li>
<li>缺点：client需要自己实现一套逻辑来挑选服务提供方。</li>
<li>举例： Eureka</li>
</ul>
</li>
<li><p>服务端发现：</p>
<ul>
<li>增加一个新的角色：代理。 代理帮助A从众多可用的B中找到一个。</li>
<li>优点：B对A是不可见的，A只需要访问代理即可。</li>
<li>举例： Nginx, Dubbo系的Zookeeper, Kubernetes(k8s：集群中的每一个节点都运行一个代理，来实现服务发现的功能)</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>pringCloud的服务调用方式（不同语言怎么在eureka中注册）</p>
<p> eureka允许其他语言被纳入到他的服务治理体系中去，具体是这种语言需要实现eureka的客户端程序，例如 node.js实现了eureka-js-client。</p>
</li>
</ol>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="zhutianpeng.github.io">zhutianpeng</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="zhutianpeng.github.io/2019/04/14/SpringCloud/">zhutianpeng.github.io/2019/04/14/SpringCloud/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1/">java - SpringCloud - 微服务</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/04/18/taobao-read/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">《淘宝技术这十年》</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/03/27/concurrent/">
        <span class="next-text nav-default">java并发</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zhutianpeng</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
